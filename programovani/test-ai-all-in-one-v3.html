<!DOCTYPE html>
<html lang="cs">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Modul - Testov√°n√≠</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
        min-height: 100vh;
        color: #e2e8f0;
        padding: 20px;
      }

      .container {
        max-width: 1000px;
        margin: 0 auto;
      }

      h1 {
        text-align: center;
        color: #38bdf8;
        margin-bottom: 30px;
        font-size: 28px;
      }

      .card {
        background: rgba(30, 41, 59, 0.8);
        backdrop-filter: blur(10px);
        border-radius: 16px;
        padding: 24px;
        margin-bottom: 20px;
        border: 1px solid rgba(71, 85, 105, 0.5);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      }

      .card-title {
        font-size: 14px;
        color: #94a3b8;
        margin-bottom: 16px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .card-title .icon {
        font-size: 18px;
      }

      /* Tabs pro providery */
      .provider-tabs {
        display: flex;
        gap: 8px;
        margin-bottom: 20px;
        flex-wrap: wrap;
      }

      .provider-tab {
        padding: 12px 20px;
        background: rgba(51, 65, 85, 0.5);
        border: 1px solid #475569;
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .provider-tab:hover {
        background: rgba(71, 85, 105, 0.7);
        border-color: #64748b;
      }

      .provider-tab.active {
        background: linear-gradient(135deg, #3b82f6, #8b5cf6);
        border-color: transparent;
        color: white;
      }

      .provider-tab .emoji {
        font-size: 18px;
      }

      /* Model select */
      .model-section {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 15px;
        align-items: end;
        margin-bottom: 20px;
      }

      label {
        display: block;
        font-size: 12px;
        color: #94a3b8;
        margin-bottom: 6px;
      }

      select,
      input,
      textarea {
        width: 100%;
        padding: 12px 14px;
        background: rgba(15, 23, 42, 0.8);
        border: 1px solid #475569;
        border-radius: 10px;
        color: #e2e8f0;
        font-size: 14px;
        transition: border-color 0.2s;
      }

      select:focus,
      input:focus,
      textarea:focus {
        outline: none;
        border-color: #3b82f6;
      }

      select option {
        background: #1e293b;
        padding: 10px;
      }

      .model-info {
        background: rgba(59, 130, 246, 0.1);
        border: 1px solid rgba(59, 130, 246, 0.3);
        border-radius: 10px;
        padding: 12px 16px;
        font-size: 12px;
        color: #93c5fd;
        white-space: nowrap;
      }

      .model-info .rpm {
        font-size: 20px;
        font-weight: bold;
        color: #60a5fa;
      }

      /* API Keys */
      .keys-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 10px;
        max-height: 200px;
        overflow-y: auto;
        padding-right: 8px;
      }

      .keys-grid::-webkit-scrollbar {
        width: 6px;
      }

      .keys-grid::-webkit-scrollbar-track {
        background: rgba(51, 65, 85, 0.3);
        border-radius: 3px;
      }

      .keys-grid::-webkit-scrollbar-thumb {
        background: #475569;
        border-radius: 3px;
      }

      .key-input-group {
        position: relative;
      }

      .key-input-group input {
        padding-right: 40px;
      }

      .key-status {
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 16px;
      }

      .key-status.ok {
        color: #22c55e;
      }
      .key-status.demo {
        color: #f59e0b;
      }
      .key-status.none {
        color: #64748b;
      }

      /* Buttons */
      .btn-row {
        display: flex;
        gap: 10px;
        margin-top: 15px;
        flex-wrap: wrap;
      }

      button {
        padding: 12px 24px;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .btn-primary {
        background: linear-gradient(135deg, #3b82f6, #2563eb);
        color: white;
      }
      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
      }
      .btn-primary:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .btn-secondary {
        background: rgba(71, 85, 105, 0.5);
        color: #e2e8f0;
        border: 1px solid #475569;
      }
      .btn-secondary:hover {
        background: rgba(71, 85, 105, 0.8);
      }

      .btn-success {
        background: linear-gradient(135deg, #22c55e, #16a34a);
        color: white;
      }

      .btn-danger {
        background: rgba(239, 68, 68, 0.2);
        color: #f87171;
        border: 1px solid rgba(239, 68, 68, 0.3);
      }

      /* Chat area */
      .chat-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      .system-prompt {
        background: rgba(139, 92, 246, 0.1);
        border: 1px solid rgba(139, 92, 246, 0.3);
        border-radius: 10px;
        padding: 12px;
      }

      .system-prompt textarea {
        background: transparent;
        border: none;
        resize: vertical;
        min-height: 60px;
      }

      .prompt-area textarea {
        min-height: 100px;
        resize: vertical;
      }

      /* Token counter */
      .token-counter {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 8px;
        font-size: 11px;
        color: #64748b;
      }

      .token-cost {
        color: #fbbf24;
      }

      /* Image upload */
      .image-upload-section {
        background: rgba(139, 92, 246, 0.1);
        border: 1px solid rgba(139, 92, 246, 0.3);
        border-radius: 10px;
        padding: 12px;
      }

      .image-upload-section label {
        color: #c4b5fd;
      }

      .image-upload-area {
        border: 2px dashed #475569;
        border-radius: 10px;
        padding: 20px;
        text-align: center;
        cursor: pointer;
        transition: all 0.2s;
        background: rgba(15, 23, 42, 0.5);
        min-height: 80px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .image-upload-area:hover {
        border-color: #8b5cf6;
        background: rgba(139, 92, 246, 0.1);
      }

      .image-upload-area.dragover {
        border-color: #a78bfa;
        background: rgba(139, 92, 246, 0.2);
      }

      .upload-placeholder {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        color: #94a3b8;
      }

      .upload-placeholder .upload-icon {
        font-size: 32px;
      }

      .image-preview {
        position: relative;
        display: inline-block;
      }

      .image-preview img {
        max-width: 200px;
        max-height: 150px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .remove-image {
        position: absolute;
        top: -8px;
        right: -8px;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: #ef4444;
        color: white;
        border: none;
        cursor: pointer;
        font-size: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }

      .remove-image:hover {
        background: #dc2626;
      }

      .image-info {
        margin-top: 8px;
        font-size: 11px;
        color: #a78bfa;
      }

      /* Response section */
      .response-section {
        margin-top: 20px;
        padding-top: 20px;
        border-top: 1px solid #334155;
      }

      .response-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }

      .response-header label {
        margin: 0;
        font-size: 13px;
        color: #94a3b8;
      }

      .response-actions {
        display: flex;
        gap: 6px;
      }

      .btn-small {
        padding: 6px 10px;
        font-size: 12px;
        background: rgba(51, 65, 85, 0.5);
        border: 1px solid #475569;
        border-radius: 6px;
        color: #e2e8f0;
        cursor: pointer;
        transition: all 0.2s;
      }

      .btn-small:hover {
        background: rgba(71, 85, 105, 0.8);
      }

      .response-footer {
        margin-top: 10px;
        font-size: 11px;
        color: #64748b;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      /* Chat history */
      .chat-history {
        max-height: 400px;
        overflow-y: auto;
        padding: 12px 0;
      }

      .history-empty {
        text-align: center;
        color: #64748b;
        padding: 20px;
        font-style: italic;
      }

      .history-item {
        background: rgba(15, 23, 42, 0.6);
        border-radius: 10px;
        padding: 12px;
        margin-bottom: 10px;
        border-left: 3px solid #3b82f6;
      }

      .history-item .history-meta {
        display: flex;
        justify-content: space-between;
        font-size: 11px;
        color: #64748b;
        margin-bottom: 8px;
      }

      .history-item .history-prompt {
        color: #93c5fd;
        font-size: 13px;
        margin-bottom: 8px;
        padding-bottom: 8px;
        border-bottom: 1px solid #334155;
      }

      .history-item .history-response {
        color: #e2e8f0;
        font-size: 13px;
        white-space: pre-wrap;
        max-height: 150px;
        overflow-y: auto;
      }

      .history-item .history-actions {
        margin-top: 8px;
        display: flex;
        gap: 6px;
      }

      /* Output */
      #output {
        background: rgba(15, 23, 42, 0.9);
        border: 1px solid #334155;
        border-radius: 12px;
        padding: 20px;
        min-height: 200px;
        max-height: 500px;
        overflow-y: auto;
        white-space: pre-wrap;
        font-family: "Monaco", "Consolas", "Courier New", monospace;
        font-size: 13px;
        line-height: 1.6;
      }

      #output.loading {
        color: #64748b;
        font-style: italic;
      }

      #output.error {
        color: #f87171;
        background: rgba(239, 68, 68, 0.1);
        border-color: rgba(239, 68, 68, 0.3);
      }

      /* Chat bubliny */
      .chat-container {
        background: rgba(15, 23, 42, 0.9);
        border: 1px solid #334155;
        border-radius: 12px;
        padding: 15px;
        min-height: 300px;
        max-height: 500px;
        overflow-y: auto;
        margin-bottom: 15px;
      }

      .chat-message {
        display: flex;
        margin-bottom: 12px;
        animation: fadeIn 0.3s ease;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .chat-message.user {
        justify-content: flex-end;
      }

      .chat-message.assistant {
        justify-content: flex-start;
      }

      .chat-bubble {
        max-width: 80%;
        padding: 12px 16px;
        border-radius: 16px;
        font-size: 14px;
        line-height: 1.5;
        white-space: pre-wrap;
        word-wrap: break-word;
      }

      .chat-message.user .chat-bubble {
        background: linear-gradient(135deg, #3b82f6, #2563eb);
        color: white;
        border-bottom-right-radius: 4px;
      }

      .chat-message.assistant .chat-bubble {
        background: rgba(51, 65, 85, 0.8);
        color: #e2e8f0;
        border-bottom-left-radius: 4px;
      }

      .chat-message.assistant .chat-bubble.error {
        background: rgba(239, 68, 68, 0.2);
        border: 1px solid rgba(239, 68, 68, 0.4);
        color: #f87171;
      }

      .chat-message.assistant .chat-bubble.loading {
        color: #94a3b8;
        font-style: italic;
      }

      .chat-input-area {
        display: flex;
        gap: 10px;
        align-items: flex-end;
      }

      .chat-input-area textarea {
        flex: 1;
        min-height: 50px;
        max-height: 150px;
        resize: none;
      }

      .chat-input-area button {
        height: 50px;
        padding: 0 20px;
      }

      .btn-upload {
        height: 50px;
        width: 50px;
        padding: 0;
        background: rgba(51, 65, 85, 0.8);
        border: 1px solid #475569;
        border-radius: 10px;
        color: #e2e8f0;
        cursor: pointer;
        font-size: 18px;
        transition: all 0.2s;
        flex-shrink: 0;
      }

      .btn-upload:hover {
        background: rgba(71, 85, 105, 0.9);
        transform: scale(1.05);
      }

      .file-preview-bar {
        background: rgba(59, 130, 246, 0.1);
        border: 1px solid rgba(59, 130, 246, 0.3);
        border-radius: 10px;
        padding: 8px 12px;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
      }

      .file-preview-item {
        display: flex;
        align-items: center;
        gap: 8px;
        flex: 1;
      }

      .file-preview-item img {
        width: 40px;
        height: 40px;
        object-fit: cover;
        border-radius: 6px;
      }

      .file-preview-item .file-icon {
        font-size: 24px;
      }

      .file-preview-item .file-name {
        flex: 1;
        font-size: 13px;
        color: #93c5fd;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .remove-file-btn {
        background: rgba(239, 68, 68, 0.2);
        border: none;
        color: #f87171;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .remove-file-btn:hover {
        background: rgba(239, 68, 68, 0.4);
      }

      .chat-message .attachment-preview {
        margin-top: 8px;
        max-width: 200px;
      }

      .chat-message .attachment-preview img {
        max-width: 100%;
        border-radius: 8px;
      }

      .chat-message .attachment-file {
        background: rgba(0, 0, 0, 0.2);
        padding: 6px 10px;
        border-radius: 6px;
        font-size: 12px;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .chat-empty {
        text-align: center;
        color: #64748b;
        padding: 40px;
        font-style: italic;
      }

      /* Status bar */
      .status-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        background: rgba(15, 23, 42, 0.6);
        border-radius: 10px;
        font-size: 12px;
        color: #94a3b8;
      }

      .status-badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 12px;
        border-radius: 20px;
        font-weight: 500;
      }

      .status-badge.ready {
        background: rgba(34, 197, 94, 0.2);
        color: #4ade80;
      }
      .status-badge.loading {
        background: rgba(59, 130, 246, 0.2);
        color: #60a5fa;
      }
      .status-badge.error {
        background: rgba(239, 68, 68, 0.2);
        color: #f87171;
      }
      .status-badge.success {
        background: rgba(34, 197, 94, 0.2);
        color: #4ade80;
      }

      /* Responsive */
      @media (max-width: 600px) {
        .provider-tabs {
          flex-direction: column;
        }
        .provider-tab {
          justify-content: center;
        }
        .model-section {
          grid-template-columns: 1fr;
        }
        .keys-grid {
          grid-template-columns: 1fr;
        }
        .model-card {
          grid-template-columns: 1fr;
          gap: 8px;
        }
      }

      /* Animations */
      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      .loading-dots {
        display: inline-flex;
        gap: 4px;
      }

      .loading-dots span {
        width: 8px;
        height: 8px;
        background: #60a5fa;
        border-radius: 50%;
        animation: pulse 1.4s infinite;
      }

      .loading-dots span:nth-child(2) {
        animation-delay: 0.2s;
      }
      .loading-dots span:nth-child(3) {
        animation-delay: 0.4s;
      }

      /* Collapsible */
      .collapsible-header {
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .collapsible-header .arrow {
        transition: transform 0.2s;
      }

      .collapsible-header.open .arrow {
        transform: rotate(180deg);
      }

      .collapsible-content {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease-out;
      }

      .collapsible-content.open {
        max-height: 800px;
      }

      /* Mini collapsible sections */
      .collapsible-section {
        margin: 12px 0;
      }

      .collapsible-header-mini {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 14px;
        background: rgba(51, 65, 85, 0.3);
        border-radius: 8px;
        cursor: pointer;
        font-size: 13px;
        color: #94a3b8;
        transition: all 0.2s;
      }

      .collapsible-header-mini:hover {
        background: rgba(51, 65, 85, 0.5);
        color: #e2e8f0;
      }

      .collapsible-content-mini {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease, padding 0.3s ease;
      }

      .collapsible-content-mini.open {
        max-height: 300px;
        padding-top: 12px;
      }

      .collapsible-content-mini textarea {
        margin-top: 0;
      }

      .collapsible-content-mini .btn-row {
        margin-top: 0;
      }

      /* Modal */
      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(5px);
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }

      .modal-content {
        background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
        border-radius: 20px;
        max-width: 800px;
        width: 100%;
        max-height: 85vh;
        display: flex;
        flex-direction: column;
        border: 1px solid #334155;
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
      }

      .modal-content.modal-wide {
        max-width: 1000px;
      }

      #testResults,
      #modelsResults {
        flex: 1;
        overflow-y: auto;
        max-height: 50vh;
      }

      .models-results {
        padding: 0 24px 24px;
      }

      .model-card {
        background: rgba(15, 23, 42, 0.6);
        border-radius: 10px;
        padding: 12px 16px;
        margin-bottom: 8px;
        display: grid;
        grid-template-columns: 1fr auto auto;
        gap: 12px;
        align-items: center;
        transition: all 0.2s;
      }

      .model-card:hover {
        background: rgba(30, 41, 59, 0.8);
      }

      .model-card.available {
        border-left: 3px solid #22c55e;
      }

      .model-card.missing {
        border-left: 3px solid #ef4444;
        opacity: 0.7;
      }

      .model-card.new {
        border-left: 3px solid #3b82f6;
        background: rgba(59, 130, 246, 0.1);
      }

      .model-card .model-name {
        font-weight: 500;
        color: #f1f5f9;
      }

      .model-card .model-id {
        font-size: 11px;
        color: #64748b;
        font-family: monospace;
      }

      .model-card .model-badges {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
      }

      .badge {
        padding: 3px 8px;
        border-radius: 12px;
        font-size: 10px;
        font-weight: 500;
      }

      .badge.free {
        background: rgba(34, 197, 94, 0.2);
        color: #4ade80;
      }

      .badge.paid {
        background: rgba(251, 191, 36, 0.2);
        color: #fbbf24;
      }

      .badge.vision {
        background: rgba(139, 92, 246, 0.2);
        color: #a78bfa;
      }

      .badge.new-badge {
        background: rgba(59, 130, 246, 0.2);
        color: #60a5fa;
      }

      .badge.missing-badge {
        background: rgba(239, 68, 68, 0.2);
        color: #f87171;
      }

      .model-card .model-context {
        font-size: 11px;
        color: #94a3b8;
        text-align: right;
      }

      .model-card .add-btn {
        padding: 4px 10px;
        font-size: 11px;
        background: rgba(59, 130, 246, 0.2);
        border: 1px solid rgba(59, 130, 246, 0.3);
        color: #60a5fa;
        border-radius: 6px;
        cursor: pointer;
      }

      .model-card .add-btn:hover {
        background: rgba(59, 130, 246, 0.4);
      }

      /* Compare models */
      .compare-results {
        padding: 0 24px 24px;
      }

      .compare-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
        gap: 16px;
      }

      .compare-card {
        background: rgba(15, 23, 42, 0.6);
        border-radius: 12px;
        padding: 16px;
        border-left: 3px solid #3b82f6;
      }

      .compare-card.loading {
        border-left-color: #fbbf24;
      }

      .compare-card.success {
        border-left-color: #22c55e;
      }

      .compare-card.error {
        border-left-color: #ef4444;
      }

      .compare-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
        padding-bottom: 10px;
        border-bottom: 1px solid #334155;
      }

      .compare-card-title {
        font-weight: 600;
        color: #f1f5f9;
      }

      .compare-card-meta {
        font-size: 11px;
        color: #64748b;
      }

      .compare-card-response {
        color: #e2e8f0;
        font-size: 13px;
        line-height: 1.6;
        white-space: pre-wrap;
        max-height: 300px;
        overflow-y: auto;
      }

      .compare-card-response.loading-text {
        color: #fbbf24;
        font-style: italic;
      }

      .compare-card-response.error-text {
        color: #f87171;
      }

      .compare-model-select {
        margin-bottom: 16px;
        padding: 16px;
        background: rgba(30, 41, 59, 0.5);
        border-radius: 10px;
      }

      .compare-model-select label {
        display: block;
        margin-bottom: 8px;
        color: #94a3b8;
        font-size: 13px;
      }

      .compare-checkboxes {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .compare-checkbox {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        background: rgba(51, 65, 85, 0.5);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 12px;
      }

      .compare-checkbox:hover {
        background: rgba(71, 85, 105, 0.8);
      }

      .compare-checkbox.selected {
        background: rgba(59, 130, 246, 0.3);
        border: 1px solid rgba(59, 130, 246, 0.5);
      }

      .compare-checkbox input {
        display: none;
      }

      /* Mini Console */
      #miniConsole {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: 200px;
        background: #0d1117;
        border-top: 2px solid #30363d;
        z-index: 9999;
        font-family: "Consolas", "Monaco", monospace;
        font-size: 12px;
      }

      .console-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 6px 12px;
        background: #161b22;
        border-bottom: 1px solid #30363d;
        color: #8b949e;
        font-size: 13px;
      }

      #consoleOutput {
        height: calc(100% - 32px);
        overflow-y: auto;
        padding: 8px 12px;
      }

      .console-log {
        color: #c9d1d9;
      }
      .console-error {
        color: #f85149;
      }
      .console-warn {
        color: #d29922;
      }
      .console-info {
        color: #58a6ff;
      }

      .console-entry {
        padding: 3px 0;
        border-bottom: 1px solid #21262d;
        word-break: break-all;
      }

      #consoleToggle {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background: #238636;
        border: none;
        font-size: 24px;
        cursor: pointer;
        z-index: 9998;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      }

      #consoleToggle:hover {
        background: #2ea043;
      }

      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 24px;
        border-bottom: 1px solid #334155;
        position: sticky;
        top: 0;
        background: #1e293b;
        z-index: 10;
      }

      .modal-header h2 {
        font-size: 20px;
        color: #f1f5f9;
        margin: 0;
      }

      .modal-close {
        background: rgba(239, 68, 68, 0.2);
        border: 1px solid rgba(239, 68, 68, 0.3);
        color: #f87171;
        width: 36px;
        height: 36px;
        border-radius: 10px;
        font-size: 20px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .modal-close:hover {
        background: rgba(239, 68, 68, 0.4);
      }

      .modal-footer {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
        padding: 16px 24px;
        border-top: 1px solid #334155;
        background: #1e293b;
        border-radius: 0 0 20px 20px;
      }

      /* Test Summary */
      .test-summary {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 12px;
        padding: 20px 24px;
        background: rgba(15, 23, 42, 0.5);
      }

      .summary-card {
        background: rgba(30, 41, 59, 0.8);
        border-radius: 12px;
        padding: 16px;
        text-align: center;
      }

      .summary-card .value {
        font-size: 28px;
        font-weight: bold;
        margin-bottom: 4px;
      }

      .summary-card .label {
        font-size: 11px;
        color: #94a3b8;
      }

      .summary-card.success .value {
        color: #4ade80;
      }
      .summary-card.error .value {
        color: #f87171;
      }
      .summary-card.speed .value {
        color: #60a5fa;
      }

      /* Provider Section */
      .provider-section {
        padding: 16px 24px;
        border-bottom: 1px solid #1e293b;
      }

      .provider-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
        cursor: pointer;
      }

      .provider-header h3 {
        font-size: 16px;
        color: #e2e8f0;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .provider-stats {
        font-size: 12px;
        color: #94a3b8;
      }

      /* Model Result */
      .model-result {
        background: rgba(15, 23, 42, 0.6);
        border-radius: 10px;
        padding: 12px 16px;
        margin-bottom: 8px;
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 12px;
        align-items: center;
      }

      .model-result.success {
        border-left: 3px solid #22c55e;
      }

      .model-result.error {
        border-left: 3px solid #ef4444;
      }

      .model-result .model-name {
        font-weight: 500;
        color: #f1f5f9;
        margin-bottom: 2px;
      }

      .model-result .model-id {
        font-size: 11px;
        color: #64748b;
        font-family: monospace;
      }

      .model-result .result-info {
        text-align: right;
      }

      .model-result .result-status {
        font-size: 12px;
        margin-bottom: 4px;
      }

      .model-result .result-status.success {
        color: #4ade80;
      }
      .model-result .result-status.error {
        color: #f87171;
      }

      .model-result .result-details {
        font-size: 11px;
        color: #94a3b8;
      }

      .model-result .error-msg {
        font-size: 11px;
        color: #fbbf24;
        margin-top: 4px;
        grid-column: 1 / -1;
      }

      /* Testing animation */
      .testing-indicator {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        color: #60a5fa;
        font-size: 13px;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .spinner {
        width: 16px;
        height: 16px;
        border: 2px solid #334155;
        border-top-color: #60a5fa;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ü§ñ AI Modul - Testov√°n√≠</h1>

      <!-- Nastaven√≠ (collapsible) - Provider + Model + API Keys -->
      <div class="card">
        <div
          class="collapsible-header"
          onclick="toggleSection('settingsSection')"
        >
          <div class="card-title" class="no-margin">
            <span class="icon">‚öôÔ∏è</span> Nastaven√≠
            <span class="inl-5fd938" id="currentSettingsInfo">
              (gemini / gemini-2.5-flash-lite)
            </span>
          </div>
          <span class="arrow" id="settingsSectionArrow">‚ñ∂</span>
        </div>
        <div class="collapsible-content" id="settingsSection">
          <div class="padding-top-16">
            <!-- Provider tabs -->
            <div class="inl-d32779">
              <label class="inl-ae273d">Poskytovatel:</label>
              <div class="provider-tabs" id="providerTabs">
                <div class="provider-tab active" data-provider="gemini">
                  <span class="emoji">ü§ñ</span> Gemini
                </div>
                <div class="provider-tab" data-provider="groq">
                  <span class="emoji">‚ö°</span> Groq
                </div>
                <div class="provider-tab" data-provider="openrouter">
                  <span class="emoji">üåê</span> OpenRouter
                </div>
                <div class="provider-tab" data-provider="mistral">
                  <span class="emoji">üî•</span> Mistral
                </div>
                <div class="provider-tab" data-provider="cohere">
                  <span class="emoji">üß†</span> Cohere
                </div>
                <div
                  class="provider-tab"
                  data-provider="huggingface"
                  title="‚ö†Ô∏è Z file:// nefunguje - pot≈ôeba HTTP server"
                >
                  <span class="emoji">ü§ó</span> HuggingFace
                </div>
              </div>
            </div>

            <!-- Model selection -->
            <div class="model-section">
              <div>
                <label>Model:</label>
                <select id="modelSelect"></select>
              </div>
              <div class="model-info">
                <div>Limit:</div>
                <div><span class="rpm" id="modelRpm">15</span> req/min</div>
              </div>
            </div>

            <!-- API Keys -->
            <div class="inl-96eb4e">
              <label class="inl-ae273d">API Kl√≠ƒçe:</label>
              <div class="keys-grid">
                <div class="key-input-group">
                  <label>ü§ñ Gemini</label>
                  <input
                    type="password"
                    id="keyGemini"
                    placeholder="AIza..."
                    aria-label="Kl√≠ƒç Google Gemini"
                  />
                  <span class="key-status" id="statusGemini">‚óè</span>
                </div>
                <div class="key-input-group">
                  <label>‚ö° Groq</label>
                  <input
                    type="password"
                    id="keyGroq"
                    placeholder="gsk_..."
                    aria-label="Kl√≠ƒç Groq"
                  />
                  <span class="key-status" id="statusGroq">‚óè</span>
                </div>
                <div class="key-input-group">
                  <label>üåê OpenRouter</label>
                  <input
                    type="password"
                    id="keyOpenrouter"
                    placeholder="sk-or-..."
                   aria-label="sk-or-..." />
                  <span class="key-status" id="statusOpenrouter">‚óè</span>
                </div>
                <div class="key-input-group">
                  <label>üî• Mistral</label>
                  <input
                    type="password"
                    id="keyMistral"
                    placeholder="..."
                    aria-label="Kl√≠ƒç Mistral"
                  />
                  <span class="key-status" id="statusMistral">‚óè</span>
                </div>
                <div class="key-input-group">
                  <label>üß† Cohere</label>
                  <input
                    type="password"
                    id="keyCohere"
                    placeholder="..."
                    aria-label="Kl√≠ƒç Cohere"
                  />
                  <span class="key-status" id="statusCohere">‚óè</span>
                </div>
                <div class="key-input-group">
                  <label>ü§ó HuggingFace</label>
                  <input
                    type="password"
                    id="keyHuggingface"
                    placeholder="hf_..."
                   aria-label="hf_..." />
                  <span class="key-status" id="statusHuggingface">‚óè</span>
                </div>
              </div>
              <div class="btn-row" class="margin-top-12">
                <button class="btn-success" onclick="saveKeys()">
                  üíæ Ulo≈æit
                </button>
                <button class="btn-secondary" onclick="exportSettings()">
                  üì• Export
                </button>
                <button class="btn-secondary" onclick="importSettings()">
                  üì§ Import
                </button>
                <button class="btn-danger" onclick="clearKeys()">
                  üóëÔ∏è Smazat
                </button>
              </div>
              <div class="inl-67e582">
                ‚úÖ = vlastn√≠ kl√≠ƒç | ‚ö†Ô∏è = demo kl√≠ƒç | ‚óã = ≈æ√°dn√Ω kl√≠ƒç
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Chat - dotaz i odpovƒõƒè spolu -->
      <div class="card">
        <div class="card-title"><span class="icon">üí¨</span> Chat</div>

        <div class="chat-container">
          <!-- System prompt - rozbalovac√≠ -->
          <div class="collapsible-section">
            <div
              class="collapsible-header-mini"
              onclick="toggleSection('systemSection')"
            >
              <span>‚öôÔ∏è System prompt (voliteln√Ω)</span>
              <span class="arrow" id="systemSectionArrow">‚ñ∂</span>
            </div>
            <div class="collapsible-content-mini" id="systemSection">
              <textarea
                id="systemPrompt"
                placeholder="Nap≈ô: Jsi pomocn√Ω asistent pro CNC programov√°n√≠..."
              ></textarea>
            </div>
          </div>

          <div class="prompt-area">
            <label>üí¨ Chat:</label>

            <!-- Chat kontejner -->
            <div class="chat-container" id="chatContainer">
              <div class="chat-empty" id="chatEmpty">Zaƒçni konverzaci...</div>
            </div>

            <!-- N√°hled souboru/obr√°zku -->
            <div class="file-preview-bar d-none" id="filePreviewBar">
              <div class="file-preview-item">
                <img id="previewThumb" src="" alt="N√°hled" class="d-none" />
                <span class="file-icon" id="fileIcon">üìÑ</span>
                <span class="file-name" id="fileName"></span>
                <button class="remove-file-btn" onclick="removeFile()">
                  √ó
                </button>
              </div>
            </div>

            <!-- Status bar -->
            <div class="status-bar">
              <div>
                <span id="currentProvider">gemini</span> /
                <span id="currentModel">-</span>
              </div>
              <div class="status-badge ready" id="statusBadge">‚óè P≈ôipraven</div>
            </div>

            <!-- Input area -->
            <div class="chat-input-area">
              <input
                type="file"
                id="fileInput"
                accept="image/*,.pdf,.txt,.md,.json,.csv"
                onchange="handleFileSelect(event)"
                class="d-none"
               aria-label="fileInput" />
              <button
                class="btn-upload"
                onclick="document.getElementById('fileInput').click()"
                title="Nahr√°t soubor nebo obr√°zek"
              >
                üìé
              </button>
              <textarea
                id="userPrompt"
                placeholder="Napi≈° zpr√°vu..."
                oninput="updateTokenCount()"
              ></textarea>
              <button class="btn-primary" id="btnSend" onclick="sendRequest()">
                üì§
              </button>
            </div>
            <div class="token-counter">
              <span id="tokenCount">~0 token≈Ø</span>
              <span class="token-cost" id="tokenCost"></span>
            </div>
          </div>

          <!-- Skryt√° sekce pro kompatibilitu -->
          <div class="image-upload-section d-none" id="imageUploadSection">
            <label>üëÅÔ∏è Obr√°zek pro Vision model:</label>
            <div
              class="image-upload-area"
              id="imageUploadArea"
              onclick="document.getElementById('imageInput').click()"
            >
              <input
                type="file"
                id="imageInput"
                accept="image/*"
                onchange="handleImageUpload(event)"
                class="d-none"
               aria-label="imageInput" />
              <div class="upload-placeholder" id="uploadPlaceholder">
                <span class="upload-icon">üì∑</span>
                <span>Klikni nebo p≈ôet√°hni obr√°zek</span>
              </div>
              <div class="image-preview d-none" id="imagePreview">
                <img id="previewImg" src="" alt="Preview" />
                <button class="remove-image" onclick="removeImage(event)">
                  √ó
                </button>
              </div>
            </div>
            <div class="image-info" id="imageInfo"></div>
          </div>

          <!-- Dal≈°√≠ akce -->
          <div class="btn-row">
            <button class="btn-secondary" onclick="sendStream()">
              üì° Stream
            </button>
            <button class="btn-secondary" onclick="clearChat()">
              üßπ Vyƒçistit chat
            </button>
            <button
              class="btn-secondary"
              onclick="copyResponse()"
              title="Kop√≠rovat posledn√≠ odpovƒõƒè"
            >
              üìã Kop√≠rovat
            </button>
          </div>

          <!-- Pokroƒçil√© akce - rozbalovac√≠ -->
          <div class="collapsible-section">
            <div
              class="collapsible-header-mini"
              onclick="toggleSection('advancedSection')"
            >
              <span>üîß Pokroƒçil√© akce</span>
              <span class="arrow" id="advancedSectionArrow">‚ñ∂</span>
            </div>
            <div class="collapsible-content-mini" id="advancedSection">
              <div class="btn-row">
                <button class="btn-secondary" onclick="testFallback()">
                  üéØ Fallback test
                </button>
                <button class="btn-secondary" onclick="testAllModels()">
                  üß™ Test v≈°ech model≈Ø
                </button>
                <button class="btn-secondary" onclick="fetchAvailableModels()">
                  üîç Zjistit dostupn√© modely
                </button>
                <button class="btn-secondary" onclick="retryLastRequest()">
                  üîÑ Retry
                </button>
                <button class="btn-secondary" onclick="compareModels()">
                  ‚öñÔ∏è Porovnat
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Historie chatu -->
      <div class="card">
        <div class="collapsible-header" onclick="toggleHistory()">
          <div class="card-title" class="no-margin">
            <span class="icon">üìú</span> Historie chatu
          </div>
          <span class="arrow" id="historyArrow">‚ñº</span>
        </div>
        <div class="collapsible-content" id="historyContent">
          <div id="chatHistory" class="chat-history">
            <div class="history-empty">Zat√≠m ≈æ√°dn√° historie...</div>
          </div>
          <div class="btn-row inl-5c7efb">
            <button class="btn-danger" onclick="clearHistory()">
              üóëÔ∏è Smazat historii
            </button>
            <button class="btn-secondary" onclick="exportHistory()">
              üì• Export
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Test Results Modal -->
    <div id="testModal" class="modal d-none">
      <div class="modal-content">
        <div class="modal-header">
          <h2>üß™ V√Ωsledky testov√°n√≠ AI model≈Ø</h2>
          <button class="modal-close" onclick="closeTestModal()">√ó</button>
        </div>
        <div id="testSummary" class="test-summary"></div>
        <div id="testResults"></div>
        <div class="modal-footer">
          <button class="btn-secondary" onclick="copyTestReport()">
            üìã Zkop√≠rovat Report
          </button>
          <button class="btn-primary" onclick="closeTestModal()">Zav≈ô√≠t</button>
        </div>
      </div>
    </div>

    <!-- Available Models Modal -->
    <div id="modelsModal" class="modal d-none">
      <div class="modal-content modal-wide">
        <div class="modal-header">
          <h2>üîç Dostupn√© AI modely</h2>
          <button class="modal-close" onclick="closeModelsModal()">√ó</button>
        </div>
        <div id="modelsSummary" class="test-summary"></div>
        <div id="modelsResults" class="models-results"></div>
        <div class="modal-footer">
          <button class="btn-secondary" onclick="updateLocalModels()">
            üîÑ Aktualizovat lok√°ln√≠ seznam
          </button>
          <button class="btn-secondary" onclick="copyModelsReport()">
            üìã Zkop√≠rovat
          </button>
          <button class="btn-primary" onclick="closeModelsModal()">
            Zav≈ô√≠t
          </button>
        </div>
      </div>
    </div>

    <!-- Compare Models Modal -->
    <div id="compareModal" class="modal d-none">
      <div class="modal-content modal-wide">
        <div class="modal-header">
          <h2>‚öñÔ∏è Porovn√°n√≠ model≈Ø</h2>
          <button class="modal-close" onclick="closeCompareModal()">√ó</button>
        </div>
        <div id="compareSummary" class="test-summary"></div>
        <div id="compareResults" class="compare-results"></div>
        <div class="modal-footer">
          <button class="btn-secondary" onclick="copyCompareReport()">
            üìã Zkop√≠rovat report
          </button>
          <button class="btn-primary" onclick="closeCompareModal()">
            Zav≈ô√≠t
          </button>
        </div>
      </div>
    </div>

    <!-- Hidden import input -->
    <input
      type="file"
      id="importInput"
      accept=".json"
      class="d-none"
      onchange="handleImport(event)"
     aria-label="importInput" />

    <!-- Mini Console -->
    <div id="miniConsole" class="d-none">
      <div class="console-header">
        <span>üñ•Ô∏è Konzole</span>
        <div>
          <button onclick="clearConsole()" class="inl-230c61">üóëÔ∏è</button>
          <button onclick="toggleConsole()" class="inl-230c61">‚úï</button>
        </div>
      </div>
      <div id="consoleOutput"></div>
    </div>

    <button
      id="consoleToggle"
      onclick="toggleConsole()"
      title="Zobrazit konzoli"
    >
      üñ•Ô∏è
    </button>

    <!-- AI Module v2.0 -->
    <script>
      /**
       * AI Module v3.0
       * ===============
       * Univerz√°ln√≠ modul pro pr√°ci s AI API (Gemini, Groq, OpenRouter, Mistral, Cohere, HuggingFace)
       *
       * ‚ö†Ô∏è D≈ÆLE≈ΩIT√â PRO AI ASISTENTY (Claude, ChatGPT, apod.):
       * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       * Tento modul se pou≈æ√≠v√° ve V√çCE HTML souborech a projektech souƒçasnƒõ!
       * Jak√°koliv √∫prava tohoto souboru m≈Ø≈æe POKAZIT funkƒçnost ostatn√≠ch str√°nek.
       *
       * P≈ôed √∫pravou:
       * 1. Zeptej se u≈æivatele, zda chce upravit TENTO sd√≠len√Ω modul, nebo vytvo≈ôit kopii
       * 2. Upozorni, ≈æe zmƒõna ovlivn√≠ V≈†ECHNY str√°nky, kter√© tento modul pou≈æ√≠vaj√≠
       * 3. P≈ôi p≈ôid√°v√°n√≠ funkc√≠ zachovej zpƒõtnou kompatibilitu
       * 4. NEMƒö≈á existuj√≠c√≠ API/n√°zvy funkc√≠ - mohlo by to rozb√≠t z√°visl√Ω k√≥d
       * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       *
       * NOV√â ve v3.0:
       * - Event syst√©m - AI.on('request:complete', callback)
       * - Workflow/Pipeline - ≈ôetƒõzen√≠ krok≈Ø
       * - Scheduler - pl√°novan√© √∫lohy
       * - Intent Detection - rozpozn√°n√≠ z√°mƒõru
       * - Smart Ask - auto-retry, load balancing
       * - Parallel - paraleln√≠ zpracov√°n√≠
       * - askJSON - validace a auto-fix JSON
       * - Conversation summarize - sumarizace historie
       *
       * Pou≈æit√≠: Naƒçti soubor p≈ôes <scr‚Äãipt src="ai-module.js"></scr‚Äãipt>
       *
       * P≈ô√≠klady:
       *   const response = await AI.ask("Ahoj, jak se m√°≈°?");
       *   const response = await AI.ask("Ahoj", { provider: 'groq' });
       *   AI.on('request:complete', (data) => console.log('Hotovo:', data));
       *   const result = await AI.workflow.create('test').step('s1', {system:'...'}).run('text');
       *   AI.scheduler.add('job', 'every 5m', async () => { ... });
       *   const intent = await AI.detectIntent("P≈ôelo≈æ to do angliƒçtiny");
       *   const result = await AI.smartAsk("Dotaz", { balanceLoad: true });
       *   const results = await AI.parallel(["Dotaz 1", "Dotaz 2"]);
       *   const data = await AI.askJSON("Extrahuj data", { schema: {...} });
       *
       * Podporovan√≠ provide≈ôi:
       * - gemini (Google) - https://aistudio.google.com/app/apikey
       * - groq - https://console.groq.com/keys
       * - openrouter - https://openrouter.ai/keys
       * - mistral - https://console.mistral.ai/api-keys/
       * - cohere - https://dashboard.cohere.com/api-keys
       * - huggingface - https://huggingface.co/settings/tokens
       *
       * Dostupn√© eventy:
       * - init, request:start, request:complete, request:error
       * - workflow:start, workflow:step:start, workflow:step:complete, workflow:complete
       * - scheduler:start, scheduler:run, scheduler:complete, scheduler:error
       * - intent:detected, conversation:summarized
       * - smartAsk:attempt, smartAsk:success, smartAsk:error
       * - parallel:start, parallel:task:start, parallel:task:complete
       *
       * @author Claude AI
       * @version 3.0
       * @license MIT
       */

      const AI = {
        // ============== DEMO KL√çƒåE (rozdƒõlen√© pro GitHub) ==============
        DEMO_KEYS: {
          gemini: "AIzaSyCXuMvhO_senLS" + "oA_idEuBk_EwnMmIPIhg",
          groq: "gsk_0uZbn9KqiBa3Zsl11ACX" + "WGdyb3FYZddvc6oPIn9HTvJpGgoBbYrJ",
          openrouter:
            "sk-or-v1-bff66ee4a0845f88" +
            "428b75d91a35aea63e355a52dc31e6427fcc1f9536c2a8a3",
          mistral: "Tvwm0qcQk71vsUDw" + "VfAAAY5GPKdbvlHj",
          cohere: "PeJo8cQwftoZI1Dob0qK" + "1lN445FlOjrfFA3piEuh",
          huggingface: "hf_UhezIpnumnYWSacKLtja" + "VPfXMxbFemUyMv",
        },

        // ============== KONFIGURACE ==============
        config: {
          keys: {
            gemini: "",
            groq: "",
            openrouter: "",
            mistral: "",
            cohere: "",
            huggingface: "",
          },

          // V√Ωchoz√≠ modely - nejlep≈°√≠ z ka≈æd√©ho providera
          models: {
            gemini: "gemini-2.5-flash", // Nejchyt≈ôej≈°√≠ Gemini
            groq: "llama-3.3-70b-versatile", // Nejchyt≈ôej≈°√≠ Groq
            openrouter: "mistralai/mistral-small-3.1-24b-instruct:free",
            mistral: "mistral-small-latest",
            cohere: "command-a-03-2025",
            huggingface: "mistralai/Mistral-7B-Instruct-v0.3",
          },

          defaultProvider: "groq", // Groq m√° nejlep≈°√≠ free limity (30 RPM)
          timeout: 90000,
          maxRetries: 3,
        },

        // ============== AKTIVN√ç PO≈ΩADAVEK (pro cancel) ==============
        _activeController: null,
        _debug: false,
        _requestQueue: [],
        _processing: false,

        // ============== DEBUG MODE ==============
        debug(enabled = true) {
          this._debug = enabled;
          console.log(enabled ? "üêõ Debug mode ON" : "üêõ Debug mode OFF");
        },

        _log(...args) {
          if (this._debug) {
            console.log("ü§ñ [AI]", ...args);
          }
        },

        // ============== REQUEST QUEUE ==============
        queue: {
          _items: [],
          _processing: false,
          _delay: 1000, // ms mezi po≈æadavky

          // P≈ôidej do fronty
          add(prompt, options = {}) {
            return new Promise((resolve, reject) => {
              AI.queue._items.push({ prompt, options, resolve, reject });
              AI.queue._process();
            });
          },

          // Zpracuj frontu
          async _process() {
            if (this._processing || this._items.length === 0) return;

            this._processing = true;

            while (this._items.length > 0) {
              const { prompt, options, resolve, reject } = this._items.shift();

              try {
                const response = await AI.ask(prompt, options);
                resolve(response);
              } catch (e) {
                reject(e);
              }

              // ƒåekej mezi po≈æadavky
              if (this._items.length > 0) {
                await new Promise((r) => setTimeout(r, this._delay));
              }
            }

            this._processing = false;
          },

          // Poƒçet polo≈æek ve frontƒõ
          size() {
            return this._items.length;
          },

          // Vyƒçisti frontu
          clear() {
            this._items.forEach((item) =>
              item.reject(new Error("Queue cleared"))
            );
            this._items = [];
          },
        },

        // ============== STATISTIKY POU≈ΩIT√ç ==============
        stats: {
          _data: {
            totalCalls: 0,
            totalTokensIn: 0,
            totalTokensOut: 0,
            dailyCalls: 0,
            lastReset: new Date().toISOString(),
            byProvider: {},
          },

          // Naƒçti statistiky z localStorage
          load() {
            try {
              const stored = localStorage.getItem("ai_module_stats");
              if (stored) {
                this._data = JSON.parse(stored);
                this._checkDailyReset();
              }
            } catch (e) {}
            return this._data;
          },

          // Ulo≈æ statistiky
          save() {
            try {
              localStorage.setItem(
                "ai_module_stats",
                JSON.stringify(this._data)
              );
            } catch (e) {}
          },

          // Zaznamenej vol√°n√≠
          record(provider, tokensIn = 0, tokensOut = 0) {
            this._data.totalCalls++;
            this._data.dailyCalls++;
            this._data.totalTokensIn += tokensIn;
            this._data.totalTokensOut += tokensOut;

            if (!this._data.byProvider[provider]) {
              this._data.byProvider[provider] = {
                calls: 0,
                tokensIn: 0,
                tokensOut: 0,
              };
            }
            this._data.byProvider[provider].calls++;
            this._data.byProvider[provider].tokensIn += tokensIn;
            this._data.byProvider[provider].tokensOut += tokensOut;

            this.save();
          },

          // Z√≠skej statistiky
          get() {
            return { ...this._data };
          },

          // Reset statistik
          reset() {
            this._data = {
              totalCalls: 0,
              totalTokensIn: 0,
              totalTokensOut: 0,
              dailyCalls: 0,
              lastReset: new Date().toISOString(),
              byProvider: {},
            };
            this.save();
          },

          // Kontrola denn√≠ho resetu
          _checkDailyReset() {
            const lastReset = new Date(this._data.lastReset);
            const today = new Date();
            if (lastReset.toDateString() !== today.toDateString()) {
              this._data.dailyCalls = 0;
              this._data.lastReset = today.toISOString();
              this.save();
            }
          },
        },

        // ============== RATE LIMITING ==============
        rateLimit: {
          _timestamps: {},
          _windowMs: 60000, // 1 minuta

          // Zaznamenej po≈æadavek
          record(provider) {
            if (!this._timestamps[provider]) {
              this._timestamps[provider] = [];
            }
            this._timestamps[provider].push(Date.now());
            this._cleanup(provider);
            this._save();
          },

          // Vyƒçisti star√© z√°znamy
          _cleanup(provider) {
            if (!this._timestamps[provider]) {
              this._timestamps[provider] = [];
              return;
            }
            const now = Date.now();
            this._timestamps[provider] = this._timestamps[provider].filter(
              (ts) => now - ts < this._windowMs
            );
          },

          // M≈Ø≈æe udƒõlat po≈æadavek?
          canMakeRequest(provider, model = null) {
            this._cleanup(provider);
            const current = this._timestamps[provider]?.length || 0;
            const limit = this._getLimit(provider, model);
            return current < limit;
          },

          // Kolik po≈æadavk≈Ø zb√Ωv√°
          remaining(provider, model = null) {
            this._cleanup(provider);
            const current = this._timestamps[provider]?.length || 0;
            const limit = this._getLimit(provider, model);
            return Math.max(0, limit - current);
          },

          // Z√≠skej limit pro providera/model
          _getLimit(provider, model) {
            // Specifick√© limity pro modely
            const modelLimits = {
              "gemini-2.5-flash-lite": 15,
              "gemini-2.5-flash": 10,
              "gemini-3-pro-preview": 2,
            };
            if (model && modelLimits[model]) {
              return modelLimits[model];
            }
            // Obecn√© limity podle providera
            const providerLimits = {
              gemini: 15,
              groq: 30,
              openrouter: 20,
              mistral: 30,
              cohere: 20,
              huggingface: 10,
            };
            return providerLimits[provider] || 15;
          },

          // Ulo≈æ do localStorage
          _save() {
            try {
              localStorage.setItem(
                "ai_module_ratelimit",
                JSON.stringify(this._timestamps)
              );
            } catch (e) {}
          },

          // Naƒçti z localStorage
          load() {
            try {
              const stored = localStorage.getItem("ai_module_ratelimit");
              if (stored) {
                this._timestamps = JSON.parse(stored);
                // Vyƒçisti star√© z√°znamy
                Object.keys(this._timestamps).forEach((p) => this._cleanup(p));
              }
            } catch (e) {}
          },
        },

        // ============== HISTORIE KONVERZACE ==============
        conversation: {
          _history: [],
          _maxLength: 20, // Max poƒçet zpr√°v v historii

          // P≈ôidej zpr√°vu
          add(role, content) {
            this._history.push({ role, content, timestamp: Date.now() });
            // O≈ô√≠zni pokud je moc dlouh√°
            if (this._history.length > this._maxLength) {
              this._history = this._history.slice(-this._maxLength);
            }
            this._save();
          },

          // Z√≠skej historii
          get() {
            return [...this._history];
          },

          // Vyƒçisti historii
          clear() {
            this._history = [];
            this._save();
          },

          // Z√≠skej jako messages pro API
          getMessages(systemPrompt = null) {
            const messages = [];
            if (systemPrompt) {
              messages.push({ role: "system", content: systemPrompt });
            }
            this._history.forEach((h) => {
              messages.push({ role: h.role, content: h.content });
            });
            return messages;
          },

          // Shr≈à konverzaci pro √∫sporu token≈Ø
          async summarize(options = {}) {
            if (this._history.length < 4) {
              return {
                summarized: false,
                reason: "Konverzace je p≈ô√≠li≈° kr√°tk√°",
              };
            }

            const keepLast = options.keepLast || 2;
            const toSummarize = this._history.slice(0, -keepLast);
            const toKeep = this._history.slice(-keepLast);

            // Sestav text pro sumarizaci
            const conversationText = toSummarize
              .map((h) => `${h.role}: ${h.content}`)
              .join("\n");

            try {
              const summary = await AI.ask(
                `Shr≈à tuto konverzaci do 2-3 vƒõt, zachovej kl√≠ƒçov√© informace:\n\n${conversationText}`,
                {
                  system:
                    "Vytv√°≈ô√≠≈° struƒçn√° shrnut√≠ konverzac√≠. Zachovej d≈Øle≈æit√© fakty a kontext.",
                  provider: options.provider || "groq",
                  temperature: 0.3,
                }
              );

              // Nahraƒè historii
              this._history = [
                {
                  role: "system",
                  content: `[Shrnut√≠ p≈ôedchoz√≠ konverzace: ${summary}]`,
                  timestamp: Date.now(),
                },
                ...toKeep,
              ];

              this._save();

              AI.emit("conversation:summarized", {
                originalLength: toSummarize.length + toKeep.length,
                newLength: this._history.length,
                summary,
              });

              return {
                summarized: true,
                summary,
                removedMessages: toSummarize.length,
                keptMessages: toKeep.length,
              };
            } catch (error) {
              return { summarized: false, error: error.message };
            }
          },

          // Odhadni tokeny v historii
          estimateTokens() {
            const text = this._history.map((h) => h.content).join(" ");
            return AI.estimateTokens(text);
          },

          // Auto-summarize pokud p≈ôes√°hne limit
          async autoSummarize(maxTokens = 2000, options = {}) {
            const tokens = this.estimateTokens();
            if (tokens > maxTokens) {
              return await this.summarize(options);
            }
            return { summarized: false, reason: "Pod limitem token≈Ø", tokens };
          },

          // Ulo≈æ do localStorage
          _save() {
            try {
              localStorage.setItem(
                "ai_module_conversation",
                JSON.stringify(this._history)
              );
            } catch (e) {}
          },

          // Naƒçti z localStorage
          load() {
            try {
              const stored = localStorage.getItem("ai_module_conversation");
              if (stored) {
                this._history = JSON.parse(stored);
              }
            } catch (e) {}
          },
        },

        // ============== ODHAD TOKEN≈Æ ==============
        estimateTokens(text) {
          if (!text) return 0;
          // P≈ôibli≈æn√Ω odhad: ~4 znaky = 1 token pro angliƒçtinu
          // Pro ƒçe≈°tinu ~3 znaky = 1 token
          return Math.ceil(text.length / 3.5);
        },

        // ============== ZRU≈†EN√ç PO≈ΩADAVKU ==============
        cancel() {
          if (this._activeController) {
            this._activeController.abort();
            this._activeController = null;
            console.log("üõë Po≈æadavek zru≈°en");
            return true;
          }
          return false;
        },

        // ============== V≈†ECHNY MODELY (se≈ôazen√© od nejlep≈°√≠ch) ==============
        ALL_MODELS: {
          gemini: [
            {
              value: "gemini-2.5-flash",
              name: "üß† Gemini 2.5 Flash",
              rpm: 10,
              quality: 95,
            },
            {
              value: "gemini-2.5-flash-lite",
              name: "‚ö° Gemini 2.5 Flash-Lite",
              rpm: 15,
              quality: 85,
            },
          ],
          groq: [
            {
              value: "llama-3.3-70b-versatile",
              name: "üß† Llama 3.3 70B (nejchyt≈ôej≈°√≠)",
              rpm: 30,
              quality: 90,
            },
            {
              value: "openai/gpt-oss-120b",
              name: "üß† GPT OSS 120B",
              rpm: 30,
              quality: 88,
            },
            {
              value: "meta-llama/llama-4-maverick-17b-128e-instruct",
              name: "üëÅÔ∏è Llama 4 Maverick (Vision)",
              rpm: 30,
              quality: 85,
            },
            {
              value: "meta-llama/llama-4-scout-17b-16e-instruct",
              name: "üëÅÔ∏è Llama 4 Scout (Vision)",
              rpm: 30,
              quality: 82,
            },
            {
              value: "openai/gpt-oss-20b",
              name: "‚ö° GPT OSS 20B (rychl√Ω)",
              rpm: 30,
              quality: 75,
            },
            {
              value: "llama-3.1-8b-instant",
              name: "‚ö° Llama 3.1 8B (nejrychlej≈°√≠)",
              rpm: 30,
              quality: 65,
            },
          ],
          mistral: [
            {
              value: "mistral-small-latest",
              name: "üß† Mistral Small",
              rpm: 30,
              quality: 80,
            },
            {
              value: "codestral-latest",
              name: "üíª Codestral (k√≥dov√°n√≠)",
              rpm: 30,
              quality: 78,
            },
          ],
          cohere: [
            {
              value: "command-a-03-2025",
              name: "üß† Command A (nejnovƒõj≈°√≠)",
              rpm: 20,
              quality: 85,
            },
            {
              value: "command-r-plus-08-2024",
              name: "üí¨ Command R+",
              rpm: 20,
              quality: 80,
            },
            {
              value: "command-r-08-2024",
              name: "‚ö° Command R (rychl√Ω)",
              rpm: 20,
              quality: 70,
            },
          ],
          openrouter: [
            {
              value: "mistralai/mistral-small-3.1-24b-instruct:free",
              name: "üî• Mistral Small 3.1 :free",
              rpm: 20,
              quality: 75,
            },
          ],
          huggingface: [
            {
              value: "mistralai/Mistral-7B-Instruct-v0.3",
              name: "üî• Mistral 7B",
              rpm: 10,
              quality: 60,
            },
            {
              value: "microsoft/Phi-3-mini-4k-instruct",
              name: "üî¨ Phi-3 Mini",
              rpm: 10,
              quality: 55,
            },
            {
              value: "HuggingFaceH4/zephyr-7b-beta",
              name: "üí® Zephyr 7B",
              rpm: 10,
              quality: 50,
            },
            {
              value: "google/gemma-2-2b-it",
              name: "ü§ñ Gemma 2 2B",
              rpm: 10,
              quality: 45,
            },
            {
              value: "tiiuae/falcon-7b-instruct",
              name: "ü¶Ö Falcon 7B",
              rpm: 10,
              quality: 40,
            },
          ],
        },

        // Po≈ôad√≠ provider≈Ø od nejlep≈°√≠ho (pro fallback)
        PROVIDER_PRIORITY: [
          "groq",
          "gemini",
          "mistral",
          "cohere",
          "openrouter",
          "huggingface",
        ],

        // Modely s podporou vision (Groq)
        VISION_MODELS: [
          "meta-llama/llama-4-maverick-17b-128e-instruct",
          "meta-llama/llama-4-scout-17b-16e-instruct",
        ],

        // Z√≠skej nejlep≈°√≠ dostupn√Ω model pro providera
        getBestModel(provider) {
          const models = this.ALL_MODELS[provider];
          if (!models || models.length === 0) return null;
          // Modely jsou u≈æ se≈ôazen√© od nejlep≈°√≠ho
          return models[0].value;
        },

        // Z√≠skej v≈°echny modely se≈ôazen√© podle kvality (nap≈ô√≠ƒç providery)
        getAllModelsSorted() {
          const allModels = [];

          for (const [provider, models] of Object.entries(this.ALL_MODELS)) {
            if (!this.getKey(provider)) continue; // P≈ôeskoƒç providery bez kl√≠ƒçe

            for (const model of models) {
              allModels.push({
                provider,
                model: model.value,
                name: model.name,
                quality: model.quality || 50,
                rpm: model.rpm,
              });
            }
          }

          // Se≈ôaƒè podle kvality (sestupnƒõ)
          return allModels.sort((a, b) => b.quality - a.quality);
        },

        // ============== HELPER FUNKCE ==============

        async fetchWithTimeout(url, options, timeoutMs) {
          const timeout = timeoutMs || this.config.timeout || 30000;

          // Vytvo≈ô AbortController pro mo≈ænost zru≈°en√≠
          this._activeController = new AbortController();
          const signal = this._activeController.signal;

          // Timeout promise
          const timeoutId = setTimeout(() => {
            this._activeController?.abort();
          }, timeout);

          try {
            const response = await fetch(url, { ...options, signal });
            clearTimeout(timeoutId);
            this._activeController = null;
            return response;
          } catch (err) {
            clearTimeout(timeoutId);
            this._activeController = null;
            if (err.name === "AbortError") {
              throw new Error("Po≈æadavek byl zru≈°en nebo vypr≈°el timeout");
            }
            throw err;
          }
        },

        // Retry s exponenci√°ln√≠m backoff
        async retryWithBackoff(apiCall, maxRetries = null) {
          const retries = maxRetries || this.config.maxRetries;

          for (let attempt = 0; attempt < retries; attempt++) {
            try {
              return await apiCall();
            } catch (err) {
              const isRateLimit =
                err.message?.includes("429") ||
                err.message?.includes("quota") ||
                err.message?.includes("RESOURCE_EXHAUSTED");

              if (isRateLimit && attempt < retries - 1) {
                const retryMatch = err.message?.match(/retry in ([\d.]+)s/i);
                let delayMs;

                if (retryMatch) {
                  delayMs = Math.ceil(parseFloat(retryMatch[1]) * 1000);
                } else {
                  delayMs = Math.pow(2, attempt + 1) * 1000;
                }

                console.log(`‚è≥ Rate limit, ƒçek√°m ${delayMs / 1000}s...`);
                await new Promise((resolve) => setTimeout(resolve, delayMs));
                continue;
              }

              throw err;
            }
          }
        },

        // Parsov√°n√≠ AI odpovƒõdi (JSON cleaning)
        parseResponse(aiResponseText) {
          try {
            let cleanedJson = aiResponseText
              .replace(/```json\s*/gi, "")
              .replace(/```\s*/g, "");

            const firstBrace = cleanedJson.indexOf("{");
            const lastBrace = cleanedJson.lastIndexOf("}");

            if (
              firstBrace !== -1 &&
              lastBrace !== -1 &&
              lastBrace > firstBrace
            ) {
              cleanedJson = cleanedJson.substring(firstBrace, lastBrace + 1);
            }

            const openBraces = (cleanedJson.match(/\{/g) || []).length;
            const closeBraces = (cleanedJson.match(/\}/g) || []).length;
            const openBrackets = (cleanedJson.match(/\[/g) || []).length;
            const closeBrackets = (cleanedJson.match(/\]/g) || []).length;

            if (openBrackets > closeBrackets) {
              cleanedJson += "]".repeat(openBrackets - closeBrackets);
            }
            if (openBraces > closeBraces) {
              cleanedJson += "}".repeat(openBraces - closeBraces);
            }

            cleanedJson = cleanedJson.replace(/(\d+\.\d{6})\d{4,}/g, "$1");
            cleanedJson = cleanedJson.replace(/,\s*([}\]])/g, "$1");

            return JSON.parse(cleanedJson);
          } catch (e) {
            console.error("‚ùå Parse error:", e.message);
            return null;
          }
        },

        // ============== NASTAVEN√ç ==============

        getKey(provider) {
          // 1. Zkus multi-key syst√©m
          const multiKey = this.keys.getActive(provider);
          if (multiKey && multiKey.length > 10) {
            return multiKey;
          }

          // 2. Zkus config.keys (nastaveno p≈ôes setKey)
          const customKey = this.config.keys[provider];
          if (customKey && customKey.length > 10) {
            return customKey;
          }

          // 3. Fallback na demo kl√≠ƒçe
          const demoKey = this.DEMO_KEYS[provider];
          if (demoKey && demoKey.length > 10) {
            return demoKey;
          }

          return null;
        },

        isUsingDemoKey(provider) {
          const multiKey = this.keys.getActive(provider);
          if (multiKey && multiKey.length > 10) return false;

          const customKey = this.config.keys[provider];
          return !(customKey && customKey.length > 10);
        },

        setKey(provider, key) {
          if (this.config.keys.hasOwnProperty(provider)) {
            this.config.keys[provider] = key;
            return true;
          }
          return false;
        },

        setModel(provider, model) {
          if (this.config.models.hasOwnProperty(provider)) {
            this.config.models[provider] = model;
            return true;
          }
          return false;
        },

        setDefaultProvider(provider) {
          if (this.config.keys.hasOwnProperty(provider)) {
            this.config.defaultProvider = provider;
            return true;
          }
          return false;
        },

        getAvailableProviders() {
          return [
            "gemini",
            "groq",
            "openrouter",
            "mistral",
            "cohere",
            "huggingface",
          ].filter((provider) => this.getKey(provider) !== null);
        },

        // ============== GEMINI ==============

        async askGemini(prompt, options = {}) {
          const key = options.key || this.getKey("gemini");
          if (!key) throw new Error("Gemini API kl√≠ƒç nen√≠ nastaven");

          const model = options.model || this.config.models.gemini;
          const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${key}`;

          const body = {
            contents: [
              {
                parts: [{ text: prompt }],
              },
            ],
            generationConfig: {
              temperature: options.temperature ?? 0.7,
              maxOutputTokens: options.maxTokens ?? 4096,
            },
          };

          if (options.system) {
            body.systemInstruction = {
              parts: [{ text: options.system }],
            };
          }

          const response = await this.retryWithBackoff(async () => {
            const resp = await this.fetchWithTimeout(url, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(body),
            });

            if (!resp.ok) {
              const error = await resp.json().catch(() => ({}));
              throw new Error(error.error?.message || `HTTP ${resp.status}`);
            }

            return resp.json();
          });

          const text =
            response.candidates?.[0]?.content?.parts?.[0]?.text || "";

          if (options.parseJson) {
            return this.parseResponse(text);
          }

          return text;
        },

        // ============== GROQ ==============

        async askGroq(prompt, options = {}) {
          const key = options.key || this.getKey("groq");
          if (!key) throw new Error("Groq API kl√≠ƒç nen√≠ nastaven");

          const model = options.model || this.config.models.groq;
          const url = "https://api.groq.com/openai/v1/chat/completions";

          let messages = [];

          if (options.system) {
            messages.push({ role: "system", content: options.system });
          }

          const isVisionModel = this.VISION_MODELS.includes(model);
          const hasImage = options.imageBase64 && options.imageMimeType;

          if (isVisionModel && hasImage) {
            messages.push({
              role: "user",
              content: [
                { type: "text", text: prompt },
                {
                  type: "image_url",
                  image_url: {
                    url: `data:${options.imageMimeType};base64,${options.imageBase64}`,
                  },
                },
              ],
            });
          } else {
            messages.push({ role: "user", content: prompt });
          }

          const response = await this.fetchWithTimeout(url, {
            method: "POST",
            headers: {
              Authorization: `Bearer ${key}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              model: model,
              messages: messages,
              temperature: options.temperature ?? 0.7,
              max_tokens: options.maxTokens ?? 4096,
            }),
          });

          if (!response.ok) {
            const error = await response.json().catch(() => ({}));
            throw new Error(error.error?.message || `HTTP ${response.status}`);
          }

          const data = await response.json();
          let text = data.choices?.[0]?.message?.content || "";

          if (!text && data.choices?.[0]?.message?.reasoning) {
            text = data.choices[0].message.reasoning;
          }

          if (options.parseJson) {
            return this.parseResponse(text);
          }

          return text;
        },

        // ============== OPENROUTER ==============

        async askOpenRouter(prompt, options = {}) {
          const key = options.key || this.getKey("openrouter");
          if (!key) throw new Error("OpenRouter API kl√≠ƒç nen√≠ nastaven");

          const model = options.model || this.config.models.openrouter;
          const url = "https://openrouter.ai/api/v1/chat/completions";

          console.info("üåê OpenRouter request:", model);

          const messages = [];

          if (options.system) {
            messages.push({ role: "system", content: options.system });
          }
          messages.push({ role: "user", content: prompt });

          const response = await this.fetchWithTimeout(url, {
            method: "POST",
            headers: {
              Authorization: `Bearer ${key}`,
              "Content-Type": "application/json",
              "HTTP-Referer": window.location.href,
              "X-Title": "AI Module Test",
            },
            body: JSON.stringify({
              model: model,
              messages: messages,
              temperature: options.temperature ?? 0.7,
              max_tokens: options.maxTokens ?? 1024,
            }),
          });

          const data = await response.json().catch(() => ({}));

          console.info("üåê OpenRouter response:", response.status, data);

          if (!response.ok) {
            // Detailn√≠ error handling
            const errMsg =
              data.error?.message ||
              data.error?.code ||
              JSON.stringify(data.error) ||
              `HTTP ${response.status}`;
            console.error("üåê OpenRouter error:", errMsg);
            throw new Error(errMsg);
          }

          const text = data.choices?.[0]?.message?.content || "";

          if (options.parseJson) {
            return this.parseResponse(text);
          }

          return text;
        },

        // ============== MISTRAL ==============

        async askMistral(prompt, options = {}) {
          const key = options.key || this.getKey("mistral");
          if (!key) throw new Error("Mistral API kl√≠ƒç nen√≠ nastaven");

          const model = options.model || this.config.models.mistral;
          const url = "https://api.mistral.ai/v1/chat/completions";

          const messages = [];

          if (options.system) {
            messages.push({ role: "system", content: options.system });
          }
          messages.push({ role: "user", content: prompt });

          const response = await this.fetchWithTimeout(url, {
            method: "POST",
            headers: {
              Authorization: `Bearer ${key}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              model: model,
              messages: messages,
              temperature: options.temperature ?? 0.7,
              max_tokens: options.maxTokens ?? 4096,
            }),
          });

          if (!response.ok) {
            const error = await response.json().catch(() => ({}));
            throw new Error(error.error?.message || `HTTP ${response.status}`);
          }

          const data = await response.json();
          const text = data.choices?.[0]?.message?.content || "";

          if (options.parseJson) {
            return this.parseResponse(text);
          }

          return text;
        },

        // ============== COHERE ==============

        async askCohere(prompt, options = {}) {
          const key = options.key || this.getKey("cohere");
          if (!key) throw new Error("Cohere API kl√≠ƒç nen√≠ nastaven");

          const model =
            options.model ||
            this.config.models.cohere ||
            "command-r-plus-08-2024";
          const url = "https://api.cohere.com/v2/chat";

          const messages = [];

          if (options.system) {
            messages.push({ role: "system", content: options.system });
          }
          messages.push({ role: "user", content: prompt });

          const response = await this.fetchWithTimeout(url, {
            method: "POST",
            headers: {
              Authorization: `Bearer ${key}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              model: model,
              messages: messages,
              temperature: options.temperature ?? 0.7,
              max_tokens: options.maxTokens ?? 4096,
            }),
          });

          if (!response.ok) {
            const error = await response.json().catch(() => ({}));
            throw new Error(error.message || `HTTP ${response.status}`);
          }

          const data = await response.json();
          const text = data.message?.content?.[0]?.text || "";

          if (options.parseJson) {
            return this.parseResponse(text);
          }

          return text;
        },

        // ============== HUGGING FACE ==============

        // CORS proxy pro HuggingFace (nutn√© pro file://)
        CORS_PROXIES: [
          "https://corsproxy.io/?url=",
          "https://api.codetabs.com/v1/proxy?quest=",
        ],

        async askHuggingFace(prompt, options = {}) {
          const key = options.key || this.getKey("huggingface");
          if (!key) throw new Error("HuggingFace API kl√≠ƒç nen√≠ nastaven");

          const model =
            options.model ||
            this.config.models.huggingface ||
            "mistralai/Mistral-7B-Instruct-v0.3";
          const originalUrl = `https://api-inference.huggingface.co/models/${model}/v1/chat/completions`;

          const messages = [];

          if (options.system) {
            messages.push({ role: "system", content: options.system });
          }
          messages.push({ role: "user", content: prompt });

          const body = JSON.stringify({
            model: model,
            messages: messages,
            temperature: options.temperature ?? 0.7,
            max_tokens: options.maxTokens ?? 1024,
            stream: false,
          });

          const headers = {
            Authorization: `Bearer ${key}`,
            "Content-Type": "application/json",
          };

          // Detekce jestli jsme na file:// nebo localhost
          const isLocalFile = window.location.protocol === "file:";

          if (!isLocalFile) {
            // P≈ô√≠m√Ω request pokud jsme na HTTP/HTTPS
            return this.doHuggingFaceRequest(
              originalUrl,
              headers,
              body,
              options
            );
          }

          // Pro file:// zkusit CORS proxy
          for (const proxyBase of this.CORS_PROXIES) {
            try {
              const proxyUrl = proxyBase + encodeURIComponent(originalUrl);
              return await this.doHuggingFaceRequest(
                proxyUrl,
                headers,
                body,
                options
              );
            } catch (e) {
              console.warn(`CORS proxy ${proxyBase} selhalo:`, e.message);
              continue;
            }
          }

          // V≈°echny proxy selhaly
          throw new Error(
            "HuggingFace: CORS blokuje p≈ô√≠stup z file://. Spus≈•: python -m http.server"
          );
        },

        async doHuggingFaceRequest(url, headers, body, options) {
          try {
            const response = await this.fetchWithTimeout(url, {
              method: "POST",
              headers: headers,
              body: body,
            });

            if (!response.ok) {
              const error = await response.json().catch(() => ({}));
              if (error.error?.includes("loading")) {
                throw new Error("Model se naƒç√≠t√°, zkus za 30s...");
              }
              throw new Error(error.error || `HTTP ${response.status}`);
            }

            const data = await response.json();
            const text = data.choices?.[0]?.message?.content || "";
            return options.parseJson ? this.parseResponse(text) : text;
          } catch (e) {
            if (e.message === "Failed to fetch") {
              throw new Error(
                "CORS blokuje p≈ô√≠stup. Spus≈•: python -m http.server"
              );
            }
            throw e;
          }
        },

        // ============== UNIVERZ√ÅLN√ç METODY ==============

        async ask(prompt, options = {}) {
          const provider = options.provider || this.config.defaultProvider;
          const model = options.model || this.config.models[provider];
          const startTime = Date.now();
          const maxKeyRotations = options._keyRotations || 0;
          const autoFallback = options.autoFallback !== false; // Default: true

          this._log(
            `Request: ${provider}/${model}`,
            prompt.substring(0, 50) + "..."
          );
          this.emit("request:start", {
            provider,
            model,
            prompt: prompt.substring(0, 100),
          });

          // Rate limiting check s automatickou rotac√≠ kl√≠ƒç≈Ø
          if (
            !options.skipRateLimit &&
            !this.rateLimit.canMakeRequest(provider, model)
          ) {
            // Zkus rotovat kl√≠ƒç
            const keysCount = this.keys.list(provider).length;
            if (keysCount > 1 && maxKeyRotations < keysCount) {
              this._log(
                `Rate limit - rotace kl√≠ƒçe (${
                  maxKeyRotations + 1
                }/${keysCount})`
              );
              this.keys.rotate(provider);
              this.rateLimit._timestamps[provider] = [];
              return this.ask(prompt, {
                ...options,
                _keyRotations: maxKeyRotations + 1,
              });
            }

            // Kl√≠ƒçe vyƒçerp√°ny - zkus dal≈°√≠ model
            if (autoFallback) {
              this._log(
                `V≈°echny kl√≠ƒçe vyƒçerp√°ny pro ${provider}, zkou≈°√≠m dal≈°√≠ model...`
              );
              return this._fallbackToNextModel(
                prompt,
                options,
                provider,
                model
              );
            }

            throw new Error(
              `Rate limit p≈ôekroƒçen pro ${provider}. Zb√Ωv√°: ${this.rateLimit.remaining(
                provider,
                model
              )} po≈æadavk≈Ø/min`
            );
          }

          // Zaznamenej rate limit
          this.rateLimit.record(provider);

          // Odhad vstupn√≠ch token≈Ø
          const tokensIn =
            this.estimateTokens(prompt) +
            this.estimateTokens(options.system || "");

          let response;
          try {
            switch (provider) {
              case "gemini":
                response = await this.askGemini(prompt, options);
                break;
              case "groq":
                response = await this.askGroq(prompt, options);
                break;
              case "openrouter":
                response = await this.askOpenRouter(prompt, options);
                break;
              case "mistral":
                response = await this.askMistral(prompt, options);
                break;
              case "cohere":
                response = await this.askCohere(prompt, options);
                break;
              case "huggingface":
                response = await this.askHuggingFace(prompt, options);
                break;
              default:
                throw new Error(`Nezn√°m√Ω poskytovatel: ${provider}`);
            }
          } catch (error) {
            // P≈ôi rate limit chybƒõ zkus rotovat kl√≠ƒç nebo fallback
            const isRateLimitError =
              error.message.includes("429") ||
              error.message.includes("rate") ||
              error.message.includes("limit") ||
              error.message.includes("quota");

            if (isRateLimitError) {
              const keysCount = this.keys.list(provider).length;
              if (keysCount > 1 && maxKeyRotations < keysCount) {
                this._log(
                  `API rate limit - rotace kl√≠ƒçe (${
                    maxKeyRotations + 1
                  }/${keysCount})`
                );
                this.keys.rotate(provider);
                return this.ask(prompt, {
                  ...options,
                  _keyRotations: maxKeyRotations + 1,
                });
              }

              // V≈°echny kl√≠ƒçe vyƒçerp√°ny - zkus dal≈°√≠ model
              if (autoFallback) {
                this._log(
                  `API rate limit, v≈°echny kl√≠ƒçe vyƒçerp√°ny - zkou≈°√≠m dal≈°√≠ model...`
                );
                return this._fallbackToNextModel(
                  prompt,
                  options,
                  provider,
                  model
                );
              }
            }

            // Jin√° chyba - tak√© zkus fallback
            if (autoFallback && !options._noMoreFallback) {
              this._log(`Chyba ${error.message} - zkou≈°√≠m dal≈°√≠ model...`);
              return this._fallbackToNextModel(
                prompt,
                options,
                provider,
                model
              );
            }

            this._log(`Error: ${error.message}`);
            this.emit("request:error", {
              provider,
              model,
              error: error.message,
              duration: Date.now() - startTime,
            });
            throw error;
          }

          // Zaznamenej statistiky
          const tokensOut = this.estimateTokens(response);
          const elapsed = Date.now() - startTime;
          this.stats.record(provider, tokensIn, tokensOut);

          this._log(`Response: ${elapsed}ms, ~${tokensIn}‚Üí${tokensOut} tokens`);
          this.emit("request:complete", {
            provider,
            model,
            tokensIn,
            tokensOut,
            duration: elapsed,
          });

          // P≈ôidej do konverzace pokud je povoleno
          if (options.useConversation) {
            this.conversation.add("user", prompt);
            this.conversation.add("assistant", response);
          }

          return response;
        },

        // Intern√≠ metoda pro fallback na dal≈°√≠ model
        _fallbackToNextModel(prompt, options, failedProvider, failedModel) {
          const allModels = this.getAllModelsSorted();

          // Najdi index aktu√°ln√≠ho modelu
          const currentIndex = allModels.findIndex(
            (m) => m.provider === failedProvider && m.model === failedModel
          );

          // Zkus dal≈°√≠ modely
          for (let i = currentIndex + 1; i < allModels.length; i++) {
            const { provider, model, name } = allModels[i];

            // P≈ôeskoƒç modely ze stejn√©ho providera pokud nemaj√≠ kl√≠ƒç
            if (!this.getKey(provider)) continue;

            this._log(`Fallback na: ${name}`);

            try {
              return this.ask(prompt, {
                ...options,
                provider,
                model,
                _keyRotations: 0, // Reset rotace pro nov√©ho providera
                autoFallback: true,
              });
            } catch (e) {
              // Pokraƒçuj na dal≈°√≠
              continue;
            }
          }

          throw new Error("V≈°echny modely vyƒçerp√°ny");
        },

        async askWithFallback(prompt, options = {}) {
          const providers =
            options.providers ||
            this.PROVIDER_PRIORITY.filter((p) => this.getKey(p));

          if (providers.length === 0) {
            throw new Error("≈Ω√°dn√Ω dostupn√Ω poskytovatel - nastav API kl√≠ƒçe");
          }

          for (const provider of providers) {
            try {
              this._log(`Fallback: zkou≈°√≠m ${provider}...`);
              return await this.ask(prompt, {
                ...options,
                provider,
                autoFallback: false,
              });
            } catch (error) {
              this._log(`${provider} selhal: ${error.message}`);
              continue;
            }
          }

          throw new Error("V≈°ichni poskytovatel√© selhali");
        },

        // Chytr√Ω dotaz - automaticky proch√°z√≠ modely podle kvality
        async askSmart(prompt, options = {}) {
          const allModels = this.getAllModelsSorted();

          if (allModels.length === 0) {
            throw new Error("≈Ω√°dn√Ω dostupn√Ω model - nastav API kl√≠ƒçe");
          }

          const errors = [];
          const startIndex = options._modelIndex || 0;

          for (let i = startIndex; i < allModels.length; i++) {
            const { provider, model, name, quality } = allModels[i];

            try {
              this._log(
                `Smart [${i + 1}/${
                  allModels.length
                }]: ${name} (quality: ${quality})`
              );

              const response = await this.ask(prompt, {
                ...options,
                provider,
                model,
                autoFallback: false, // Zabra≈à nekoneƒçn√© rekurzi
              });

              return response;
            } catch (error) {
              errors.push({ provider, model, error: error.message });
              this._log(`${name} selhal: ${error.message}`);

              // Pokraƒçuj na dal≈°√≠ model
              continue;
            }
          }

          // V≈°echny modely selhaly
          const errorSummary = errors
            .map((e) => `${e.provider}/${e.model}: ${e.error}`)
            .join("\n");
          throw new Error(`V≈°echny modely selhaly:\n${errorSummary}`);
        },

        // Alias pro askSmart - automatick√Ω fallback p≈ôes v≈°echny modely
        async askAuto(prompt, options = {}) {
          return this.askSmart(prompt, options);
        },

        // ============== STREAMING (Gemini) ==============

        async *streamGemini(prompt, options = {}) {
          const key = options.key || this.getKey("gemini");
          if (!key) throw new Error("Gemini API kl√≠ƒç nen√≠ nastaven");

          const model = options.model || this.config.models.gemini;
          const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:streamGenerateContent?key=${key}&alt=sse`;

          const body = {
            contents: [{ parts: [{ text: prompt }] }],
            generationConfig: {
              temperature: options.temperature ?? 0.7,
              maxOutputTokens: options.maxTokens ?? 4096,
            },
          };

          if (options.system) {
            body.systemInstruction = { parts: [{ text: options.system }] };
          }

          const response = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          });

          if (!response.ok) {
            const error = await response.json().catch(() => ({}));
            throw new Error(error.error?.message || `HTTP ${response.status}`);
          }

          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = "";

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split("\n");
            buffer = lines.pop() || "";

            for (const line of lines) {
              if (line.startsWith("data: ")) {
                try {
                  const data = JSON.parse(line.slice(6));
                  const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
                  if (text) yield text;
                } catch (e) {}
              }
            }
          }
        },

        async *askStream(prompt, options = {}) {
          const provider = options.provider || this.config.defaultProvider;

          if (provider === "gemini") {
            yield* this.streamGemini(prompt, options);
          } else {
            const response = await this.ask(prompt, options);
            yield response;
          }
        },

        // ============== UTILITY ==============

        getModels(provider) {
          return this.ALL_MODELS[provider] || [];
        },

        getAllModels() {
          return this.ALL_MODELS;
        },

        getModelLimit(model) {
          for (const provider of Object.keys(this.ALL_MODELS)) {
            const found = this.ALL_MODELS[provider].find(
              (m) => m.value === model
            );
            if (found) return found.rpm;
          }
          return 15;
        },

        supportsVision(model) {
          return this.VISION_MODELS.includes(model);
        },

        getProviderForModel(model) {
          for (const [provider, models] of Object.entries(this.ALL_MODELS)) {
            if (models.some((m) => m.value === model)) {
              return provider;
            }
          }
          return null;
        },

        getProviderInfo(provider) {
          const info = {
            gemini: {
              name: "Google Gemini",
              endpoint: "generativelanguage.googleapis.com",
              keyUrl: "https://aistudio.google.com/app/apikey",
            },
            groq: {
              name: "Groq",
              endpoint: "api.groq.com",
              keyUrl: "https://console.groq.com/keys",
            },
            openrouter: {
              name: "OpenRouter",
              endpoint: "openrouter.ai",
              keyUrl: "https://openrouter.ai/keys",
            },
            mistral: {
              name: "Mistral AI",
              endpoint: "api.mistral.ai",
              keyUrl: "https://console.mistral.ai/api-keys/",
            },
            cohere: {
              name: "Cohere",
              endpoint: "api.cohere.com",
              keyUrl: "https://dashboard.cohere.com/api-keys",
            },
            huggingface: {
              name: "Hugging Face",
              endpoint: "api-inference.huggingface.co",
              keyUrl: "https://huggingface.co/settings/tokens",
            },
          };

          const providerInfo = info[provider];
          if (!providerInfo) return null;

          providerInfo.models = this.ALL_MODELS[provider] || [];

          return providerInfo;
        },

        // ============== MULTI-KEY MANAGEMENT ==============
        keys: {
          _storage: {},

          // P≈ôidej kl√≠ƒç pro providera
          add(provider, key, name = null) {
            if (!this._storage[provider]) {
              this._storage[provider] = [];
            }
            this._storage[provider].push({
              key,
              name: name || `Kl√≠ƒç ${this._storage[provider].length + 1}`,
              active: this._storage[provider].length === 0,
              addedAt: Date.now(),
            });
            this._save();
          },

          // Odeber kl√≠ƒç
          remove(provider, index) {
            if (this._storage[provider] && this._storage[provider][index]) {
              this._storage[provider].splice(index, 1);
              // Aktivuj prvn√≠ pokud byl odebr√°n aktivn√≠
              if (
                this._storage[provider].length > 0 &&
                !this._storage[provider].find((k) => k.active)
              ) {
                this._storage[provider][0].active = true;
              }
              this._save();
            }
          },

          // P≈ôepni na dal≈°√≠ kl√≠ƒç (rotace)
          rotate(provider) {
            const keys = this._storage[provider];
            if (!keys || keys.length < 2) return false;

            const activeIndex = keys.findIndex((k) => k.active);
            keys[activeIndex].active = false;
            keys[(activeIndex + 1) % keys.length].active = true;
            this._save();
            return true;
          },

          // Z√≠skej aktivn√≠ kl√≠ƒç
          getActive(provider) {
            const keys = this._storage[provider];
            if (!keys || keys.length === 0) return null;
            const active = keys.find((k) => k.active);
            return active ? active.key : keys[0].key;
          },

          // Seznam kl√≠ƒç≈Ø
          list(provider) {
            return (this._storage[provider] || []).map((k, i) => ({
              index: i,
              name: k.name,
              active: k.active,
              preview: k.key.substring(0, 10) + "...",
            }));
          },

          _save() {
            try {
              localStorage.setItem(
                "ai_module_multikeys",
                JSON.stringify(this._storage)
              );
            } catch (e) {}
          },

          load() {
            try {
              const stored = localStorage.getItem("ai_module_multikeys");
              if (stored) this._storage = JSON.parse(stored);
            } catch (e) {}
          },
        },

        // ============== RESPONSE CACHE ==============
        cache: {
          _data: {},
          _maxAge: 3600000, // 1 hodina
          _maxSize: 100,

          // Generuj kl√≠ƒç pro cache
          _makeKey(prompt, options) {
            const provider = options.provider || "default";
            const model = options.model || "default";
            return `${provider}:${model}:${prompt.substring(0, 100)}`;
          },

          // Z√≠skej z cache
          get(prompt, options = {}) {
            const key = this._makeKey(prompt, options);
            const entry = this._data[key];

            if (!entry) return null;
            if (Date.now() - entry.timestamp > this._maxAge) {
              delete this._data[key];
              return null;
            }

            return entry.response;
          },

          // Ulo≈æ do cache
          set(prompt, response, options = {}) {
            const key = this._makeKey(prompt, options);

            // Limit velikosti
            const keys = Object.keys(this._data);
            if (keys.length >= this._maxSize) {
              // Sma≈æ nejstar≈°√≠
              const oldest = keys.reduce((a, b) =>
                this._data[a].timestamp < this._data[b].timestamp ? a : b
              );
              delete this._data[oldest];
            }

            this._data[key] = {
              response,
              timestamp: Date.now(),
            };
          },

          // Vyƒçisti cache
          clear() {
            this._data = {};
          },

          // Statistiky cache
          stats() {
            const keys = Object.keys(this._data);
            return {
              size: keys.length,
              maxSize: this._maxSize,
              maxAge: this._maxAge,
            };
          },
        },

        // ============== PROMPT TEMPLATES ==============
        templates: {
          _templates: {
            translate: {
              name: "P≈ôeklad",
              system:
                "Jsi profesion√°ln√≠ p≈ôekladatel. P≈ôekl√°dej p≈ôesnƒõ a zachov√°vej styl.",
              prompt: "P≈ôelo≈æ do {language}: {text}",
            },
            summarize: {
              name: "Shrnut√≠",
              system: "Vytv√°≈ô√≠≈° struƒçn√° a p≈ôesn√° shrnut√≠.",
              prompt: "Shr≈à n√°sleduj√≠c√≠ text v {length} vƒõt√°ch: {text}",
            },
            code: {
              name: "Programov√°n√≠",
              system: "Jsi expert na programov√°n√≠. Pi≈° ƒçist√Ω, komentovan√Ω k√≥d.",
              prompt: "Napi≈° {language} k√≥d kter√Ω: {task}",
            },
            explain: {
              name: "Vysvƒõtlen√≠",
              system: "Vysvƒõtluje≈° slo≈æit√© koncepty jednodu≈°e a srozumitelnƒõ.",
              prompt: "Vysvƒõtli {topic} jako bych byl {level}",
            },
            email: {
              name: "Email",
              system: "P√≠≈°e≈° profesion√°ln√≠ emaily.",
              prompt: "Napi≈° {tone} email ohlednƒõ: {subject}",
            },
            cnc: {
              name: "CNC/G-k√≥d",
              system: "Jsi expert na CNC programov√°n√≠ a G-k√≥dy pro soustruhy.",
              prompt: "Vytvo≈ô G-k√≥d pro: {operation}",
            },
          },

          // Z√≠skej ≈°ablonu
          get(name) {
            return this._templates[name] || null;
          },

          // Seznam ≈°ablon
          list() {
            return Object.entries(this._templates).map(([key, t]) => ({
              key,
              name: t.name,
            }));
          },

          // Pou≈æij ≈°ablonu
          apply(name, variables = {}) {
            const template = this._templates[name];
            if (!template) return null;

            let prompt = template.prompt;
            let system = template.system;

            // Nahraƒè promƒõnn√©
            Object.entries(variables).forEach(([key, value]) => {
              const regex = new RegExp(`{${key}}`, "g");
              prompt = prompt.replace(regex, value);
              system = system.replace(regex, value);
            });

            return { prompt, system };
          },

          // P≈ôidej vlastn√≠ ≈°ablonu
          add(key, name, system, prompt) {
            this._templates[key] = { name, system, prompt };
            this._save();
          },

          _save() {
            try {
              localStorage.setItem(
                "ai_module_templates",
                JSON.stringify(this._templates)
              );
            } catch (e) {}
          },

          load() {
            try {
              const stored = localStorage.getItem("ai_module_templates");
              if (stored) {
                const custom = JSON.parse(stored);
                this._templates = { ...this._templates, ...custom };
              }
            } catch (e) {}
          },
        },

        // ============== EVENT SYSTEM ==============
        events: {
          _listeners: {},

          // P≈ôidej listener
          on(event, callback) {
            if (!this._listeners[event]) {
              this._listeners[event] = [];
            }
            this._listeners[event].push(callback);
            return () => this.off(event, callback); // Vrac√≠ funkci pro odebr√°n√≠
          },

          // Odeber listener
          off(event, callback) {
            if (!this._listeners[event]) return;
            this._listeners[event] = this._listeners[event].filter(
              (cb) => cb !== callback
            );
          },

          // Jednou
          once(event, callback) {
            const wrapper = (...args) => {
              this.off(event, wrapper);
              callback(...args);
            };
            this.on(event, wrapper);
          },

          // Emituj event
          emit(event, data) {
            if (!this._listeners[event]) return;
            this._listeners[event].forEach((callback) => {
              try {
                callback(data);
              } catch (e) {
                console.error(`Event handler error (${event}):`, e);
              }
            });
          },

          // Seznam event≈Ø
          list() {
            return Object.keys(this._listeners);
          },

          // Vyƒçisti v≈°echny listenery
          clear(event = null) {
            if (event) {
              delete this._listeners[event];
            } else {
              this._listeners = {};
            }
          },
        },

        // Zkratky pro eventy
        on(event, callback) {
          return this.events.on(event, callback);
        },
        off(event, callback) {
          this.events.off(event, callback);
        },
        emit(event, data) {
          this.events.emit(event, data);
        },

        // ============== WORKFLOW / PIPELINE SYSTEM ==============
        workflow: {
          _workflows: {},

          // Vytvo≈ô nov√Ω workflow
          create(name) {
            const workflow = {
              name,
              steps: [],

              // P≈ôidej krok
              step(stepName, options = {}) {
                this.steps.push({
                  name: stepName,
                  system: options.system || null,
                  prompt: options.prompt || null, // Template s {input} a {prevOutput}
                  provider: options.provider || null,
                  model: options.model || null,
                  transform: options.transform || null, // Funkce pro transformaci v√Ωstupu
                  condition: options.condition || null, // Podm√≠nka pro spu≈°tƒõn√≠ kroku
                  temperature: options.temperature,
                  parseJson: options.parseJson || false,
                });
                return this;
              },

              // Spus≈• workflow
              async run(input, options = {}) {
                const results = [];
                let currentInput = input;
                let prevOutput = null;

                AI.emit("workflow:start", { name: this.name, input });

                for (let i = 0; i < this.steps.length; i++) {
                  const step = this.steps[i];

                  // Zkontroluj podm√≠nku
                  if (
                    step.condition &&
                    !step.condition(currentInput, prevOutput, results)
                  ) {
                    AI.emit("workflow:skip", {
                      name: this.name,
                      step: step.name,
                      reason: "condition",
                    });
                    continue;
                  }

                  // Sestav prompt
                  let prompt = step.prompt
                    ? step.prompt
                        .replace("{input}", currentInput)
                        .replace("{prevOutput}", prevOutput || "")
                    : currentInput;

                  try {
                    AI.emit("workflow:step:start", {
                      name: this.name,
                      step: step.name,
                      input: prompt,
                    });

                    const response = await AI.ask(prompt, {
                      system: step.system,
                      provider: step.provider || options.provider,
                      model: step.model,
                      temperature: step.temperature,
                      parseJson: step.parseJson,
                    });

                    // Transformuj v√Ωstup pokud je definov√°na funkce
                    const output = step.transform
                      ? step.transform(response)
                      : response;

                    results.push({
                      step: step.name,
                      input: prompt,
                      output,
                      success: true,
                    });

                    prevOutput = output;
                    currentInput = output;

                    AI.emit("workflow:step:complete", {
                      name: this.name,
                      step: step.name,
                      output,
                    });
                  } catch (error) {
                    results.push({
                      step: step.name,
                      input: prompt,
                      error: error.message,
                      success: false,
                    });

                    AI.emit("workflow:step:error", {
                      name: this.name,
                      step: step.name,
                      error,
                    });

                    if (!options.continueOnError) {
                      AI.emit("workflow:error", {
                        name: this.name,
                        step: step.name,
                        error,
                        results,
                      });
                      throw error;
                    }
                  }
                }

                AI.emit("workflow:complete", {
                  name: this.name,
                  results,
                  finalOutput: prevOutput,
                });

                return {
                  success: results.every((r) => r.success),
                  steps: results,
                  output: prevOutput,
                };
              },
            };

            this._workflows[name] = workflow;
            return workflow;
          },

          // Z√≠skej existuj√≠c√≠ workflow
          get(name) {
            return this._workflows[name] || null;
          },

          // Seznam workflows
          list() {
            return Object.keys(this._workflows);
          },

          // Sma≈æ workflow
          remove(name) {
            delete this._workflows[name];
          },
        },

        // ============== SCHEDULER / CRON SYSTEM ==============
        scheduler: {
          _jobs: {},
          _intervals: {},
          _running: false,

          // Parsuj cron v√Ωraz (zjednodu≈°en√° verze)
          _parseCron(expression) {
            // Podporuje: 'every Xm', 'every Xh', 'every Xs', nebo interval v ms
            if (typeof expression === "number") return expression;

            const match = expression.match(/every\s+(\d+)\s*(s|m|h|d)/i);
            if (match) {
              const value = parseInt(match[1]);
              const unit = match[2].toLowerCase();
              const multipliers = {
                s: 1000,
                m: 60000,
                h: 3600000,
                d: 86400000,
              };
              return value * multipliers[unit];
            }

            // Jednoduch√Ω cron (minuty hodiny * * *)
            const cronMatch = expression.match(/^(\d+|\*)\s+(\d+|\*)\s+/);
            if (cronMatch) {
              // Pro jednoduchost vr√°t√≠me interval 1 hodinu pro cron v√Ωrazy
              console.warn(
                "‚ö†Ô∏è Pln√Ω cron nen√≠ podporov√°n, pou≈æ√≠v√°m interval 1h"
              );
              return 3600000;
            }

            return 60000; // V√Ωchoz√≠ 1 minuta
          },

          // P≈ôidej √∫lohu
          add(name, schedule, task, options = {}) {
            const intervalMs = this._parseCron(schedule);

            this._jobs[name] = {
              name,
              schedule,
              intervalMs,
              task,
              enabled: options.enabled !== false,
              runImmediately: options.runImmediately || false,
              lastRun: null,
              nextRun: Date.now() + (options.runImmediately ? 0 : intervalMs),
              runCount: 0,
              errors: [],
              maxErrors: options.maxErrors || 5,
            };

            if (this._running) {
              this._startJob(name);
            }

            AI.emit("scheduler:add", { name, schedule, intervalMs });
            return this;
          },

          // Spus≈• scheduler
          start() {
            if (this._running) return;
            this._running = true;

            Object.keys(this._jobs).forEach((name) => this._startJob(name));
            AI.emit("scheduler:start", { jobs: Object.keys(this._jobs) });
            console.log("‚è∞ Scheduler spu≈°tƒõn");
          },

          // Zastav scheduler
          stop() {
            this._running = false;
            Object.keys(this._intervals).forEach((name) => {
              clearInterval(this._intervals[name]);
              delete this._intervals[name];
            });
            AI.emit("scheduler:stop", {});
            console.log("‚è∞ Scheduler zastaven");
          },

          // Intern√≠: spus≈• konkr√©tn√≠ job
          _startJob(name) {
            const job = this._jobs[name];
            if (!job || !job.enabled) return;

            // Vyƒçisti existuj√≠c√≠ interval
            if (this._intervals[name]) {
              clearInterval(this._intervals[name]);
            }

            const runTask = async () => {
              if (!job.enabled) return;

              job.lastRun = Date.now();
              job.runCount++;

              AI.emit("scheduler:run", { name, runCount: job.runCount });

              try {
                const result = await job.task();
                AI.emit("scheduler:complete", { name, result });
              } catch (error) {
                job.errors.push({ time: Date.now(), message: error.message });
                AI.emit("scheduler:error", { name, error });

                // Automaticky vypni po p≈ô√≠li≈° mnoha chyb√°ch
                if (job.errors.length >= job.maxErrors) {
                  job.enabled = false;
                  AI.emit("scheduler:disabled", {
                    name,
                    reason: "too many errors",
                  });
                  console.warn(
                    `‚ö†Ô∏è Job '${name}' vypnut po ${job.maxErrors} chyb√°ch`
                  );
                }
              }

              job.nextRun = Date.now() + job.intervalMs;
            };

            // Spus≈• okam≈æitƒõ pokud je nastaveno
            if (job.runImmediately && job.runCount === 0) {
              runTask();
            }

            this._intervals[name] = setInterval(runTask, job.intervalMs);
          },

          // Manu√°ln√≠ spu≈°tƒõn√≠
          async run(name) {
            const job = this._jobs[name];
            if (!job) throw new Error(`Job '${name}' neexistuje`);

            job.lastRun = Date.now();
            job.runCount++;
            return await job.task();
          },

          // Povol/zak√°zat job
          enable(name, enabled = true) {
            if (this._jobs[name]) {
              this._jobs[name].enabled = enabled;
              if (enabled && this._running) {
                this._startJob(name);
              } else if (!enabled && this._intervals[name]) {
                clearInterval(this._intervals[name]);
                delete this._intervals[name];
              }
            }
          },

          // Odeber job
          remove(name) {
            if (this._intervals[name]) {
              clearInterval(this._intervals[name]);
              delete this._intervals[name];
            }
            delete this._jobs[name];
            AI.emit("scheduler:remove", { name });
          },

          // Seznam job≈Ø
          list() {
            return Object.values(this._jobs).map((j) => ({
              name: j.name,
              schedule: j.schedule,
              enabled: j.enabled,
              lastRun: j.lastRun ? new Date(j.lastRun).toLocaleString() : null,
              nextRun: j.nextRun ? new Date(j.nextRun).toLocaleString() : null,
              runCount: j.runCount,
              errorCount: j.errors.length,
            }));
          },

          // Status
          status() {
            return {
              running: this._running,
              jobs: this.list(),
            };
          },
        },

        // ============== INTENT DETECTION ==============
        async detectIntent(text, options = {}) {
          const systemPrompt = options.customIntents
            ? `Rozpoznej z√°mƒõr u≈æivatele. Mo≈æn√© z√°mƒõry: ${options.customIntents.join(
                ", "
              )}.
               Vra≈• JSON: { "intent": "n√°zev_z√°mƒõru", "confidence": 0-1, "params": {} }`
            : `Rozpoznej z√°mƒõr u≈æivatele z textu. Mo≈æn√© z√°mƒõry:
               - translate (p≈ôeklad) - params: { language, text }
               - summarize (shrnut√≠) - params: { length }
               - code (programov√°n√≠) - params: { language, task }
               - explain (vysvƒõtlen√≠) - params: { topic, level }
               - search (vyhled√°v√°n√≠) - params: { query }
               - create (vytvo≈ôen√≠) - params: { type, description }
               - analyze (anal√Ωza) - params: { target }
               - compare (porovn√°n√≠) - params: { items }
               - convert (konverze) - params: { from, to }
               - other (jin√©) - params: { description }

               Vra≈• pouze JSON: { "intent": "n√°zev", "confidence": 0.0-1.0, "params": {}, "originalText": "..." }`;

          try {
            const response = await this.ask(text, {
              system: systemPrompt,
              provider: options.provider || "groq", // Groq je rychl√Ω
              temperature: 0.1, // N√≠zk√° pro konzistentn√≠ v√Ωsledky
              parseJson: true,
            });

            const result =
              typeof response === "string"
                ? this.parseJSON(response)
                : response;

            if (result && result.intent) {
              this.emit("intent:detected", result);
              return result;
            }

            return {
              intent: "unknown",
              confidence: 0,
              params: {},
              originalText: text,
            };
          } catch (error) {
            console.warn("Intent detection failed:", error.message);
            return {
              intent: "error",
              confidence: 0,
              params: {},
              error: error.message,
            };
          }
        },

        // Zpracuj p≈ô√≠kaz podle intentu
        async processIntent(text, options = {}) {
          const intent = await this.detectIntent(text, options);

          if (intent.confidence < (options.minConfidence || 0.5)) {
            return {
              success: false,
              intent,
              message: "N√≠zk√° jistota z√°mƒõru. M≈Ø≈æe≈° up≈ôesnit?",
            };
          }

          // Mapov√°n√≠ intent≈Ø na akce
          const actions = {
            translate: async (params) =>
              this.translate(params.text || text, params.language || "en"),
            summarize: async (params) =>
              this.summarize(params.text || text, params.length || 3),
            code: async (params) =>
              this.generateCode(
                params.task || text,
                params.language || "javascript"
              ),
            explain: async (params) =>
              this.ask(`Vysvƒõtli ${params.topic || text}`, {
                system: `Vysvƒõtluj pro √∫rove≈à: ${params.level || "zaƒç√°teƒçn√≠k"}`,
              }),
            ...options.customActions,
          };

          const action = actions[intent.intent];

          if (action) {
            try {
              const result = await action(intent.params);
              return { success: true, intent, result };
            } catch (error) {
              return { success: false, intent, error: error.message };
            }
          }

          return { success: false, intent, message: "Nezn√°m√Ω z√°mƒõr" };
        },

        // ============== SMART ASK (Auto-retry, Load Balancing) ==============
        async smartAsk(prompt, options = {}) {
          const {
            preferredProviders = this.PROVIDER_PRIORITY,
            maxRetries = 3,
            balanceLoad = true,
            fallbackOnError = true,
            timeout = this.config.timeout,
          } = options;

          // Se≈ôaƒè providery podle dostupnosti
          const providers = preferredProviders.filter((p) => this.getKey(p));

          if (balanceLoad) {
            // Se≈ôaƒè podle zb√Ωvaj√≠c√≠ch po≈æadavk≈Ø
            providers.sort((a, b) => {
              const remainingA = this.rateLimit.remaining(a);
              const remainingB = this.rateLimit.remaining(b);
              return remainingB - remainingA;
            });
          }

          let lastError = null;
          let attempts = [];

          for (const provider of providers) {
            for (let retry = 0; retry < maxRetries; retry++) {
              // Zkontroluj rate limit
              if (!this.rateLimit.canMakeRequest(provider)) {
                this.emit("smartAsk:rateLimit", { provider });
                break; // P≈ôejdi na dal≈°√≠ho providera
              }

              try {
                this.emit("smartAsk:attempt", {
                  provider,
                  retry,
                  prompt: prompt.substring(0, 50),
                });

                const startTime = Date.now();
                const response = await this.ask(prompt, {
                  ...options,
                  provider,
                  timeout,
                });

                const duration = Date.now() - startTime;

                this.emit("smartAsk:success", { provider, retry, duration });

                return {
                  response,
                  provider,
                  attempts: attempts.length + 1,
                  duration,
                };
              } catch (error) {
                lastError = error;
                attempts.push({ provider, retry, error: error.message });

                this.emit("smartAsk:error", {
                  provider,
                  retry,
                  error: error.message,
                });

                // Rate limit - p≈ôejdi na dal≈°√≠ho providera
                if (
                  error.message.includes("429") ||
                  error.message.includes("quota")
                ) {
                  break;
                }

                // Jin√© chyby - zkus znovu s mal√Ωm zpo≈ædƒõn√≠m
                if (retry < maxRetries - 1) {
                  await new Promise((r) => setTimeout(r, 1000 * (retry + 1)));
                }
              }
            }

            if (!fallbackOnError) break;
          }

          this.emit("smartAsk:failed", {
            attempts,
            lastError: lastError?.message,
          });
          throw new Error(
            `V≈°ichni provide≈ôi selhali. Posledn√≠ chyba: ${lastError?.message}`
          );
        },

        // ============== ASK JSON (s validac√≠ a auto-fix) ==============
        async askJSON(prompt, options = {}) {
          const {
            schema = null,
            maxRetries = 3,
            autoFix = true,
            strict = false,
          } = options;

          const schemaHint = schema
            ? `\n\nVra≈• JSON p≈ôesnƒõ v tomto form√°tu: ${JSON.stringify(schema)}`
            : "\n\nVra≈• pouze validn√≠ JSON, ≈æ√°dn√Ω jin√Ω text.";

          let lastResponse = null;
          let lastError = null;

          for (let attempt = 0; attempt < maxRetries; attempt++) {
            try {
              let currentPrompt = prompt + schemaHint;

              // Pokud je to retry a m√°me chybu, p≈ôidej opravu
              if (attempt > 0 && lastError && autoFix) {
                currentPrompt = `${prompt}${schemaHint}\n\nP≈òEDCHOZ√ç POKUS SELHAL. Chyba: ${lastError}\nOprav JSON a vra≈• spr√°vn√Ω form√°t.`;
                if (lastResponse) {
                  currentPrompt += `\n\nP≈ôedchoz√≠ odpovƒõƒè (≈°patn√°): ${lastResponse.substring(
                    0,
                    500
                  )}`;
                }
              }

              const response = await this.ask(currentPrompt, {
                ...options,
                system:
                  (options.system || "") +
                  "\nV≈ædy odpov√≠dej pouze validn√≠m JSON bez markdown blok≈Ø.",
                temperature: options.temperature ?? 0.3, // Ni≈æ≈°√≠ pro konzistenci
              });

              lastResponse = response;

              // Parsuj JSON
              const parsed = this.parseJSON(response);

              if (!parsed) {
                lastError = "Nepoda≈ôilo se parsovat JSON";
                continue;
              }

              // Validuj proti sch√©matu pokud existuje
              if (schema && strict) {
                const validation = this._validateSchema(parsed, schema);
                if (!validation.valid) {
                  lastError = `Schema validace selhala: ${validation.errors.join(
                    ", "
                  )}`;
                  continue;
                }
              }

              this.emit("askJSON:success", { attempt, parsed });
              return parsed;
            } catch (error) {
              lastError = error.message;
              this.emit("askJSON:retry", { attempt, error: error.message });
            }
          }

          this.emit("askJSON:failed", { attempts: maxRetries, lastError });
          throw new Error(
            `Nepoda≈ôilo se z√≠skat validn√≠ JSON po ${maxRetries} pokusech: ${lastError}`
          );
        },

        // Jednoduch√° validace sch√©matu
        _validateSchema(data, schema) {
          const errors = [];

          const validate = (obj, schemaObj, path = "") => {
            if (typeof schemaObj === "string") {
              // schemaObj je typ: 'string', 'number', 'boolean', 'array', 'object'
              const actualType = Array.isArray(obj) ? "array" : typeof obj;
              if (actualType !== schemaObj && schemaObj !== "any") {
                errors.push(
                  `${path}: oƒçek√°v√°n ${schemaObj}, dost√°n ${actualType}`
                );
              }
            } else if (Array.isArray(schemaObj)) {
              if (!Array.isArray(obj)) {
                errors.push(`${path}: oƒçek√°v√°no pole`);
              }
            } else if (typeof schemaObj === "object" && schemaObj !== null) {
              if (typeof obj !== "object" || obj === null) {
                errors.push(`${path}: oƒçek√°v√°n objekt`);
              } else {
                for (const key of Object.keys(schemaObj)) {
                  if (!(key in obj)) {
                    errors.push(`${path}.${key}: chyb√≠`);
                  } else {
                    validate(obj[key], schemaObj[key], `${path}.${key}`);
                  }
                }
              }
            }
          };

          validate(data, schema);
          return { valid: errors.length === 0, errors };
        },

        // ============== PARALLEL EXECUTION ==============
        async parallel(tasks, options = {}) {
          const {
            maxConcurrent = 3,
            stopOnError = false,
            timeout = this.config.timeout,
            balanceProviders = true,
          } = options;

          const results = [];
          const queue = [...tasks];
          let activeCount = 0;
          let hasError = false;

          // P≈ôi≈ôaƒè providery pokud chceme balancovat
          if (balanceProviders) {
            const providers = this.getAvailableProviders();
            queue.forEach((task, i) => {
              if (!task.provider) {
                task.provider = providers[i % providers.length];
              }
            });
          }

          this.emit("parallel:start", {
            totalTasks: tasks.length,
            maxConcurrent,
          });

          return new Promise((resolve, reject) => {
            const processNext = async () => {
              if (hasError && stopOnError) return;
              if (queue.length === 0 && activeCount === 0) {
                this.emit("parallel:complete", { results });
                resolve(results);
                return;
              }

              while (activeCount < maxConcurrent && queue.length > 0) {
                const task = queue.shift();
                const index = tasks.indexOf(task);
                activeCount++;

                (async () => {
                  const startTime = Date.now();
                  try {
                    this.emit("parallel:task:start", {
                      index,
                      prompt: (task.prompt || task).substring(0, 50),
                    });

                    const response = await this.ask(
                      typeof task === "string" ? task : task.prompt,
                      typeof task === "string"
                        ? options
                        : { ...options, ...task }
                    );

                    results[index] = {
                      success: true,
                      response,
                      duration: Date.now() - startTime,
                      provider: task.provider || options.provider,
                    };

                    this.emit("parallel:task:complete", {
                      index,
                      duration: results[index].duration,
                    });
                  } catch (error) {
                    results[index] = {
                      success: false,
                      error: error.message,
                      duration: Date.now() - startTime,
                    };

                    this.emit("parallel:task:error", {
                      index,
                      error: error.message,
                    });

                    if (stopOnError) {
                      hasError = true;
                      reject(error);
                      return;
                    }
                  }

                  activeCount--;
                  processNext();
                })();
              }
            };

            processNext();
          });
        },

        // ============== MEMORY / LEARNING ==============
        memory: {
          _data: {
            patterns: [], // √öspƒõ≈°n√© vzory
            preferences: {}, // U≈æivatelsk√© preference
            corrections: [], // Opravy
          },
          _maxPatterns: 100,

          // Zaznamenej √∫spƒõ≈°n√Ω vzor
          recordSuccess(input, output, metadata = {}) {
            this._data.patterns.push({
              input: input.substring(0, 100),
              outputPreview: output.substring(0, 50),
              metadata,
              timestamp: Date.now(),
            });

            // Limit velikosti
            if (this._data.patterns.length > this._maxPatterns) {
              this._data.patterns = this._data.patterns.slice(
                -this._maxPatterns
              );
            }
            this._save();
          },

          // Zaznamenej opravu
          recordCorrection(original, corrected) {
            this._data.corrections.push({
              original: original.substring(0, 100),
              corrected: corrected.substring(0, 100),
              timestamp: Date.now(),
            });
            this._save();
          },

          // Nastav preferenci
          setPreference(key, value) {
            this._data.preferences[key] = value;
            this._save();
          },

          // Z√≠skej preferenci
          getPreference(key) {
            return this._data.preferences[key];
          },

          // Z√≠skej kontext pro AI
          getContext() {
            const context = [];

            if (this._data.patterns.length > 0) {
              const recent = this._data.patterns.slice(-3);
              context.push(
                `P≈ôedchoz√≠ √∫spƒõ≈°n√© p≈ô√≠kazy: ${recent
                  .map((p) => p.input)
                  .join(", ")}`
              );
            }

            if (Object.keys(this._data.preferences).length > 0) {
              context.push(
                `Preference: ${JSON.stringify(this._data.preferences)}`
              );
            }

            return context.join("\n");
          },

          // Vyƒçisti pamƒõ≈•
          clear() {
            this._data = { patterns: [], preferences: {}, corrections: [] };
            this._save();
          },

          // Statistiky
          stats() {
            return {
              patterns: this._data.patterns.length,
              preferences: Object.keys(this._data.preferences).length,
              corrections: this._data.corrections.length,
            };
          },

          _save() {
            try {
              localStorage.setItem(
                "ai_module_memory",
                JSON.stringify(this._data)
              );
            } catch (e) {}
          },

          load() {
            try {
              const stored = localStorage.getItem("ai_module_memory");
              if (stored) this._data = JSON.parse(stored);
            } catch (e) {}
          },
        },

        // ============== JSON HELPER ==============
        parseJSON(text) {
          try {
            // Vyƒçisti markdown bloky
            let clean = text
              .replace(/```json\s*/gi, "")
              .replace(/```\s*/g, "")
              .trim();

            // Najdi JSON objekt nebo pole
            const firstBrace = clean.indexOf("{");
            const firstBracket = clean.indexOf("[");
            const lastBrace = clean.lastIndexOf("}");
            const lastBracket = clean.lastIndexOf("]");

            let start, end;
            if (
              firstBrace !== -1 &&
              (firstBracket === -1 || firstBrace < firstBracket)
            ) {
              start = firstBrace;
              end = lastBrace;
            } else if (firstBracket !== -1) {
              start = firstBracket;
              end = lastBracket;
            } else {
              return null;
            }

            if (start !== -1 && end !== -1 && end > start) {
              clean = clean.substring(start, end + 1);
            }

            // Oprav neuzav≈ôen√© z√°vorky
            const openBraces = (clean.match(/\{/g) || []).length;
            const closeBraces = (clean.match(/\}/g) || []).length;
            const openBrackets = (clean.match(/\[/g) || []).length;
            const closeBrackets = (clean.match(/\]/g) || []).length;

            clean += "]".repeat(Math.max(0, openBrackets - closeBrackets));
            clean += "}".repeat(Math.max(0, openBraces - closeBraces));

            // Odstra≈à trailing ƒç√°rky
            clean = clean.replace(/,\s*([}\]])/g, "$1");

            return JSON.parse(clean);
          } catch (e) {
            console.warn("JSON parse failed:", e.message);
            return null;
          }
        },

        // ============== BATCH REQUESTS ==============
        async batch(prompts, options = {}) {
          const results = [];
          const concurrency = options.concurrency || 3;
          const delay = options.delay || 500;

          // Rozdƒõl na skupiny
          for (let i = 0; i < prompts.length; i += concurrency) {
            const batch = prompts.slice(i, i + concurrency);

            // Paralelnƒõ zpracuj skupinu
            const batchResults = await Promise.allSettled(
              batch.map((p) =>
                this.ask(
                  typeof p === "string" ? p : p.prompt,
                  typeof p === "string" ? options : { ...options, ...p }
                )
              )
            );

            results.push(
              ...batchResults.map((r, idx) => ({
                prompt: batch[idx],
                success: r.status === "fulfilled",
                response: r.status === "fulfilled" ? r.value : null,
                error: r.status === "rejected" ? r.reason.message : null,
              }))
            );

            // ƒåekej mezi skupinami
            if (i + concurrency < prompts.length) {
              await new Promise((r) => setTimeout(r, delay));
            }
          }

          return results;
        },

        // ============== QUICK METHODS ==============

        // Dotaz s cache
        async askCached(prompt, options = {}) {
          // Zkus cache
          const cached = this.cache.get(prompt, options);
          if (cached) {
            console.log("üì¶ Cache hit");
            return cached;
          }

          // Zavolej API
          const response = await this.ask(prompt, {
            ...options,
            skipRateLimit: false,
          });

          // Ulo≈æ do cache
          this.cache.set(prompt, response, options);

          return response;
        },

        // Dotaz s ≈°ablonou
        async askWithTemplate(templateName, variables = {}, options = {}) {
          const template = this.templates.apply(templateName, variables);
          if (!template) {
            throw new Error(`≈†ablona '${templateName}' neexistuje`);
          }

          return this.ask(template.prompt, {
            ...options,
            system: template.system,
          });
        },

        // Dotaz s pamƒõt√≠ (p≈ôid√° kontext z memory)
        async askWithMemory(prompt, options = {}) {
          const context = this.memory.getContext();
          const enhancedPrompt = context
            ? `${context}\n\nAktu√°ln√≠ po≈æadavek: ${prompt}`
            : prompt;

          const response = await this.ask(enhancedPrompt, options);

          // Zaznamenej √∫spƒõch
          this.memory.recordSuccess(prompt, response);

          return response;
        },

        // Rychl√Ω p≈ôeklad
        async translate(text, targetLang = "en", options = {}) {
          return this.ask(`P≈ôelo≈æ do ${targetLang}: ${text}`, {
            ...options,
            system: "Jsi p≈ôekladatel. Vra≈• pouze p≈ôeklad, nic jin√©ho.",
          });
        },

        // Rychl√© shrnut√≠
        async summarize(text, sentences = 3, options = {}) {
          return this.ask(`Shr≈à v ${sentences} vƒõt√°ch: ${text}`, {
            ...options,
            system: "Vra≈• pouze shrnut√≠, nic jin√©ho.",
          });
        },

        // Rychl√° extrakce JSON
        async extractJSON(text, schema = null, options = {}) {
          const schemaHint = schema
            ? `\nVra≈• JSON ve form√°tu: ${JSON.stringify(schema)}`
            : "";
          const response = await this.ask(
            `Extrahuj strukturovan√° data z textu:${schemaHint}\n\nText: ${text}`,
            {
              ...options,
              system: "Vra≈• pouze validn√≠ JSON, ≈æ√°dn√Ω dal≈°√≠ text.",
            }
          );
          return this.parseJSON(response);
        },

        // Generov√°n√≠ k√≥du
        async generateCode(task, language = "javascript", options = {}) {
          return this.ask(`Napi≈° ${language} k√≥d: ${task}`, {
            ...options,
            system: `Jsi expert na ${language}. Vra≈• pouze k√≥d s koment√°≈ôi, bez vysvƒõtlen√≠.`,
          });
        },

        // ============== INICIALIZACE ==============
        init() {
          this.stats.load();
          this.rateLimit.load();
          this.conversation.load();
          this.keys.load();
          this.templates.load();
          this.memory.load();

          // Emituj init event
          this.emit("init", {
            version: "3.0",
            providers: this.getAvailableProviders(),
          });

          console.log("ü§ñ AI Module v3.0 inicializov√°n (s automatizac√≠)");
          console.log('   üì° Events: AI.on("request:complete", callback)');
          console.log('   üîó Workflow: AI.workflow.create("name")');
          console.log(
            '   ‚è∞ Scheduler: AI.scheduler.add("job", "every 5m", task)'
          );
          console.log('   üéØ Intent: AI.detectIntent("text")');
          console.log('   ‚ö° Smart: AI.smartAsk("prompt")');
          console.log("   üì¶ Parallel: AI.parallel([prompts])");

          return this;
        },

        // Verze modulu
        version: "3.0.0",
      };

      // Automatick√° inicializace
      AI.init();

      // Expose globally
      window.AI = AI;
    </script>
    <script>
      // ============================================================
      // UI LOGIKA
      // ============================================================
      // MINI KONZOLE
      // ============================================================

      let consoleVisible = false;

      function toggleConsole() {
        const miniConsole = document.getElementById("miniConsole");
        const toggle = document.getElementById("consoleToggle");
        consoleVisible = !consoleVisible;
        miniConsole.style.display = consoleVisible ? "block" : "none";
        toggle.textContent = consoleVisible ? "‚úï" : "üñ•Ô∏è";
        toggle.style.background = consoleVisible ? "#f85149" : "#238636";
      }

      function clearConsole() {
        document.getElementById("consoleOutput").innerHTML = "";
      }

      function logToConsole(type, ...args) {
        const output = document.getElementById("consoleOutput");
        if (!output) return;

        const entry = document.createElement("div");
        entry.className = "console-entry console-" + type;

        const time = new Date().toLocaleTimeString("cs-CZ");
        const prefix =
          type === "error"
            ? "‚ùå"
            : type === "warn"
            ? "‚ö†Ô∏è"
            : type === "info"
            ? "‚ÑπÔ∏è"
            : "üìù";

        let text = args
          .map((arg) => {
            if (typeof arg === "object") {
              try {
                return JSON.stringify(arg, null, 2);
              } catch (e) {
                return String(arg);
              }
            }
            return String(arg);
          })
          .join(" ");

        entry.innerHTML = `<span  class="inl-2d1b37">[${time}]</span> ${prefix} ${text}`;
        output.appendChild(entry);
        output.scrollTop = output.scrollHeight;
      }

      // Zachytit glob√°ln√≠ chyby
      window.onerror = function (msg, url, line, col, error) {
        logToConsole("error", `${msg} (≈ô√°dek ${line})`);
      };

      window.onunhandledrejection = function (event) {
        logToConsole("error", "Promise rejected:", event.reason);
      };

      // ============================================================
      // PROVIDER MANAGEMENT
      // ============================================================

      let currentProvider = "gemini";

      // Init
      document.addEventListener("DOMContentLoaded", () => {
        loadKeys();
        updateKeyStatuses();
        updateModels();
        setupProviderTabs();
        loadHistory();
        setupImageDragDrop();
        updateTokenCount();

        // Nastav v√Ωchoz√≠ system prompt pro ƒçe≈°tinu
        const systemPrompt = document.getElementById("systemPrompt");
        if (systemPrompt) {
          systemPrompt.value =
            "Odpov√≠dej v≈ædy ƒçesky. Jsi p≈ô√°telsk√Ω a n√°pomocn√Ω asistent.";
          systemPrompt.addEventListener("input", updateTokenCount);
        }

        updateTokenCount();
      });

      // Provider tabs
      function setupProviderTabs() {
        const tabs = document.querySelectorAll(".provider-tab");
        if (!tabs.length) return;

        tabs.forEach((tab) => {
          tab.addEventListener("click", () => {
            tabs.forEach((t) => t.classList.remove("active"));
            tab.classList.add("active");
            currentProvider = tab.dataset.provider;
            const providerEl = document.getElementById("currentProvider");
            if (providerEl) providerEl.textContent = currentProvider;
            updateModels();

            // Upozornƒõn√≠ pro HuggingFace na file://
            showProviderWarning(currentProvider);
          });
        });
      }

      function showProviderWarning(provider) {
        // Odstranit p≈ôedchoz√≠ upozornƒõn√≠
        const existingWarning = document.getElementById("providerWarning");
        if (existingWarning) existingWarning.remove();

        if (
          provider === "huggingface" &&
          window.location.protocol === "file:"
        ) {
          const warning = document.createElement("div");
          warning.id = "providerWarning";
          warning.style.cssText =
            "background: rgba(251, 191, 36, 0.2); border: 1px solid #fbbf24; border-radius: 8px; padding: 10px 14px; margin-top: 12px; font-size: 12px; color: #fbbf24;";
          warning.innerHTML =
            '‚ö†Ô∏è <strong>HuggingFace</strong> nefunguje z lok√°ln√≠ho disku (file://). Spus≈• p≈ôes HTTP server: <code  class="inl-1e3098">python -m http.server</code>';

          const modelSection = document.querySelector(".model-section");
          if (modelSection) {
            modelSection.parentNode.insertBefore(
              warning,
              modelSection.nextSibling
            );
          }
        }
      }

      // Update models for selected provider
      function updateModels() {
        const select = document.getElementById("modelSelect");
        if (!select) return;

        const models = AI.getModels(currentProvider);

        select.innerHTML = "";
        models.forEach((model) => {
          const option = document.createElement("option");
          option.value = model.value;
          option.textContent = `${model.name} (${model.rpm} RPM)`;
          select.appendChild(option);
        });

        updateModelInfo();

        select.onchange = updateModelInfo;
      }

      function updateModelInfo() {
        const select = document.getElementById("modelSelect");
        if (!select || !select.value) return;

        const model = select.value;
        const limit = AI.getModelLimit(model);

        const rpmEl = document.getElementById("modelRpm");
        const modelEl = document.getElementById("currentModel");

        if (rpmEl) {
          if (AI.supportsVision(model)) {
            rpmEl.innerHTML = limit + ' <span  class="inl-9bd93d">üëÅÔ∏è</span>';
          } else {
            rpmEl.textContent = limit;
          }
        }

        if (modelEl) {
          modelEl.textContent = model.split("/").pop();
        }

        // Aktualizovat info v hlaviƒçce Nastaven√≠
        const settingsInfo = document.getElementById("currentSettingsInfo");
        if (settingsInfo) {
          const shortModel = model.split("/").pop().substring(0, 25);
          settingsInfo.textContent = `(${currentProvider} / ${shortModel})`;
        }

        // Zobrazit/skr√Ωt upload obr√°zku
        checkVisionModel();
      }

      // Keys management
      function loadKeys() {
        const keys = JSON.parse(localStorage.getItem("aiModuleKeys") || "{}");

        const geminiInput = document.getElementById("keyGemini");
        const groqInput = document.getElementById("keyGroq");
        const openrouterInput = document.getElementById("keyOpenrouter");
        const mistralInput = document.getElementById("keyMistral");
        const cohereInput = document.getElementById("keyCohere");
        const huggingfaceInput = document.getElementById("keyHuggingface");

        if (geminiInput) geminiInput.value = keys.gemini || "";
        if (groqInput) groqInput.value = keys.groq || "";
        if (openrouterInput) openrouterInput.value = keys.openrouter || "";
        if (mistralInput) mistralInput.value = keys.mistral || "";
        if (cohereInput) cohereInput.value = keys.cohere || "";
        if (huggingfaceInput) huggingfaceInput.value = keys.huggingface || "";

        Object.entries(keys).forEach(([provider, key]) => {
          if (key) AI.setKey(provider, key);
        });
      }

      function saveKeys() {
        const keys = {
          gemini: document.getElementById("keyGemini")?.value.trim() || "",
          groq: document.getElementById("keyGroq")?.value.trim() || "",
          openrouter:
            document.getElementById("keyOpenrouter")?.value.trim() || "",
          mistral: document.getElementById("keyMistral")?.value.trim() || "",
          cohere: document.getElementById("keyCohere")?.value.trim() || "",
          huggingface:
            document.getElementById("keyHuggingface")?.value.trim() || "",
        };

        localStorage.setItem("aiModuleKeys", JSON.stringify(keys));

        Object.entries(keys).forEach(([provider, key]) => {
          AI.setKey(provider, key);
        });

        updateKeyStatuses();
        alert("‚úÖ Kl√≠ƒçe ulo≈æeny!");
      }

      function clearKeys() {
        if (!confirm("Opravdu smazat v≈°echny kl√≠ƒçe?")) return;

        localStorage.removeItem("aiModuleKeys");
        [
          "keyGemini",
          "keyGroq",
          "keyOpenrouter",
          "keyMistral",
          "keyCohere",
          "keyHuggingface",
        ].forEach((id) => {
          const el = document.getElementById(id);
          if (el) el.value = "";
        });
        [
          "gemini",
          "groq",
          "openrouter",
          "mistral",
          "cohere",
          "huggingface",
        ].forEach((p) => AI.setKey(p, ""));
        updateKeyStatuses();
      }

      // ============================================================
      // EXPORT / IMPORT NASTAVEN√ç
      // ============================================================

      function exportSettings() {
        const settings = {
          version: "1.0",
          exportDate: new Date().toISOString(),
          keys: JSON.parse(localStorage.getItem("aiModuleKeys") || "{}"),
          history: JSON.parse(localStorage.getItem("aiChatHistory") || "[]"),
          preferences: {
            lastProvider: currentProvider,
            lastModel: document.getElementById("modelSelect")?.value,
          },
        };

        const blob = new Blob([JSON.stringify(settings, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `ai-module-backup-${
          new Date().toISOString().split("T")[0]
        }.json`;
        a.click();
        URL.revokeObjectURL(url);

        alert("‚úÖ Nastaven√≠ exportov√°no!");
      }

      function importSettings() {
        document.getElementById("importInput").click();
      }

      function handleImport(event) {
        const file = event.target.files?.[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const settings = JSON.parse(e.target.result);

            // Validace
            if (!settings.version || !settings.keys) {
              throw new Error("Neplatn√Ω form√°t souboru");
            }

            // Import kl√≠ƒç≈Ø
            if (settings.keys) {
              localStorage.setItem(
                "aiModuleKeys",
                JSON.stringify(settings.keys)
              );
              loadKeys();
            }

            // Import historie (volitelnƒõ)
            if (settings.history && settings.history.length > 0) {
              if (
                confirm(
                  `Importovat tak√© historii chatu (${settings.history.length} polo≈æek)?`
                )
              ) {
                const existingHistory = JSON.parse(
                  localStorage.getItem("aiChatHistory") || "[]"
                );
                const merged = [...existingHistory, ...settings.history];
                // Deduplikace podle id
                const unique = merged.filter(
                  (item, index, self) =>
                    index === self.findIndex((t) => t.id === item.id)
                );
                localStorage.setItem("aiChatHistory", JSON.stringify(unique));
                loadHistory();
              }
            }

            updateKeyStatuses();
            alert("‚úÖ Nastaven√≠ importov√°no!");
          } catch (err) {
            alert("‚ùå Chyba p≈ôi importu: " + err.message);
          }
        };
        reader.readAsText(file);

        // Reset input
        event.target.value = "";
      }

      // ============================================================
      // RETRY POSLEDN√ç DOTAZ
      // ============================================================

      let lastRequest = {
        prompt: null,
        system: null,
        provider: null,
        model: null,
      };

      function saveLastRequest(prompt, system, provider, model) {
        lastRequest = { prompt, system, provider, model };
      }

      async function retryLastRequest() {
        if (!lastRequest.prompt) {
          alert("≈Ω√°dn√Ω p≈ôedchoz√≠ dotaz k opakov√°n√≠");
          return;
        }

        // Obnovit hodnoty
        const promptEl = document.getElementById("userPrompt");
        const systemEl = document.getElementById("systemPrompt");

        if (promptEl) promptEl.value = lastRequest.prompt;
        if (systemEl) systemEl.value = lastRequest.system || "";

        // Odeslat
        await sendRequest();
      }

      // ============================================================
      // POROVN√ÅN√ç MODEL≈Æ
      // ============================================================

      let compareResults = [];
      let selectedModelsForCompare = [];

      function compareModels() {
        const prompt = document.getElementById("userPrompt")?.value.trim();

        if (!prompt) {
          alert("Zadej dotaz pro porovn√°n√≠!");
          return;
        }

        const modal = document.getElementById("compareModal");
        const summaryEl = document.getElementById("compareSummary");
        const resultsEl = document.getElementById("compareResults");

        if (!modal) return;

        modal.style.display = "flex";

        // Vytvo≈ôit v√Ωbƒõr model≈Ø
        summaryEl.innerHTML = "";
        resultsEl.innerHTML = renderModelSelector();

        // Inicializovat vybran√© modely (prvn√≠ z ka≈æd√©ho providera s kl√≠ƒçem)
        selectedModelsForCompare = [];
        const providers = [
          "gemini",
          "groq",
          "openrouter",
          "mistral",
          "cohere",
          "huggingface",
        ];

        providers.forEach((provider) => {
          if (AI.getKey(provider)) {
            const models = AI.ALL_MODELS[provider];
            if (models && models.length > 0) {
              selectedModelsForCompare.push({
                provider: provider,
                model: models[0].value,
                name: models[0].name,
              });
            }
          }
        });

        updateModelSelector();
      }

      function renderModelSelector() {
        const providerEmojis = {
          gemini: "ü§ñ",
          groq: "‚ö°",
          openrouter: "üåê",
          mistral: "üî•",
          cohere: "üß†",
          huggingface: "ü§ó",
        };

        let html = `
        <div class="compare-model-select">
            <label>Vyber modely pro porovn√°n√≠ (klikni pro v√Ωbƒõr/zru≈°en√≠):</label>
            <div class="compare-checkboxes" id="modelCheckboxes">
    `;

        const providers = [
          "gemini",
          "groq",
          "openrouter",
          "mistral",
          "cohere",
          "huggingface",
        ];

        providers.forEach((provider) => {
          const key = AI.getKey(provider);
          const models = AI.ALL_MODELS[provider] || [];

          if (!key || models.length === 0) return;

          models.forEach((model) => {
            const id = `compare_${provider}_${model.value.replace(
              /[^a-zA-Z0-9]/g,
              "_"
            )}`;
            html += `
                <label class="compare-checkbox" data-provider="${provider}" data-model="${
              model.value
            }" data-name="${model.name}" onclick="toggleModelForCompare(this)">
                    ${providerEmojis[provider]} ${model.name
              .replace(/[ü§ñ‚ö°üåêüî•üß†ü§óüíªüí¨üëÅÔ∏èü¶ôüî¨ü™∂üß™]/g, "")
              .trim()}
                </label>
            `;
          });
        });

        html += `
            </div>
            <div class="margin-top-12">
                <button class="btn-primary" onclick="startComparison()">üöÄ Spustit porovn√°n√≠</button>
                <button class="btn-secondary" onclick="selectAllModels()">Vybrat v≈°e</button>
                <button class="btn-secondary" onclick="deselectAllModels()">Zru≈°it v√Ωbƒõr</button>
            </div>
        </div>
        <div class="compare-grid" id="compareGrid"></div>
    `;

        return html;
      }

      function toggleModelForCompare(el) {
        const provider = el.dataset.provider;
        const model = el.dataset.model;
        const name = el.dataset.name;

        const index = selectedModelsForCompare.findIndex(
          (m) => m.provider === provider && m.model === model
        );

        if (index >= 0) {
          selectedModelsForCompare.splice(index, 1);
          el.classList.remove("selected");
        } else {
          selectedModelsForCompare.push({ provider, model, name });
          el.classList.add("selected");
        }
      }

      function updateModelSelector() {
        document.querySelectorAll(".compare-checkbox").forEach((el) => {
          const provider = el.dataset.provider;
          const model = el.dataset.model;
          const isSelected = selectedModelsForCompare.some(
            (m) => m.provider === provider && m.model === model
          );
          el.classList.toggle("selected", isSelected);
        });
      }

      function selectAllModels() {
        selectedModelsForCompare = [];
        document.querySelectorAll(".compare-checkbox").forEach((el) => {
          selectedModelsForCompare.push({
            provider: el.dataset.provider,
            model: el.dataset.model,
            name: el.dataset.name,
          });
          el.classList.add("selected");
        });
      }

      function deselectAllModels() {
        selectedModelsForCompare = [];
        document.querySelectorAll(".compare-checkbox").forEach((el) => {
          el.classList.remove("selected");
        });
      }

      async function startComparison() {
        if (selectedModelsForCompare.length === 0) {
          alert("Vyber alespo≈à jeden model!");
          return;
        }

        const prompt = document.getElementById("userPrompt")?.value.trim();
        const system = document.getElementById("systemPrompt")?.value.trim();

        if (!prompt) {
          alert("Zadej dotaz!");
          return;
        }

        const grid = document.getElementById("compareGrid");
        const summaryEl = document.getElementById("compareSummary");

        compareResults = [];

        // P≈ôipravit karty
        grid.innerHTML = selectedModelsForCompare
          .map(
            (m, i) => `
        <div class="compare-card loading" id="compareCard${i}">
            <div class="compare-card-header">
                <div class="compare-card-title">${m.name}</div>
                <div class="compare-card-meta">${m.provider}</div>
            </div>
            <div class="compare-card-response loading-text">‚è≥ ƒåek√°m na odpovƒõƒè...</div>
        </div>
    `
          )
          .join("");

        // Spustit v≈°echny paralelnƒõ
        const promises = selectedModelsForCompare.map(async (m, i) => {
          const startTime = performance.now();

          try {
            const response = await AI.ask(prompt, {
              provider: m.provider,
              model: m.model,
              system: system || undefined,
            });

            const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);

            compareResults.push({
              provider: m.provider,
              model: m.model,
              name: m.name,
              success: true,
              response: response,
              time: elapsed,
              chars: response.length,
            });

            updateCompareCard(i, true, response, elapsed);
          } catch (error) {
            const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);

            compareResults.push({
              provider: m.provider,
              model: m.model,
              name: m.name,
              success: false,
              error: error.message,
              time: elapsed,
            });

            updateCompareCard(i, false, error.message, elapsed);
          }
        });

        await Promise.all(promises);

        // Aktualizovat souhrn
        const success = compareResults.filter((r) => r.success).length;
        const failed = compareResults.filter((r) => !r.success).length;
        const avgTime =
          success > 0
            ? (
                compareResults
                  .filter((r) => r.success)
                  .reduce((sum, r) => sum + parseFloat(r.time), 0) / success
              ).toFixed(2)
            : 0;
        const fastest =
          success > 0
            ? compareResults
                .filter((r) => r.success)
                .sort((a, b) => parseFloat(a.time) - parseFloat(b.time))[0]
            : null;

        summaryEl.innerHTML = `
        <div class="summary-card">
            <div class="value">${selectedModelsForCompare.length}</div>
            <div class="label">üì¶ Testov√°no</div>
        </div>
        <div class="summary-card success">
            <div class="value">${success}</div>
            <div class="label">‚úÖ √öspƒõch</div>
        </div>
        <div class="summary-card error">
            <div class="value">${failed}</div>
            <div class="label">‚ùå Chyba</div>
        </div>
        <div class="summary-card">
            <div class="value">${avgTime}s</div>
            <div class="label">‚ö° Pr≈Ømƒõr</div>
        </div>
        ${
          fastest
            ? `
        <div class="summary-card inl-2d944b">
            <div class="value inl-28c77b">${fastest.name.substring(0, 15)}</div>
            <div class="label">üèÜ Nejrychlej≈°√≠</div>
        </div>
        `
            : ""
        }
    `;
      }

      function updateCompareCard(index, success, content, time) {
        const card = document.getElementById(`compareCard${index}`);
        if (!card) return;

        card.classList.remove("loading");
        card.classList.add(success ? "success" : "error");

        const responseEl = card.querySelector(".compare-card-response");
        responseEl.classList.remove("loading-text");

        if (success) {
          responseEl.textContent = content;
        } else {
          responseEl.classList.add("error-text");
          responseEl.textContent = "‚ùå " + content;
        }

        const metaEl = card.querySelector(".compare-card-meta");
        metaEl.textContent += ` ‚Ä¢ ${time}s`;
        if (success) {
          metaEl.textContent += ` ‚Ä¢ ${content.length} znak≈Ø`;
        }
      }

      function closeCompareModal() {
        const modal = document.getElementById("compareModal");
        if (modal) modal.style.display = "none";
      }

      function copyCompareReport() {
        const prompt = document.getElementById("userPrompt")?.value.trim();

        let report = "‚öñÔ∏è POROVN√ÅN√ç AI MODEL≈Æ\n";
        report += "========================\n\n";
        report += `üìù Dotaz: ${prompt}\n\n`;

        const success = compareResults.filter((r) => r.success);
        const failed = compareResults.filter((r) => !r.success);

        report += `üìä V√Ωsledky: ‚úÖ ${success.length} OK | ‚ùå ${failed.length} chyb\n\n`;

        if (success.length > 0) {
          // Se≈ôadit podle ƒçasu
          const sorted = [...success].sort(
            (a, b) => parseFloat(a.time) - parseFloat(b.time)
          );

          report += "üèÜ PO≈òAD√ç (podle rychlosti):\n";
          report += "-".repeat(40) + "\n";

          sorted.forEach((r, i) => {
            report += `${i + 1}. ${r.name} (${r.provider}) - ${r.time}s\n`;
            report += `   Odpovƒõƒè: ${r.response.substring(0, 100)}${
              r.response.length > 100 ? "..." : ""
            }\n\n`;
          });
        }

        if (failed.length > 0) {
          report += "\n‚ùå CHYBY:\n";
          failed.forEach((r) => {
            report += `- ${r.name}: ${r.error}\n`;
          });
        }

        copyToClipboard(report).then((success) => {
          if (success) {
            alert("üìã Report zkop√≠rov√°n!");
          } else {
            const win = window.open("", "_blank", "width=600,height=400");
            win.document.write(
              '<pre class="mono-pre">' + report.replace(/</g, "&lt;") + "</pre>"
            );
            win.document.title = "Compare Report";
          }
        });
      }

      function updateKeyStatuses() {
        [
          "gemini",
          "groq",
          "openrouter",
          "mistral",
          "cohere",
          "huggingface",
        ].forEach((provider) => {
          const statusId =
            "status" + provider.charAt(0).toUpperCase() + provider.slice(1);
          const status = document.getElementById(statusId);
          if (!status) return;

          const hasCustom =
            AI.config.keys[provider] && AI.config.keys[provider].length > 10;
          const hasDemo =
            AI.DEMO_KEYS[provider] && AI.DEMO_KEYS[provider].length > 10;

          if (hasCustom) {
            status.textContent = "‚úÖ";
            status.className = "key-status ok";
            status.title = "Vlastn√≠ kl√≠ƒç";
          } else if (hasDemo) {
            status.textContent = "‚ö†Ô∏è";
            status.className = "key-status demo";
            status.title = "Demo kl√≠ƒç";
          } else {
            status.textContent = "‚óã";
            status.className = "key-status none";
            status.title = "≈Ω√°dn√Ω kl√≠ƒç";
          }
        });
      }

      function toggleKeys() {
        const content = document.getElementById("keysContent");
        if (!content) return;

        const header = content.previousElementSibling;
        content.classList.toggle("open");
        if (header) header.classList.toggle("open");
      }

      // Status helpers
      function setStatus(type, text) {
        const badge = document.getElementById("statusBadge");
        if (!badge) return;

        badge.className = "status-badge " + type;

        if (type === "loading") {
          badge.innerHTML =
            '<div class="loading-dots"><span></span><span></span><span></span></div> ' +
            text;
        } else {
          badge.innerHTML = "‚óè " + text;
        }
      }

      // Glob√°ln√≠ promƒõnn√° pro posledn√≠ odpovƒõƒè
      let lastResponse = "";

      // P≈ôid√° zpr√°vu do chatu
      function addChatMessage(
        text,
        isUser = false,
        isError = false,
        isLoading = false,
        attachment = null
      ) {
        const container = document.getElementById("chatContainer");
        const empty = document.getElementById("chatEmpty");
        if (!container) return;

        // Skryj placeholder
        if (empty) empty.style.display = "none";

        const msgDiv = document.createElement("div");
        msgDiv.className = `chat-message ${isUser ? "user" : "assistant"}`;

        const bubble = document.createElement("div");
        bubble.className = "chat-bubble";
        if (isError) bubble.classList.add("error");
        if (isLoading) bubble.classList.add("loading");

        // P≈ôidej text
        if (text) {
          bubble.textContent = text;
        }

        // P≈ôidej p≈ô√≠lohu (obr√°zek nebo soubor)
        if (attachment) {
          const attachDiv = document.createElement("div");
          attachDiv.className = "attachment-preview";

          if (attachment.type === "image" && attachment.dataUrl) {
            const img = document.createElement("img");
            img.src = attachment.dataUrl;
            img.alt = attachment.name || "Obr√°zek";
            attachDiv.appendChild(img);
          } else {
            const fileDiv = document.createElement("div");
            fileDiv.className = "attachment-file";
            fileDiv.innerHTML = `üìé ${attachment.name}`;
            attachDiv.appendChild(fileDiv);
          }

          bubble.appendChild(attachDiv);
        }

        msgDiv.appendChild(bubble);
        container.appendChild(msgDiv);

        // Scroll dol≈Ø
        container.scrollTop = container.scrollHeight;

        return bubble; // Vr√°t√≠ bublinu pro pozdƒõj≈°√≠ update
      }

      // Aktualizuje posledn√≠ AI bublinu
      function updateLastAssistantBubble(text, isError = false) {
        const container = document.getElementById("chatContainer");
        if (!container) return;

        const messages = container.querySelectorAll(".chat-message.assistant");
        if (messages.length === 0) return;

        const lastMsg = messages[messages.length - 1];
        const bubble = lastMsg.querySelector(".chat-bubble");
        if (bubble) {
          bubble.textContent = text;
          bubble.classList.remove("loading", "error");
          if (isError) bubble.classList.add("error");
        }

        container.scrollTop = container.scrollHeight;
      }

      // Vyƒçist√≠ chat
      function clearChat() {
        const container = document.getElementById("chatContainer");
        const empty = document.getElementById("chatEmpty");
        if (container) {
          container.innerHTML = "";
          if (empty) {
            container.appendChild(empty);
            empty.style.display = "block";
          } else {
            container.innerHTML =
              '<div class="chat-empty" id="chatEmpty">Zaƒçni konverzaci...</div>';
          }
        }
        lastResponse = "";
      }

      // Star√Ω setOutput pro kompatibilitu (p≈ôesmƒõruje do chatu)
      function setOutput(text, isError = false, isLoading = false) {
        // Pro kompatibilitu - pokud existuje #output, pou≈æij ho
        const output = document.getElementById("output");
        if (output) {
          output.textContent = text;
          output.className = isError ? "error" : isLoading ? "loading" : "";
        }
      }

      // Send request
      async function sendRequest() {
        const promptInput = document.getElementById("userPrompt");
        let prompt = promptInput?.value.trim();
        const system = document.getElementById("systemPrompt")?.value.trim();
        const model = document.getElementById("modelSelect")?.value;

        // Pokud nen√≠ prompt ale je soubor, pou≈æij v√Ωchoz√≠ prompt
        if (!prompt && !uploadedFile.base64 && !uploadedFile.content) {
          alert("Zadej dotaz nebo nahraj soubor!");
          return;
        }

        // P≈ôiprav attachment info pro zobrazen√≠ v chatu
        let attachment = null;
        if (uploadedFile.base64 || uploadedFile.content) {
          attachment = {
            type: uploadedFile.type,
            name: uploadedFile.name,
            dataUrl: uploadedFile.dataUrl,
          };
        }

        // Pokud je textov√Ω soubor, p≈ôidej obsah do promptu
        if (uploadedFile.type === "text" && uploadedFile.content) {
          const fileContent = uploadedFile.content.substring(0, 10000); // Max 10k znak≈Ø
          prompt = prompt
            ? `${prompt}\n\nObsah souboru "${uploadedFile.name}":\n\`\`\`\n${fileContent}\n\`\`\``
            : `Analyzuj tento soubor "${uploadedFile.name}":\n\`\`\`\n${fileContent}\n\`\`\``;
        }

        // Pokud je obr√°zek bez textu, p≈ôidej v√Ωchoz√≠ prompt
        if (uploadedFile.type === "image" && !prompt) {
          prompt = "Co vid√≠≈° na tomto obr√°zku? Popi≈° ho.";
        }

        // Ulo≈æ image data p≈ôed vyƒçi≈°tƒõn√≠m
        const imageData =
          uploadedFile.type === "image"
            ? {
                base64: uploadedFile.base64,
                mimeType: uploadedFile.mimeType,
              }
            : null;

        // P≈ôidej u≈æivatelovu zpr√°vu do chatu (s p≈ô√≠lohou)
        addChatMessage(
          promptInput?.value.trim() || prompt,
          true,
          false,
          false,
          attachment
        );

        // Vyƒçisti input a soubor
        if (promptInput) promptInput.value = "";
        removeFile();
        updateTokenCount();

        // Ulo≈æit pro retry
        saveLastRequest(prompt, system, currentProvider, model);

        const btn = document.getElementById("btnSend");
        if (btn) btn.disabled = true;

        setStatus("loading", "Odes√≠l√°m...");

        // P≈ôidej loading zpr√°vu od asistenta
        addChatMessage("P≈ôem√Ω≈°l√≠m...", false, false, true);

        const startTime = performance.now();

        try {
          // P≈ôipravit options
          const options = {
            provider: currentProvider,
            model: model,
            system: system || undefined,
          };

          // P≈ôidat obr√°zek pokud byl nahr√°n a model podporuje vision
          if (imageData && AI.supportsVision(model)) {
            options.imageBase64 = imageData.base64;
            options.imageMimeType = imageData.mimeType;
          }

          const response = await AI.ask(prompt, options);

          const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);

          // Aktualizuj loading zpr√°vu na skuteƒçnou odpovƒõƒè
          updateLastAssistantBubble(response);
          lastResponse = response;

          setStatus("success", `Hotovo (${elapsed}s)`);

          // P≈ôidat do historie
          addToHistory(prompt, response, currentProvider, model, elapsed);
        } catch (error) {
          updateLastAssistantBubble("‚ùå Chyba: " + error.message, true);
          setStatus("error", "Chyba");
        }

        if (btn) btn.disabled = false;
      }

      // Stream
      async function sendStream() {
        const promptInput = document.getElementById("userPrompt");
        const prompt = promptInput?.value.trim();
        const system = document.getElementById("systemPrompt")?.value.trim();
        const model = document.getElementById("modelSelect")?.value;

        if (!prompt) {
          alert("Zadej dotaz!");
          return;
        }

        // P≈ôidej u≈æivatelovu zpr√°vu do chatu
        addChatMessage(prompt, true);

        // Vyƒçisti input
        if (promptInput) promptInput.value = "";
        updateTokenCount();

        setStatus("loading", "Streamuji...");

        // P≈ôidej pr√°zdnou bublinu pro stream
        const bubble = addChatMessage("", false, false, true);

        const startTime = performance.now();
        let fullResponse = "";

        try {
          for await (const chunk of AI.askStream(prompt, {
            provider: currentProvider,
            model: model,
            system: system || undefined,
          })) {
            fullResponse += chunk;
            if (bubble) {
              bubble.textContent = fullResponse;
              bubble.classList.remove("loading");
            }
            // Scroll chat dol≈Ø
            const container = document.getElementById("chatContainer");
            if (container) container.scrollTop = container.scrollHeight;
          }

          lastResponse = fullResponse;
          const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
          setStatus("success", `Stream hotov (${elapsed}s)`);

          // P≈ôidat do historie
          addToHistory(prompt, fullResponse, currentProvider, model, elapsed);
        } catch (error) {
          if (bubble) {
            bubble.textContent = "‚ùå Chyba: " + error.message;
            bubble.classList.add("error");
            bubble.classList.remove("loading");
          }
          setStatus("error", "Chyba");
        }
      }

      // Fallback test
      async function testFallback() {
        const prompt = document.getElementById("userPrompt")?.value.trim();
        const system = document.getElementById("systemPrompt")?.value.trim();

        if (!prompt) {
          alert("Zadej dotaz!");
          return;
        }

        setStatus("loading", "Zkou≈°√≠m providery...");
        setOutput(
          "üîÑ Testuji fallback p≈ôes v≈°echny providery...\n\n",
          false,
          true
        );

        const output = document.getElementById("output");
        const startTime = performance.now();

        try {
          const response = await AI.askWithFallback(prompt, {
            system: system || undefined,
          });

          const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
          if (output) {
            output.textContent += response;
            output.className = "";
          }
          setStatus("success", `Fallback OK (${elapsed}s)`);
        } catch (error) {
          if (output) {
            output.textContent += "‚ùå V≈°ichni selhali: " + error.message;
            output.className = "error";
          }
          setStatus("error", "V≈°e selhalo");
        }
      }

      // Clear
      function clearOutput() {
        clearChat();
        setStatus("ready", "P≈ôipraven");
      }

      // Copy response
      function copyResponse() {
        if (!lastResponse) {
          return;
        }

        copyToClipboard(lastResponse).then((success) => {
          if (success) {
            // Vizu√°ln√≠ feedback
            const btn = event?.target;
            if (btn) {
              const originalText = btn.textContent;
              btn.textContent = "‚úÖ Zkop√≠rov√°no";
              setTimeout(() => (btn.textContent = originalText), 1000);
            }
          }
        });
      }

      // ============================================================
      // HISTORIE CHATU
      // ============================================================

      let chatHistory = [];

      function loadHistory() {
        const saved = localStorage.getItem("aiChatHistory");
        if (saved) {
          chatHistory = JSON.parse(saved);
          renderHistory();
        }
      }

      function saveHistory() {
        // Omezit na posledn√≠ch 50 zpr√°v
        if (chatHistory.length > 50) {
          chatHistory = chatHistory.slice(-50);
        }
        localStorage.setItem("aiChatHistory", JSON.stringify(chatHistory));
      }

      function addToHistory(prompt, response, provider, model, time) {
        chatHistory.push({
          id: Date.now(),
          prompt,
          response,
          provider,
          model,
          time,
          timestamp: new Date().toISOString(),
        });
        saveHistory();
        renderHistory();
      }

      function renderHistory() {
        const container = document.getElementById("chatHistory");
        if (!container) return;

        if (chatHistory.length === 0) {
          container.innerHTML =
            '<div class="history-empty">Zat√≠m ≈æ√°dn√° historie...</div>';
          return;
        }

        container.innerHTML = chatHistory
          .slice()
          .reverse()
          .map((item) => {
            const date = new Date(item.timestamp);
            const timeStr = date.toLocaleString("cs-CZ");
            const shortResponse =
              item.response.length > 200
                ? item.response.substring(0, 200) + "..."
                : item.response;

            return `
            <div class="history-item">
                <div class="history-meta">
                    <span>${item.provider}/${item.model.split("/").pop()}</span>
                    <span>${timeStr} ‚Ä¢ ${item.time}s</span>
                </div>
                <div class="history-prompt">üí¨ ${escapeHtml(item.prompt)}</div>
                <div class="history-response">${escapeHtml(shortResponse)}</div>
                <div class="history-actions">
                    <button class="btn-small" onclick="reusePrompt('${escapeAttr(
                      item.prompt
                    )}')">üîÑ Znovu</button>
                    <button class="btn-small" onclick="copyHistoryItem('${escapeAttr(
                      item.response
                    )}')">üìã Kop√≠rovat</button>
                    <button class="btn-small" onclick="deleteHistoryItem(${
                      item.id
                    })">üóëÔ∏è</button>
                </div>
            </div>
        `;
          })
          .join("");
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      function escapeAttr(text) {
        return text
          .replace(/'/g, "\\'")
          .replace(/\n/g, "\\n")
          .substring(0, 500);
      }

      function reusePrompt(prompt) {
        const textarea = document.getElementById("userPrompt");
        if (textarea) {
          textarea.value = prompt.replace(/\\n/g, "\n");
          textarea.focus();
        }
      }

      function copyHistoryItem(text) {
        copyToClipboard(text.replace(/\\n/g, "\n"));
      }

      function deleteHistoryItem(id) {
        chatHistory = chatHistory.filter((item) => item.id !== id);
        saveHistory();
        renderHistory();
      }

      function clearHistory() {
        if (!confirm("Opravdu smazat celou historii?")) return;
        chatHistory = [];
        localStorage.removeItem("aiChatHistory");
        renderHistory();
      }

      function exportHistory() {
        if (chatHistory.length === 0) {
          alert("Historie je pr√°zdn√°");
          return;
        }

        let text = "# AI Chat Historie\n\n";
        chatHistory.forEach((item) => {
          const date = new Date(item.timestamp).toLocaleString("cs-CZ");
          text += `## ${date}\n`;
          text += `**Model:** ${item.provider}/${item.model}\n`;
          text += `**ƒåas:** ${item.time}s\n\n`;
          text += `**Dotaz:**\n${item.prompt}\n\n`;
          text += `**Odpovƒõƒè:**\n${item.response}\n\n`;
          text += "---\n\n";
        });

        const blob = new Blob([text], { type: "text/markdown" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `ai-chat-history-${
          new Date().toISOString().split("T")[0]
        }.md`;
        a.click();
        URL.revokeObjectURL(url);
      }

      function toggleHistory() {
        const content = document.getElementById("historyContent");
        const arrow = document.getElementById("historyArrow");
        if (content) {
          content.classList.toggle("open");
        }
        if (arrow) {
          arrow.style.transform = content?.classList.contains("open")
            ? "rotate(180deg)"
            : "";
        }
      }

      function toggleSection(sectionId) {
        const content = document.getElementById(sectionId);
        const arrow = document.getElementById(sectionId + "Arrow");

        if (content) {
          content.classList.toggle("open");
        }
        if (arrow) {
          arrow.textContent = content?.classList.contains("open") ? "‚ñº" : "‚ñ∂";
        }
      }

      // ============================================================
      // POƒå√çTADLO TOKEN≈Æ
      // ============================================================

      function estimateTokens(text) {
        if (!text) return 0;
        // P≈ôibli≈æn√Ω odhad: 1 token ‚âà 4 znaky pro angliƒçtinu, 2-3 pro ƒçe≈°tinu
        const words = text.split(/\s+/).filter((w) => w.length > 0);
        const chars = text.length;
        // Kombinovan√Ω odhad
        return Math.ceil((chars / 3.5 + words.length) / 2);
      }

      function updateTokenCount() {
        const prompt = document.getElementById("userPrompt")?.value || "";
        const system = document.getElementById("systemPrompt")?.value || "";

        const promptTokens = estimateTokens(prompt);
        const systemTokens = estimateTokens(system);
        const totalTokens = promptTokens + systemTokens;

        const tokenCountEl = document.getElementById("tokenCount");
        const tokenCostEl = document.getElementById("tokenCost");

        if (tokenCountEl) {
          let label = `~${totalTokens} token≈Ø`;
          if (systemTokens > 0) {
            label += ` (prompt: ${promptTokens}, system: ${systemTokens})`;
          }
          tokenCountEl.textContent = label;
        }

        // Odhad ceny (pro placen√© modely)
        if (tokenCostEl) {
          // Vƒõt≈°ina free model≈Ø, tak≈æe nezobrazujeme cenu
          tokenCostEl.textContent = "";
        }
      }

      // ============================================================
      // UPLOAD OBR√ÅZK≈Æ (Vision modely)
      // ============================================================

      let uploadedImage = {
        base64: null,
        mimeType: null,
        name: null,
        size: null,
      };

      function checkVisionModel() {
        const model = document.getElementById("modelSelect")?.value;
        const section = document.getElementById("imageUploadSection");

        if (!section) return;

        const isVision = AI.supportsVision(model);
        section.style.display = isVision ? "block" : "none";

        // Pokud p≈ôepneme na ne-vision model, vyƒçistit obr√°zek
        if (!isVision && uploadedImage.base64) {
          removeImage();
        }
      }

      function handleImageUpload(event) {
        const file = event.target.files?.[0];
        if (!file) return;

        // Kontrola typu
        if (!file.type.startsWith("image/")) {
          alert("Pros√≠m vyber obr√°zek (JPG, PNG, GIF, WebP)");
          return;
        }

        // Kontrola velikosti (max 20MB)
        if (file.size > 20 * 1024 * 1024) {
          alert("Obr√°zek je p≈ô√≠li≈° velk√Ω (max 20MB)");
          return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
          const base64Full = e.target.result;
          // Odstranit prefix "data:image/...;base64,"
          const base64 = base64Full.split(",")[1];

          uploadedImage = {
            base64: base64,
            mimeType: file.type,
            name: file.name,
            size: file.size,
          };

          showImagePreview(base64Full, file);
        };
        reader.readAsDataURL(file);
      }

      function showImagePreview(dataUrl, file) {
        const placeholder = document.getElementById("uploadPlaceholder");
        const preview = document.getElementById("imagePreview");
        const previewImg = document.getElementById("previewImg");
        const imageInfo = document.getElementById("imageInfo");

        if (placeholder) placeholder.style.display = "none";
        if (preview) preview.style.display = "inline-block";
        if (previewImg) previewImg.src = dataUrl;

        if (imageInfo) {
          const sizeKB = (file.size / 1024).toFixed(1);
          imageInfo.textContent = `üìé ${file.name} (${sizeKB} KB)`;
        }
      }

      function removeImage(event) {
        if (event) {
          event.stopPropagation();
        }

        uploadedImage = {
          base64: null,
          mimeType: null,
          name: null,
          size: null,
        };

        const placeholder = document.getElementById("uploadPlaceholder");
        const preview = document.getElementById("imagePreview");
        const imageInfo = document.getElementById("imageInfo");
        const imageInput = document.getElementById("imageInput");

        if (placeholder) placeholder.style.display = "flex";
        if (preview) preview.style.display = "none";
        if (imageInfo) imageInfo.textContent = "";
        if (imageInput) imageInput.value = "";
      }

      // Drag & drop
      function setupImageDragDrop() {
        const area = document.getElementById("imageUploadArea");
        if (!area) return;

        area.addEventListener("dragover", (e) => {
          e.preventDefault();
          area.classList.add("dragover");
        });

        area.addEventListener("dragleave", () => {
          area.classList.remove("dragover");
        });

        area.addEventListener("drop", (e) => {
          e.preventDefault();
          area.classList.remove("dragover");

          const file = e.dataTransfer.files?.[0];
          if (file) {
            // Simulovat input change
            const input = document.getElementById("imageInput");
            const dt = new DataTransfer();
            dt.items.add(file);
            input.files = dt.files;
            handleImageUpload({ target: input });
          }
        });
      }

      // ============================================================
      // NOV√ù FILE UPLOAD PRO CHAT
      // ============================================================

      let uploadedFile = {
        base64: null,
        mimeType: null,
        name: null,
        size: null,
        type: null, // 'image' nebo 'text'
        content: null, // pro textov√© soubory
      };

      function handleFileSelect(event) {
        const file = event.target.files?.[0];
        if (!file) return;

        // Kontrola velikosti (max 20MB)
        if (file.size > 20 * 1024 * 1024) {
          alert("Soubor je p≈ô√≠li≈° velk√Ω (max 20MB)");
          return;
        }

        const isImage = file.type.startsWith("image/");
        const isText =
          file.type.startsWith("text/") ||
          file.name.endsWith(".json") ||
          file.name.endsWith(".md") ||
          file.name.endsWith(".csv");

        if (isImage) {
          // Zpracuj jako obr√°zek
          const reader = new FileReader();
          reader.onload = (e) => {
            const base64Full = e.target.result;
            const base64 = base64Full.split(",")[1];

            uploadedFile = {
              base64: base64,
              mimeType: file.type,
              name: file.name,
              size: file.size,
              type: "image",
              content: null,
              dataUrl: base64Full,
            };

            // Tak√© nastav uploadedImage pro kompatibilitu
            uploadedImage = {
              base64: base64,
              mimeType: file.type,
              name: file.name,
              size: file.size,
            };

            showFilePreview(file, base64Full);
          };
          reader.readAsDataURL(file);
        } else if (isText || file.type === "application/pdf") {
          // Zpracuj jako text
          const reader = new FileReader();
          reader.onload = (e) => {
            uploadedFile = {
              base64: null,
              mimeType: file.type,
              name: file.name,
              size: file.size,
              type: "text",
              content: e.target.result,
            };

            showFilePreview(file, null);
          };
          reader.readAsText(file);
        } else {
          alert(
            "Nepodporovan√Ω typ souboru. Podporovan√©: obr√°zky, TXT, MD, JSON, CSV"
          );
          return;
        }
      }

      function showFilePreview(file, dataUrl) {
        const bar = document.getElementById("filePreviewBar");
        const thumb = document.getElementById("previewThumb");
        const icon = document.getElementById("fileIcon");
        const name = document.getElementById("fileName");

        if (!bar) return;

        bar.style.display = "flex";

        const sizeKB = (file.size / 1024).toFixed(1);
        name.textContent = `${file.name} (${sizeKB} KB)`;

        if (dataUrl && file.type.startsWith("image/")) {
          thumb.src = dataUrl;
          thumb.style.display = "block";
          icon.style.display = "none";
        } else {
          thumb.style.display = "none";
          icon.style.display = "inline";

          // Ikona podle typu
          if (file.name.endsWith(".pdf")) icon.textContent = "üìï";
          else if (file.name.endsWith(".json")) icon.textContent = "üìã";
          else if (file.name.endsWith(".csv")) icon.textContent = "üìä";
          else if (file.name.endsWith(".md")) icon.textContent = "üìù";
          else icon.textContent = "üìÑ";
        }
      }

      function removeFile() {
        uploadedFile = {
          base64: null,
          mimeType: null,
          name: null,
          size: null,
          type: null,
          content: null,
        };

        uploadedImage = {
          base64: null,
          mimeType: null,
          name: null,
          size: null,
        };

        const bar = document.getElementById("filePreviewBar");
        const input = document.getElementById("fileInput");

        if (bar) bar.style.display = "none";
        if (input) input.value = "";
      }

      // ============================================================
      // TESTOV√ÅN√ç MODEL≈Æ
      // ============================================================

      let testResults = [];

      async function testAllModels() {
        const modal = document.getElementById("testModal");
        const summaryEl = document.getElementById("testSummary");
        const resultsEl = document.getElementById("testResults");

        if (!modal || !summaryEl || !resultsEl) return;

        // Zobrazit modal
        modal.style.display = "flex";

        // Reset
        testResults = [];
        summaryEl.innerHTML = `
        <div class="summary-card">
            <div class="testing-indicator">
                <div class="spinner"></div>
                Testov√°n√≠ prob√≠h√°...
            </div>
        </div>
    `;
        resultsEl.innerHTML = "";

        const providers = [
          "gemini",
          "groq",
          "openrouter",
          "mistral",
          "cohere",
          "huggingface",
        ];
        const providerEmojis = {
          gemini: "ü§ñ",
          groq: "‚ö°",
          openrouter: "üåê",
          mistral: "üî•",
          cohere: "üß†",
          huggingface: "ü§ó",
        };

        const testPrompt = "Odpovƒõz pouze ƒç√≠slem: 6 * 7 = ?";

        // Testovat ka≈æd√©ho providera
        for (const provider of providers) {
          const models = AI.getModels(provider);
          const key = AI.getKey(provider);

          if (!key) continue;

          // Vytvo≈ôit sekci pro providera
          const sectionId = `section-${provider}`;
          resultsEl.innerHTML += `
            <div class="provider-section" id="${sectionId}">
                <div class="provider-header">
                    <h3>${providerEmojis[provider]} ${
            provider.charAt(0).toUpperCase() + provider.slice(1)
          }</h3>
                    <span class="provider-stats" id="stats-${provider}">Testov√°n√≠...</span>
                </div>
                <div id="models-${provider}"></div>
            </div>
        `;

          const modelsContainer = document.getElementById(`models-${provider}`);
          let providerSuccess = 0;
          let providerError = 0;

          // Testovat ka≈æd√Ω model
          for (const model of models) {
            const startTime = performance.now();
            let result = {
              provider,
              model: model.value,
              name: model.name,
              success: false,
              time: 0,
              response: "",
              error: "",
            };

            try {
              const response = await AI.ask(testPrompt, {
                provider,
                model: model.value,
                maxTokens: 50,
              });

              result.success = true;
              result.time = Math.round(performance.now() - startTime);
              result.response = response.trim().substring(0, 50);
              providerSuccess++;
            } catch (error) {
              result.success = false;
              result.time = Math.round(performance.now() - startTime);
              result.error = parseErrorMessage(error.message);
              providerError++;
            }

            testResults.push(result);

            // Zobrazit v√Ωsledek modelu
            if (modelsContainer) {
              modelsContainer.innerHTML += createModelResultHTML(result);
            }

            // Aktualizovat statistiky providera
            const statsEl = document.getElementById(`stats-${provider}`);
            if (statsEl) {
              statsEl.innerHTML = `‚úÖ ${providerSuccess} / ‚ùå ${providerError}`;
            }
          }
        }

        // Zobrazit souhrn
        updateTestSummary();
      }

      function parseErrorMessage(msg) {
        if (
          msg.includes("429") ||
          msg.includes("quota") ||
          msg.includes("RESOURCE_EXHAUSTED")
        ) {
          return "üìä P≈ôekroƒçena kv√≥ta API. Model nen√≠ dostupn√Ω v bezplatn√© verzi nebo je vyƒçerp√°n denn√≠ limit.";
        }
        if (msg.includes("404") || msg.includes("not found")) {
          return "‚ùì Model nebyl nalezen. Mo≈æn√° byl odstranƒõn nebo p≈ôejmenov√°n.";
        }
        if (
          msg.includes("401") ||
          msg.includes("unauthorized") ||
          msg.includes("invalid") ||
          msg.includes("User not found")
        ) {
          return "üîë Neplatn√Ω API kl√≠ƒç. Demo kl√≠ƒç expiroval - pot≈ôebuje≈° vlastn√≠ kl√≠ƒç.";
        }
        if (msg.includes("timeout") || msg.includes("Timeout")) {
          return "‚è±Ô∏è Vypr≈°el ƒçasov√Ω limit po≈æadavku.";
        }
        return msg.substring(0, 100);
      }

      function createModelResultHTML(result) {
        const statusClass = result.success ? "success" : "error";
        const statusText = result.success ? "‚úÖ Funguje" : "‚ùå Chyba";

        let detailsHTML = "";
        if (result.success) {
          detailsHTML = `‚ö° ${result.time}ms üí¨ "${result.response}"`;
        }

        let errorHTML = "";
        if (!result.success && result.error) {
          errorHTML = `<div class="error-msg">‚ö†Ô∏è ${result.error}</div>`;
        }

        return `
        <div class="model-result ${statusClass}">
            <div>
                <div class="model-name">${result.name
                  .replace(/[‚ö°üß†üí¨üíªüëÅÔ∏èü§ñü¶ôüî•]/g, "")
                  .trim()}</div>
                <div class="model-id">${result.model}</div>
            </div>
            <div class="result-info">
                <div class="result-status ${statusClass}">${statusText}</div>
                <div class="result-details">${detailsHTML}</div>
            </div>
            ${errorHTML}
        </div>
    `;
      }

      function updateTestSummary() {
        const summaryEl = document.getElementById("testSummary");
        if (!summaryEl) return;

        const successCount = testResults.filter((r) => r.success).length;
        const errorCount = testResults.filter((r) => !r.success).length;
        const avgTime =
          testResults.filter((r) => r.success).length > 0
            ? Math.round(
                testResults
                  .filter((r) => r.success)
                  .reduce((sum, r) => sum + r.time, 0) / successCount
              )
            : 0;

        summaryEl.innerHTML = `
        <div class="summary-card">
            <div class="value">${testResults.length}</div>
            <div class="label">üìä Celkem test≈Ø</div>
        </div>
        <div class="summary-card success">
            <div class="value">${successCount}</div>
            <div class="label">‚úÖ Funguje</div>
        </div>
        <div class="summary-card error">
            <div class="value">${errorCount}</div>
            <div class="label">‚ùå Chyba</div>
        </div>
        <div class="summary-card speed">
            <div class="value">${avgTime}ms</div>
            <div class="label">‚ö° Pr≈Ømƒõrn√° odezva</div>
        </div>
    `;
      }

      function closeTestModal() {
        const modal = document.getElementById("testModal");
        if (modal) modal.style.display = "none";
      }

      // Pomocn√° funkce pro kop√≠rov√°n√≠ do schr√°nky (s fallback)
      function copyToClipboard(text) {
        return new Promise((resolve) => {
          // Pokus 1: Fallback pomoc√≠ textarea (funguje v≈ædy)
          const textarea = document.createElement("textarea");
          textarea.value = text;
          textarea.style.cssText =
            "position:fixed;left:-9999px;top:-9999px;opacity:0";
          document.body.appendChild(textarea);
          textarea.focus();
          textarea.select();
          textarea.setSelectionRange(0, 99999); // Pro mobiln√≠ za≈ô√≠zen√≠

          try {
            const success = document.execCommand("copy");
            document.body.removeChild(textarea);
            if (success) {
              resolve(true);
              return;
            }
          } catch (err) {
            document.body.removeChild(textarea);
          }

          // Pokus 2: Modern Clipboard API
          if (navigator.clipboard && window.isSecureContext) {
            navigator.clipboard
              .writeText(text)
              .then(() => resolve(true))
              .catch(() => resolve(false));
          } else {
            resolve(false);
          }
        });
      }

      function copyTestReport() {
        let report = "üß™ V√ùSLEDKY TESTOV√ÅN√ç AI MODEL≈Æ\n";
        report += "================================\n\n";

        const successCount = testResults.filter((r) => r.success).length;
        const errorCount = testResults.filter((r) => !r.success).length;
        const avgTime =
          successCount > 0
            ? Math.round(
                testResults
                  .filter((r) => r.success)
                  .reduce((sum, r) => sum + r.time, 0) / successCount
              )
            : 0;

        report += `üìä Souhrn: ‚úÖ ${successCount} funguje | ‚ùå ${errorCount} chyb | ‚ö° ${avgTime}ms pr≈Ømƒõr\n\n`;

        const providers = [...new Set(testResults.map((r) => r.provider))];

        for (const provider of providers) {
          const providerResults = testResults.filter(
            (r) => r.provider === provider
          );
          const pSuccess = providerResults.filter((r) => r.success).length;
          const pError = providerResults.filter((r) => !r.success).length;

          report += `${provider.toUpperCase()} (‚úÖ ${pSuccess} / ‚ùå ${pError})\n`;
          report += "-".repeat(30) + "\n";

          for (const r of providerResults) {
            if (r.success) {
              report += `‚úÖ ${r.model} - ${r.time}ms - "${r.response}"\n`;
            } else {
              report += `‚ùå ${r.model} - ${r.error}\n`;
            }
          }
          report += "\n";
        }

        copyToClipboard(report).then((success) => {
          if (success) {
            alert("üìã Report zkop√≠rov√°n do schr√°nky!");
          } else {
            // Zobrazit v nov√©m oknƒõ pro ruƒçn√≠ kop√≠rov√°n√≠
            const win = window.open("", "_blank", "width=600,height=400");
            win.document.write(
              '<pre class="mono-pre">' + report.replace(/</g, "&lt;") + "</pre>"
            );
            win.document.title = "AI Test Report - zkop√≠ruj ruƒçnƒõ";
            alert(
              "Schr√°nka nen√≠ dostupn√°. Report otev≈ôen v nov√©m oknƒõ - zkop√≠ruj ruƒçnƒõ (Ctrl+A, Ctrl+C)."
            );
          }
        });
      }

      // ============================================================
      // ZJI≈†TƒöN√ç DOSTUPN√ùCH MODEL≈Æ Z API
      // ============================================================

      let fetchedModels = {
        gemini: [],
        groq: [],
        openrouter: [],
        mistral: [],
        cohere: [],
        huggingface: [],
      };

      async function fetchAvailableModels() {
        const modal = document.getElementById("modelsModal");
        const summaryEl = document.getElementById("modelsSummary");
        const resultsEl = document.getElementById("modelsResults");

        if (!modal) return;

        modal.style.display = "flex";

        summaryEl.innerHTML = `
        <div class="summary-card">
            <div class="testing-indicator">
                <div class="spinner"></div>
                Naƒç√≠t√°m modely z API...
            </div>
        </div>
    `;
        resultsEl.innerHTML = "";

        // Reset
        fetchedModels = {
          gemini: [],
          groq: [],
          openrouter: [],
          mistral: [],
          cohere: [],
          huggingface: [],
        };

        // Paralelnƒõ naƒç√≠st ze v≈°ech provider≈Ø
        const results = await Promise.allSettled([
          fetchGeminiModels(),
          fetchGroqModels(),
          fetchOpenRouterModels(),
          fetchMistralModels(),
          fetchCohereModels(),
          fetchHuggingFaceModels(),
        ]);

        // Zobrazit v√Ωsledky
        renderModelsResults();
      }

      async function fetchGeminiModels() {
        const key = AI.getKey("gemini");
        if (!key) return;

        try {
          const response = await fetch(
            `https://generativelanguage.googleapis.com/v1beta/models?key=${key}`
          );
          if (!response.ok) throw new Error("API error");

          const data = await response.json();

          fetchedModels.gemini = (data.models || [])
            .filter(
              (m) =>
                m.name.includes("gemini") &&
                m.supportedGenerationMethods?.includes("generateContent")
            )
            .map((m) => ({
              id: m.name.replace("models/", ""),
              name: m.displayName || m.name,
              context: m.inputTokenLimit || 0,
              free: true, // Gemini m√° free tier
              description: m.description || "",
            }));
        } catch (e) {
          console.warn("Gemini models fetch failed:", e);
        }
      }

      async function fetchGroqModels() {
        const key = AI.getKey("groq");
        if (!key) return;

        try {
          const response = await fetch(
            "https://api.groq.com/openai/v1/models",
            {
              headers: { Authorization: `Bearer ${key}` },
            }
          );
          if (!response.ok) throw new Error("API error");

          const data = await response.json();

          fetchedModels.groq = (data.data || []).map((m) => ({
            id: m.id,
            name: m.id,
            context: m.context_window || 0,
            free: true, // Groq je free
            owned_by: m.owned_by || "",
          }));
        } catch (e) {
          console.warn("Groq models fetch failed:", e);
        }
      }

      async function fetchOpenRouterModels() {
        const key = AI.getKey("openrouter");
        if (!key) return;

        try {
          const response = await fetch("https://openrouter.ai/api/v1/models", {
            headers: { Authorization: `Bearer ${key}` },
          });
          if (!response.ok) throw new Error("API error");

          const data = await response.json();

          // Filtrovat pouze free modely (pricing.prompt === "0" nebo obsahuje :free)
          fetchedModels.openrouter = (data.data || [])
            .filter((m) => m.pricing?.prompt === "0" || m.id.includes(":free"))
            .map((m) => ({
              id: m.id,
              name: m.name || m.id,
              context: m.context_length || 0,
              free: true,
              pricing: m.pricing,
            }));

          console.info(
            `üåê OpenRouter: Nalezeno ${fetchedModels.openrouter.length} free model≈Ø`
          );
        } catch (e) {
          console.warn("OpenRouter models fetch failed:", e);
        }
      }

      async function fetchMistralModels() {
        const key = AI.getKey("mistral");
        if (!key) return;

        try {
          const response = await fetch("https://api.mistral.ai/v1/models", {
            headers: { Authorization: `Bearer ${key}` },
          });
          if (!response.ok) throw new Error("API error");

          const data = await response.json();

          fetchedModels.mistral = (data.data || []).map((m) => ({
            id: m.id,
            name: m.id,
            context: m.max_context_length || 0,
            free: false, // Mistral je placen√Ω (ale m√° free tier s limity)
          }));
        } catch (e) {
          console.warn("Mistral models fetch failed:", e);
        }
      }

      async function fetchCohereModels() {
        const key = AI.getKey("cohere");
        if (!key) return;

        try {
          const response = await fetch("https://api.cohere.com/v1/models", {
            headers: { Authorization: `Bearer ${key}` },
          });
          if (!response.ok) throw new Error("API error");

          const data = await response.json();

          fetchedModels.cohere = (data.models || [])
            .filter((m) => m.endpoints?.includes("chat"))
            .map((m) => ({
              id: m.name,
              name: m.name,
              context: m.context_length || 0,
              free: true, // Cohere m√° free tier
            }));
        } catch (e) {
          console.warn("Cohere models fetch failed:", e);
        }
      }

      async function fetchHuggingFaceModels() {
        const key = AI.getKey("huggingface");
        if (!key) return;

        // HuggingFace nem√° jednoduch√Ω endpoint pro seznam model≈Ø
        // Pou≈æijeme p≈ôedefinovan√Ω seznam popul√°rn√≠ch model≈Ø
        // a ovƒõ≈ô√≠me jejich dostupnost

        const popularModels = [
          "meta-llama/Llama-3.3-70B-Instruct",
          "meta-llama/Llama-3.1-70B-Instruct",
          "meta-llama/Llama-3.1-8B-Instruct",
          "Qwen/Qwen2.5-72B-Instruct",
          "Qwen/Qwen2.5-32B-Instruct",
          "mistralai/Mistral-7B-Instruct-v0.3",
          "mistralai/Mixtral-8x7B-Instruct-v0.1",
          "microsoft/Phi-3-mini-4k-instruct",
          "google/gemma-2-9b-it",
          "google/gemma-2-27b-it",
          "HuggingFaceH4/zephyr-7b-beta",
          "tiiuae/falcon-7b-instruct",
        ];

        fetchedModels.huggingface = popularModels.map((id) => ({
          id: id,
          name: id.split("/").pop(),
          context: 0,
          free: true, // HF Inference API je free (s limity)
        }));
      }

      function renderModelsResults() {
        const summaryEl = document.getElementById("modelsSummary");
        const resultsEl = document.getElementById("modelsResults");

        // Spoƒç√≠tat statistiky
        let totalFetched = 0;
        let totalFree = 0;
        let newModels = 0;
        let missingModels = 0;

        const providerEmojis = {
          gemini: "ü§ñ",
          groq: "‚ö°",
          openrouter: "üåê",
          mistral: "üî•",
          cohere: "üß†",
          huggingface: "ü§ó",
        };

        let html = "";

        for (const [provider, models] of Object.entries(fetchedModels)) {
          const localModels = AI.ALL_MODELS[provider] || [];
          const localIds = localModels.map((m) => m.value);

          // Naj√≠t nov√© modely (v API ale ne v lok√°ln√≠m seznamu)
          const newInApi = models.filter((m) => !localIds.includes(m.id));

          // Naj√≠t chybƒõj√≠c√≠ modely (v lok√°ln√≠m seznamu ale ne v API)
          const fetchedIds = models.map((m) => m.id);
          const missing = localModels.filter(
            (m) => !fetchedIds.includes(m.value)
          );

          totalFetched += models.length;
          totalFree += models.filter((m) => m.free).length;
          newModels += newInApi.length;
          missingModels += missing.length;

          html += `
            <div class="provider-section">
                <div class="provider-header">
                    <h3>${providerEmojis[provider]} ${
            provider.charAt(0).toUpperCase() + provider.slice(1)
          }</h3>
                    <span class="provider-stats">
                        üì¶ ${models.length} model≈Ø |
                        üÜï ${newInApi.length} nov√Ωch |
                        ${
                          missing.length > 0
                            ? `‚ö†Ô∏è ${missing.length} chyb√≠`
                            : "‚úÖ v≈°e OK"
                        }
                    </span>
                </div>
        `;

          // Zobrazit chybƒõj√≠c√≠ modely
          if (missing.length > 0) {
            html += `<div class="alert-error">
                <div class="font-size-12 color-error margin-bottom-8">‚ö†Ô∏è Tyto modely nejsou dostupn√© v API:</div>`;
            for (const m of missing) {
              html += `
                    <div class="model-card missing">
                        <div>
                            <div class="model-name">${m.name}</div>
                            <div class="model-id">${m.value}</div>
                        </div>
                        <div class="model-badges">
                            <span class="badge missing-badge">ODSTRANƒöN?</span>
                        </div>
                        <div></div>
                    </div>
                `;
            }
            html += "</div>";
          }

          // Zobrazit nov√© modely
          if (newInApi.length > 0) {
            html += `<div class="margin-bottom-12">
                <div class="font-size-12 text-accent-blue margin-bottom-8">üÜï Nov√© modely k dispozici:</div>`;
            for (const m of newInApi.slice(0, 20)) {
              // Max 20
              html += `
                    <div class="model-card new">
                        <div>
                            <div class="model-name">${m.name}</div>
                            <div class="model-id">${m.id}</div>
                        </div>
                        <div class="model-badges">
                            ${
                              m.free
                                ? '<span class="badge free">FREE</span>'
                                : '<span class="badge paid">PAID</span>'
                            }
                            <span class="badge new-badge">NOV√ù</span>
                        </div>
                        <div class="model-context">${formatContext(
                          m.context
                        )}</div>
                    </div>
                `;
            }
            if (newInApi.length > 20) {
              html += `<div class="info-muted">... a ${
                newInApi.length - 20
              } dal≈°√≠ch</div>`;
            }
            html += "</div>";
          }

          // Zobrazit aktu√°ln√≠ lok√°ln√≠ modely
          html += `<div class="font-size-12 color-muted margin-bottom-8">üìã Aktu√°ln√≠ lok√°ln√≠ konfigurace:</div>`;
          for (const m of localModels) {
            const inApi = fetchedIds.includes(m.value);
            const apiModel = models.find((am) => am.id === m.value);
            html += `
                <div class="model-card ${inApi ? "available" : "missing"}">
                    <div>
                        <div class="model-name">${m.name}</div>
                        <div class="model-id">${m.value}</div>
                    </div>
                    <div class="model-badges">
                        ${
                          inApi
                            ? '<span class="badge free">‚úÖ OK</span>'
                            : '<span class="badge missing-badge">‚ùå CHYB√ç</span>'
                        }
                        ${
                          AI.supportsVision(m.value)
                            ? '<span class="badge vision">üëÅÔ∏è VISION</span>'
                            : ""
                        }
                    </div>
                    <div class="model-context">${m.rpm} RPM</div>
                </div>
            `;
          }

          html += "</div>";
        }

        // Souhrn
        summaryEl.innerHTML = `
        <div class="summary-card">
            <div class="value">${totalFetched}</div>
            <div class="label">üì¶ Celkem v API</div>
        </div>
        <div class="summary-card success">
            <div class="value">${totalFree}</div>
            <div class="label">üÜì Free modely</div>
        </div>
        <div class="summary-card inl-39505f">
            <div class="value inl-8ffdae">${newModels}</div>
            <div class="label">üÜï Nov√©</div>
        </div>
        <div class="summary-card error">
            <div class="value">${missingModels}</div>
            <div class="label">‚ö†Ô∏è Chyb√≠</div>
        </div>
    `;

        resultsEl.innerHTML = html;
      }

      function formatContext(tokens) {
        if (!tokens) return "";
        if (tokens >= 1000000) return `${(tokens / 1000000).toFixed(1)}M ctx`;
        if (tokens >= 1000) return `${(tokens / 1000).toFixed(0)}K ctx`;
        return `${tokens} ctx`;
      }

      function closeModelsModal() {
        const modal = document.getElementById("modelsModal");
        if (modal) modal.style.display = "none";
      }

      function updateLocalModels() {
        // Tato funkce by mohla aktualizovat ALL_MODELS
        // Pro teƒè jen uk√°≈æeme alert s instrukcemi
        let code = "// Aktualizovan√© modely:\n\n";

        for (const [provider, models] of Object.entries(fetchedModels)) {
          if (models.length === 0) continue;

          const freeModels = models.filter((m) => m.free).slice(0, 10);

          code += `${provider}: [\n`;
          for (const m of freeModels) {
            code += `    { value: "${m.id}", name: "${m.name}", rpm: 30 },\n`;
          }
          code += `],\n\n`;
        }

        copyToClipboard(code).then((success) => {
          if (success) {
            alert(
              "üìã K√≥d pro aktualizaci model≈Ø zkop√≠rov√°n do schr√°nky!\n\nVlo≈æ ho do ALL_MODELS v k√≥du."
            );
          } else {
            const win = window.open("", "_blank", "width=600,height=400");
            win.document.write(
              '<pre class="mono-pre">' + code.replace(/</g, "&lt;") + "</pre>"
            );
            win.document.title = "Models Code";
            alert("K√≥d otev≈ôen v nov√©m oknƒõ - zkop√≠ruj ruƒçnƒõ.");
          }
        });
      }

      function copyModelsReport() {
        let report = "üîç DOSTUPN√â AI MODELY\n";
        report += "======================\n\n";

        for (const [provider, models] of Object.entries(fetchedModels)) {
          const localModels = AI.ALL_MODELS[provider] || [];
          const localIds = localModels.map((m) => m.value);
          const fetchedIds = models.map((m) => m.id);

          const newInApi = models.filter((m) => !localIds.includes(m.id));
          const missing = localModels.filter(
            (m) => !fetchedIds.includes(m.value)
          );

          report += `${provider.toUpperCase()} (${models.length} model≈Ø)\n`;
          report += "-".repeat(40) + "\n";

          if (missing.length > 0) {
            report += `‚ö†Ô∏è CHYBƒöJ√çC√ç: ${missing
              .map((m) => m.value)
              .join(", ")}\n`;
          }

          if (newInApi.length > 0) {
            report += `üÜï NOV√â FREE:\n`;
            for (const m of newInApi.filter((m) => m.free).slice(0, 10)) {
              report += `   ${m.id}\n`;
            }
          }

          report += "\n";
        }

        copyToClipboard(report).then((success) => {
          if (success) {
            alert("üìã Report zkop√≠rov√°n!");
          } else {
            const win = window.open("", "_blank", "width=600,height=400");
            win.document.write(
              '<pre class="mono-pre">' + report.replace(/</g, "&lt;") + "</pre>"
            );
            win.document.title = "Models Report";
          }
        });
      }
    </script>
  </body>
</html>
