<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Generátor CAM pro Sinumerik 840D (Auto-Trim) - Fixed v11</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel Standalone -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- jsPDF pro generování PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <!-- Gemini SDK Import Map -->
    <script type="importmap">
    {
      "imports": {
        "@google/genai": "https://esm.run/@google/genai"
      }
    }
    </script>

    <style>
        body { overscroll-behavior: none; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #9ca3af; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        .canvas-container { cursor: crosshair; touch-action: none; background-image: radial-gradient(#ccc 1px, transparent 1px); background-size: 20px 20px; }
        .dark .canvas-container { background-image: radial-gradient(#333 1px, transparent 1px); }
        .safe-pb { padding-bottom: env(safe-area-inset-bottom); }
        /* Styl pro aktivní řádek kódu */
        .code-line.active { background-color: rgba(59, 130, 246, 0.2); font-weight: bold; border-left: 3px solid #3b82f6; }
        .dark .code-line.active { background-color: rgba(59, 130, 246, 0.3); border-left: 3px solid #60a5fa; }
    </style>
</head>
<body class="h-[100dvh] w-screen overflow-hidden flex flex-col font-sans transition-colors duration-300">

    <div id="root" class="h-full w-full"></div>

    <script type="text/babel" data-type="module">
        import { GoogleGenAI } from "@google/genai";
        
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        // --- ICONS ---
        const IconTrash = () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;
        const IconPlus = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>;
        const IconSun = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>;
        const IconMoon = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>;
        const IconEdit = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path></svg>;
        const IconBox = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>;
        const IconMagic = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><path d="m12 2 2.5 5.5L20 9l-4 3.5L17.5 18 12 15l-5.5 3L8 12.5 4 9l5.5-1.5L12 2z"></path></svg>;
        const IconClipboard = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>;
        const IconInsert = () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>;
        const IconTarget = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line></svg>;
        const IconEye = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>;
        const IconPlay = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M5 3l14 9-14 9V3z"/></svg>;
        const IconPause = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>;
        const IconStop = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="6" y="6" width="12" height="12" /></svg>;
        const IconDownload = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>;
        const IconArrowRight = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>;
        const IconArrowDown = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline></svg>;
        const IconWarning = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ef4444" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>;
        const IconInfo = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>;
        const IconRefresh = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>;
        const IconRotate = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.3"/></svg>;
        const IconUndo = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 7v6h6"></path><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"></path></svg>;
        const IconRedo = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 7v6h-6"></path><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3L21 13"></path></svg>;
        const IconFileText = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>;
        const IconPlusCircle = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>;
        const IconSpark = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z"/><path d="M20 3v4"/><path d="M22 5h-4"/><path d="M4 17v2"/><path d="M5 18H3"/></svg>;
        const IconVoiceChat = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/><line x1="9" y1="10" x2="15" y2="10"/><line x1="12" y1="7" x2="12" y2="13"/></svg>;
        
        // NEW ICONS FOR FEATURES
        const IconDocumentScanner = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 7V5a2 2 0 0 1 2-2h2"/><path d="M17 3h2a2 2 0 0 1 2 2v2"/><path d="M21 17v2a2 2 0 0 1-2 2h-2"/><path d="M7 21H5a2 2 0 0 1-2-2v-2"/><rect x="7" y="7" width="10" height="10" rx="1"/></svg>;
        const IconBolt = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M11 21l-1-11H4l11-10 1 11h6L11 21z"/></svg>;
        const IconNetworkIntelligence = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="2" y="2" width="20" height="8" rx="2" ry="2"></rect><rect x="2" y="14" width="20" height="8" rx="2" ry="2"></rect><line x1="6" y1="6" x2="6.01" y2="6"></line><line x1="6" y1="18" x2="6.01" y2="18"></line></svg>;
        const IconX = () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;


        // Shape Icons for Buttons
        const IconShapeCircle = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none"><circle cx="12" cy="12" r="10"/></svg>;
        const IconShapePolygon = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M3 3h18v18H3z"/></svg>;

        // --- COMPONENTS ---
        
        const SmartInput = ({ value, onValueChange, className, placeholder, type = "text", step }) => {
            const [localVal, setLocalVal] = useState(value);
            const [isDirty, setIsDirty] = useState(false);

            useEffect(() => { setLocalVal(value); }, [value]);

            useEffect(() => {
                if (!isDirty) return;
                const handler = setTimeout(() => { onValueChange(localVal); setIsDirty(false); }, 600); 
                return () => clearTimeout(handler);
            }, [localVal, isDirty, onValueChange]);

            const handleChange = (e) => { setLocalVal(e.target.value); setIsDirty(true); };
            const handleBlur = () => { if (isDirty) { onValueChange(localVal); setIsDirty(false); } };
            const handleKeyDown = (e) => { if (e.key === 'Enter') { if (isDirty) { onValueChange(localVal); setIsDirty(false); } e.target.blur(); } };

            return (
                <input type={type} className={className} placeholder={placeholder} value={localVal} onChange={handleChange} onBlur={handleBlur} onKeyDown={handleKeyDown} step={step} />
            );
        };
        
        const AiAssistant = ({ contourPoints, stockPoints, params, onUpdateContour, theme }) => {
            const [messages, setMessages] = useState([
                { role: 'model', text: 'Dobrý den, jsem váš AI asistent pro CNC programování. S čím vám mohu pomoci?' }
            ]);
            const [input, setInput] = useState('');
            const [loading, setLoading] = useState(false);
            const [mode, setMode] = useState('normal'); // 'normal', 'fast', 'thinking'
            const [image, setImage] = useState(null); // base64 string
            const scrollRef = useRef(null);
            const fileInputRef = useRef(null);

            useEffect(() => {
                if(scrollRef.current) scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
            }, [messages]);

            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        setImage(reader.result);
                    };
                    reader.readAsDataURL(file);
                }
            };

            const removeImage = () => {
                setImage(null);
                if (fileInputRef.current) fileInputRef.current.value = '';
            };

            const handleSend = async () => {
                if (!input.trim() && !image) return;
                const userMsg = { role: 'user', text: input, image: image };
                setMessages(prev => [...prev, userMsg]);
                setInput('');
                setImage(null);
                if (fileInputRef.current) fileInputRef.current.value = '';
                setLoading(true);

                try {
                    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
                    
                    const systemContext = `
                        Current CNC Configuration:
                        - Machine: ${params.machineType} (${params.machineStructure})
                        - Control: ${params.controlSystem}
                        - Current Contour Points: ${JSON.stringify(contourPoints)}
                    `;

                    const systemInstruction = `You are an expert CNC programmer and conversational assistant. Help user with Sinumerik 840D, Fanuc, and Heidenhain programming.
                    If the user requests to generate or modify the contour/geometry, you MUST output the new points in strictly this JSON format inside the text:
                    [{"type": "G0"|"G1"|"G2"|"G3", "x": number, "z": number, "r": number, "mode": "ABS"|"INC"}]
                    If explaining, use Czech language. Be helpful, concise, and professional.
                    Current context is provided in every turn.
                    `;

                    // MODEL SELECTION LOGIC
                    let modelName = "gemini-3-pro-preview"; // Default standard
                    let requestConfig = {
                        systemInstruction: { parts: [{ text: systemInstruction }] }
                    };

                    // 1. FAST MODE (Flash-Lite)
                    if (mode === 'fast' && !userMsg.image) {
                        modelName = "gemini-2.5-flash-lite-latest";
                    } 
                    // 2. THINKING MODE (Pro + Thinking)
                    else if (mode === 'thinking') {
                        modelName = "gemini-3-pro-preview";
                        requestConfig.thinkingConfig = { thinkingBudget: 32768 };
                    }
                    
                    // 3. IMAGE UPLOAD (MUST use Pro)
                    if (userMsg.image) {
                        modelName = "gemini-3-pro-preview";
                        // If thinking was NOT selected, standard Pro. If thinking WAS selected, we keep thinking config.
                    }

                    // Construct history
                    const history = messages.map(m => {
                        const parts = [];
                        if (m.image) {
                             // This is history, we don't resend image bytes usually in history for stateless unless needed, 
                             // but for this simple implementation we might skip or try to include.
                             // For simplicity and token saving, we might just include text for history or placeholder.
                             parts.push({ text: "[User uploaded an image]" });
                        }
                        if (m.text) parts.push({ text: m.text });
                        return { role: m.role, parts };
                    });

                    // Construct Current Message Parts
                    const currentParts = [];
                    if (userMsg.image) {
                        const base64Data = userMsg.image.split(',')[1];
                        const mimeType = userMsg.image.split(';')[0].split(':')[1];
                        currentParts.push({ inlineData: { mimeType, data: base64Data } });
                    }
                    currentParts.push({ text: systemContext + "\n\nUser Request: " + userMsg.text });

                    const contents = [
                        ...history,
                        { role: 'user', parts: currentParts }
                    ];

                    const result = await ai.models.generateContent({
                        model: modelName,
                        contents: contents,
                        config: requestConfig
                    });
                    
                    const text = result.text;
                    
                    // Try to parse JSON from response
                    let suggestedPoints = null;
                    try {
                        const jsonMatch = text.match(/\[\s*\{.*\}\s*\]/s);
                        if (jsonMatch) {
                            suggestedPoints = JSON.parse(jsonMatch[0]);
                        }
                    } catch (e) {
                        suggestedPoints = null;
                    }

                    setMessages(prev => [...prev, { role: 'model', text: text, suggestedPoints }]);

                } catch (error) {
                    setMessages(prev => [...prev, { role: 'model', text: "Chyba při komunikaci s AI: " + error.message + ". Ujistěte se, že máte nastaven API klíč." }]);
                }
                setLoading(false);
            };

            return (
                <div className="flex flex-col h-full">
                    {/* Chat Messages Area */}
                    <div ref={scrollRef} className={`flex-1 overflow-y-auto p-4 space-y-4 ${theme === 'dark' ? 'bg-gray-800' : 'bg-gray-50'}`}>
                        {messages.map((msg, idx) => (
                            <div key={idx} className={`flex flex-col ${msg.role === 'user' ? 'items-end' : 'items-start'}`}>
                                <div className={`max-w-[85%] rounded-lg p-3 text-sm whitespace-pre-wrap ${
                                    msg.role === 'user' 
                                        ? (theme === 'dark' ? 'bg-blue-700 text-white' : 'bg-blue-600 text-white')
                                        : (theme === 'dark' ? 'bg-gray-700 text-gray-200' : 'bg-white border text-gray-800 shadow-sm')
                                }`}>
                                    {msg.image && (
                                        <div className="mb-2">
                                            <img src={msg.image} alt="Upload" className="max-w-full h-auto rounded border" style={{maxHeight: '150px'}} />
                                        </div>
                                    )}
                                    {msg.text}
                                </div>
                                {msg.suggestedPoints && (
                                    <button 
                                        onClick={() => onUpdateContour(msg.suggestedPoints)}
                                        className="mt-2 text-xs bg-green-600 hover:bg-green-500 text-white py-1.5 px-3 rounded flex items-center gap-1 shadow-sm"
                                    >
                                        <IconPlusCircle /> Aplikovat tuto konturu
                                    </button>
                                )}
                            </div>
                        ))}
                        {loading && (
                            <div className="flex items-start">
                                <div className={`max-w-[85%] rounded-lg p-3 text-sm ${theme === 'dark' ? 'bg-gray-700' : 'bg-white border shadow-sm'}`}>
                                    <div className="flex gap-1">
                                        <span className="animate-bounce">●</span>
                                        <span className="animate-bounce delay-100">●</span>
                                        <span className="animate-bounce delay-200">●</span>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                    
                    {/* Input Area with Toolbar */}
                    <div className={`p-3 border-t flex flex-col gap-2 ${theme === 'dark' ? 'bg-gray-900 border-gray-700' : 'bg-white border-gray-200'}`}>
                        
                        {/* Toolbar */}
                        <div className="flex items-center gap-2">
                            <input 
                                type="file" 
                                accept="image/*" 
                                ref={fileInputRef} 
                                onChange={handleFileChange} 
                                className="hidden" 
                            />
                            <button 
                                onClick={() => fileInputRef.current?.click()}
                                className={`p-1.5 rounded transition-colors ${image ? 'bg-blue-100 text-blue-600' : 'text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-800 dark:text-gray-400'}`}
                                title="Nahrát obrázek (výkres)"
                            >
                                <IconDocumentScanner />
                            </button>
                            
                            <div className="h-4 w-px bg-gray-300 dark:bg-gray-700 mx-1"></div>
                            
                            <button 
                                onClick={() => setMode(mode === 'fast' ? 'normal' : 'fast')}
                                className={`flex items-center gap-1 px-2 py-1 rounded text-xs font-bold transition-colors ${mode === 'fast' ? 'bg-yellow-100 text-yellow-700 border border-yellow-200' : 'text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-800'}`}
                                title="Rychlá odpověď (Flash-Lite)"
                            >
                                <IconBolt /> {mode === 'fast' && 'Fast'}
                            </button>
                            
                            <button 
                                onClick={() => setMode(mode === 'thinking' ? 'normal' : 'thinking')}
                                className={`flex items-center gap-1 px-2 py-1 rounded text-xs font-bold transition-colors ${mode === 'thinking' ? 'bg-purple-100 text-purple-700 border border-purple-200' : 'text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-800'}`}
                                title="Thinking Mode (Reasoning)"
                            >
                                <IconNetworkIntelligence /> {mode === 'thinking' && 'Thinking'}
                            </button>
                        </div>

                        {/* Image Preview */}
                        {image && (
                            <div className="relative inline-block w-fit">
                                <img src={image} alt="Preview" className="h-16 rounded border shadow-sm" />
                                <button 
                                    onClick={removeImage}
                                    className="absolute -top-1 -right-1 bg-red-500 text-white rounded-full p-0.5 shadow hover:bg-red-600"
                                >
                                    <IconX />
                                </button>
                            </div>
                        )}

                        {/* Text Input */}
                        <div className="flex gap-2">
                            <textarea 
                                value={input}
                                onChange={(e) => setInput(e.target.value)}
                                onKeyDown={(e) => { if(e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend(); } }}
                                placeholder={image ? "Popište tento výkres..." : "Zeptejte se na G-kód..."}
                                className={`flex-1 border rounded-lg p-2 text-sm resize-none h-12 focus:outline-none focus:ring-2 focus:ring-blue-500 ${theme === 'dark' ? 'bg-gray-800 border-gray-600 text-white' : 'bg-gray-50 border-gray-300 text-gray-900'}`}
                            />
                            <button onClick={handleSend} disabled={loading || (!input.trim() && !image)} className={`px-4 rounded-lg font-bold flex items-center justify-center transition-colors ${loading || (!input.trim() && !image) ? 'bg-gray-400 cursor-not-allowed' : 'bg-indigo-600 hover:bg-indigo-500 text-white'}`}>
                                <IconSpark />
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // --- MATH HELPERS ---
        const dist = (p1, p2) => {
            if(!p1 || !p2) return 0;
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.z - p1.z, 2));
        }

        const getNormal = (p1, p2) => {
            if (!p1 || !p2) return {x:0, z:0};
            const dx = p2.x - p1.x; const dz = p2.z - p1.z; const l = Math.sqrt(dx*dx + dz*dz);
            if (l===0 || isNaN(l)) return {x:0, z:0}; return { x: -dz/l, z: dx/l };
        };

        const intersectLines = (p1, p2, p3, p4) => {
            if (!p1 || !p2 || !p3 || !p4) return null;
            if (isNaN(p1.x) || isNaN(p1.z) || isNaN(p2.x) || isNaN(p2.z) || 
                isNaN(p3.x) || isNaN(p3.z) || isNaN(p4.x) || isNaN(p4.z)) return null;

            const d = (p1.x - p2.x) * (p3.z - p4.z) - (p1.z - p2.z) * (p3.x - p4.x);
            if (Math.abs(d) < 1e-9 || isNaN(d)) return null; 
            const t = ((p1.x - p3.x) * (p3.z - p4.z) - (p1.z - p3.z) * (p3.x - p4.x)) / d;
            
            const ix = p1.x + t * (p2.x - p1.x);
            const iz = p1.z + t * (p2.z - p1.z);
            if (isNaN(ix) || isNaN(iz)) return null;
            return { x: ix, z: iz };
        };

        const intersectLinesInfinite = (p1, p2, p3, p4) => {
            if (!p1 || !p2 || !p3 || !p4) return null;
            if (isNaN(p1.x) || isNaN(p1.z) || isNaN(p2.x) || isNaN(p2.z) || 
                isNaN(p3.x) || isNaN(p3.z) || isNaN(p4.x) || isNaN(p4.z)) return null;

            const d = (p1.x - p2.x) * (p3.z - p4.z) - (p1.z - p2.z) * (p3.x - p4.x);
            if (Math.abs(d) < 1e-9 || isNaN(d)) return null; 
            const t = ((p1.x - p3.x) * (p3.z - p4.z) - (p1.z - p3.z) * (p3.x - p4.x)) / d;
            const px = p1.x + t * (p2.x - p1.x);
            const pz = p1.z + t * (p2.z - p1.z);
            if(isNaN(px) || isNaN(pz)) return null;
            return { x: px, z: pz };
        };

        const intersectLineCircle = (p1, p2, center, r) => {
            if (!p1 || !p2 || !center) return null;
            const dx = p2.x - p1.x; const dz = p2.z - p1.z; const fx = p1.x - center.x; const fz = p1.z - center.z;
            const a = dx*dx + dz*dz; const b = 2*(fx*dx + fz*dz); const c = (fx*fx + fz*fz) - r*r;
            let discriminant = b*b - 4*a*c; if (discriminant < 0) return null;
            discriminant = Math.sqrt(discriminant);
            const t1 = (-b - discriminant) / (2*a); const t2 = (-b + discriminant) / (2*a);
            return [{ x: p1.x + t1*dx, z: p1.z + t1*dz }, { x: p1.x + t2*dx, z: p1.z + t2*dz }];
        };

        const getArcParams = (p1, p2, r, type) => {
            if (!p1 || !p2) return { error: true, cx: 0, cz: 0, r: 0 };
            const d2 = Math.pow(p2.x - p1.x, 2) + Math.pow(p2.z - p1.z, 2); const d = Math.sqrt(d2);
            const isLongArc = r < 0; const absR = Math.abs(r); let safeR = absR; let error = false;
            if (d2 === 0) return { error: true, cx: p1.x, cz: p1.z, r: 0 };
            if (absR < d/2 - 0.001) { error = true; safeR = d/2 + 0.001; }
            const mx = (p1.x + p2.x) / 2; const mz = (p1.z + p2.z) / 2;
            const h = Math.sqrt(Math.max(0, safeR*safeR - d2/4));
            const dx = p2.x - p1.x; const dz = p2.z - p1.z;
            const ox = -dz / d; const oz = dx / d;
            let sign = (type === 'G3') ? -1 : 1; if (isLongArc) sign *= -1;
            const cx = mx + sign * h * ox; const cz = mz + sign * h * oz;
            if(isNaN(cx) || isNaN(cz)) return { error: true, cx: 0, cz: 0, r: 0 };
            return { cx, cz, r: safeR, error };
        };

        const isAngleBetween = (target, start, end, isG2) => {
            if (isNaN(target) || isNaN(start) || isNaN(end)) return false;
            const t = (target % (2*Math.PI) + 2*Math.PI) % (2*Math.PI);
            const s = (start % (2*Math.PI) + 2*Math.PI) % (2*Math.PI);
            const e = (end % (2*Math.PI) + 2*Math.PI) % (2*Math.PI);
            if (isG2) { if (s >= e) return t <= s && t >= e; return t <= s || t >= e; } else { if (e >= s) return t >= s && t <= e; return t >= s || t <= e; }
        };

        const intersectHorizontalLineSegment = (xLine, p1, p2) => {
            if (!p1 || !p2) return null;
            const minX = Math.min(p1.x, p2.x); const maxX = Math.max(p1.x, p2.x);
            if (xLine < minX || xLine > maxX) return null; if (Math.abs(p2.x - p1.x) < 1e-6) return null;
            const t = (xLine - p1.x) / (p2.x - p1.x); return p1.z + t * (p2.z - p1.z);
        };
        const intersectHorizontalLineArc = (xLine, center, radius) => {
            if (!center) return [];
            const term = radius*radius - Math.pow(xLine - center.x, 2); if (term < 0) return [];
            const sqrtTerm = Math.sqrt(term); return [center.z - sqrtTerm, center.z + sqrtTerm];
        };
        const intersectVerticalLineSegment = (zLine, p1, p2) => {
            if (!p1 || !p2) return null;
            const minZ = Math.min(p1.z, p2.z); const maxZ = Math.max(p1.z, p2.z);
            if (zLine < minZ || zLine > maxZ) return null; if (Math.abs(p2.z - p1.z) < 1e-6) return null;
            const t = (zLine - p1.z) / (p2.z - p1.z); return p1.x + t * (p2.x - p1.x);
        };
        const intersectVerticalLineArc = (zLine, center, radius) => {
            if (!center) return [];
            const term = radius*radius - Math.pow(zLine - center.z, 2); if (term < 0) return [];
            const sqrtTerm = Math.sqrt(term); return [center.x - sqrtTerm, center.x + sqrtTerm];
        };

        // --- APP ---
        const App = () => {
            const [theme, setTheme] = useState('light');
            const [editMode, setEditMode] = useState('contour'); 
            const [mobileTab, setMobileTab] = useState('editor'); 
            const [copyFeedback, setCopyFeedback] = useState(false);
            
            const [simRunning, setSimRunning] = useState(false);
            const [simProgress, setSimProgress] = useState(0); 
            
            // Flag for LocalStorage Loading
            const [isLoaded, setIsLoaded] = useState(false);

            // DRAG & DROP & INSERT STATE
            const [draggedPointId, setDraggedPointId] = useState(null);
            const [hoverPointId, setHoverPointId] = useState(null);
            const [addPointMode, setAddPointMode] = useState(false); // New state for add point mode

            // UNDO / REDO STATE
            const [past, setPast] = useState([]);
            const [future, setFuture] = useState([]);

            const [params, setParams] = useState({
                machineType: 'LIMS=2000',
                mode: 'DIAMON',
                toolName: 'ROUGHER_T1',
                speed: 200,
                feed: 0.25,
                depthOfCut: 2.0,
                retractDistance: 2.0,
                allowanceX: 0.5,
                allowanceZ: 0.1,
                toolRadius: 0.8,
                doFinishing: true, 
                roughingStrategy: 'longitudinal',
                stockMode: 'cylinder', 
                stockMargin: 5.0, 
                stockDiameter: 100, 
                stockLength: 100,
                stockFace: 2.0,
                safeX: 150,
                safeZ: 5,
                machineStructure: 'lathe', 
                controlSystem: 'sinumerik',
                toolShape: 'round', // 'round' | 'polygon'
                toolLength: 10,
                toolAngle: 15, // 15 deg default
                toolTipAngle: 90 // Default 90 (Square)
            });

            const [contourPoints, setContourPoints] = useState([
                { id: 1, type: 'G0', x: 0, z: 0, r: 0, mode: 'ABS' },
                { id: 2, type: 'G1', x: 20, z: 0, r: 0, mode: 'ABS' },     
                { id: 3, type: 'G1', x: 20, z: -15, r: 0, mode: 'ABS' },   
                { id: 4, type: 'G1', x: 30, z: -15, r: 0, mode: 'ABS' },   
                { id: 5, type: 'G1', x: 35, z: -25, r: 0, mode: 'ABS' },   
                { id: 6, type: 'G1', x: 35, z: -40, r: 0, mode: 'ABS' },   
                { id: 7, type: 'G2', x: 55, z: -50, r: 10, mode: 'ABS' },  
                { id: 8, type: 'G1', x: 55, z: -55, r: 0, mode: 'ABS' }, 
                { id: 81, type: 'G1', x: 45, z: -55, r: 0, mode: 'ABS' }, 
                { id: 82, type: 'G1', x: 45, z: -60, r: 0, mode: 'ABS' }, 
                { id: 83, type: 'G1', x: 55, z: -60, r: 0, mode: 'ABS' }, 
                { id: 9, type: 'G1', x: 55, z: -65, r: 0, mode: 'ABS' }, 
                { id: 10, type: 'G3', x: 65, z: -75, r: 12, mode: 'ABS' },  
                { id: 11, type: 'G1', x: 80, z: -100, r: 0, mode: 'ABS' }  
            ]);

            const [stockPoints, setStockPoints] = useState([
                { id: 101, type: 'G0', x: 85, z: 2, r: 0, mode: 'ABS' },
                { id: 102, type: 'G1', x: 85, z: -105, r: 0, mode: 'ABS' },
                { id: 103, type: 'G1', x: 0, z: -105, r: 0, mode: 'ABS' }
            ]);
            
            const [errors, setErrors] = useState([]);
            const [gCodeInput, setGCodeInput] = useState('');
            const [generatedCode, setGeneratedCode] = useState([]);
            const [activeTab, setActiveTab] = useState('editor');
            
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const codeContainerRef = useRef(null);
            const [view, setView] = useState({ scale: 3, panX: 600, panY: 350 });
            const [isDragging, setIsDragging] = useState(false);
            const lastMousePos = useRef({ x: 0, y: 0 });
            const lastPinchDist = useRef(null);
            
            // --- HISTORY LOGIC ---
            const pushHistory = useCallback(() => {
                setPast(prev => [...prev, { 
                    contour: JSON.parse(JSON.stringify(contourPoints)), 
                    stock: JSON.parse(JSON.stringify(stockPoints)) 
                }]);
                setFuture([]);
            }, [contourPoints, stockPoints]);

            const undo = () => {
                if (past.length === 0) return;
                const previous = past[past.length - 1];
                const newPast = past.slice(0, -1);
                
                setFuture(prev => [{ 
                    contour: JSON.parse(JSON.stringify(contourPoints)), 
                    stock: JSON.parse(JSON.stringify(stockPoints)) 
                }, ...prev]);
                
                setContourPoints(previous.contour);
                setStockPoints(previous.stock);
                setPast(newPast);
            };

            const redo = () => {
                if (future.length === 0) return;
                const next = future[0];
                const newFuture = future.slice(1);
                
                setPast(prev => [...prev, { 
                    contour: JSON.parse(JSON.stringify(contourPoints)), 
                    stock: JSON.parse(JSON.stringify(stockPoints)) 
                }]);
                
                setContourPoints(next.contour);
                setStockPoints(next.stock);
                setFuture(newFuture);
            };

            // --- LOCAL STORAGE LOGIC ---
            const STORAGE_KEY = 'sinumerik_cam_save_v1';

            useEffect(() => {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        if (parsed.params) setParams(prev => ({...prev, ...parsed.params}));
                        if (parsed.contourPoints && parsed.contourPoints.length > 0) setContourPoints(parsed.contourPoints);
                        if (parsed.stockPoints && parsed.stockPoints.length > 0) setStockPoints(parsed.stockPoints);
                        if (parsed.theme) setTheme(parsed.theme);
                    } catch (e) {
                        console.error("Failed to load local storage:", e);
                    }
                }
                setIsLoaded(true);
            }, []);

            useEffect(() => {
                if (!isLoaded) return;
                const dataToSave = { params, contourPoints, stockPoints, theme };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
            }, [isLoaded, params, contourPoints, stockPoints, theme]);

            const handleResetApp = () => {
                if(confirm("Opravdu chcete vymazat veškerou uloženou práci a resetovat aplikaci?")) {
                    localStorage.removeItem(STORAGE_KEY);
                    window.location.reload();
                }
            };
            
            // --- PDF EXPORT LOGIC ---
            const handleExportPDF = () => {
                 if (!window.jspdf) {
                     alert("Knihovna pro PDF se ještě načítá, zkuste to za chvíli.");
                     return;
                 }

                 const { jsPDF } = window.jspdf;
                 const doc = new jsPDF();
                 const noAccents = (str) => str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");

                 // 1. Header
                 doc.setFontSize(20);
                 doc.text(noAccents("Technologicky list - CAM"), 15, 20);
                 
                 doc.setFontSize(10);
                 doc.text(`Datum: ${new Date().toLocaleDateString()}`, 15, 30);
                 doc.text(noAccents(`System: ${params.controlSystem.toUpperCase()}`), 15, 35);
                 
                 // 2. Parameters
                 doc.setFontSize(12);
                 doc.text(noAccents("Parametry obrabeni:"), 15, 50);
                 doc.setFontSize(10);
                 let y = 60;
                 const addParam = (label, val) => {
                     doc.text(noAccents(`${label}: ${val}`), 20, y);
                     y += 6;
                 };
                 
                 addParam("Stroj", params.machineType);
                 addParam("Nastroj", params.toolName);
                 addParam("Rezna rychlost", params.speed + " m/min");
                 addParam("Posuv", params.feed + " mm/ot");
                 addParam("Hloubka trisky", params.depthOfCut + " mm");
                 
                 // 3. Image
                 if (canvasRef.current) {
                     const imgData = canvasRef.current.toDataURL("image/png");
                     // A4 width is 210. Margins 15. Width available 180.
                     const imgProps = doc.getImageProperties(imgData);
                     const pdfWidth = 100;
                     const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;
                     
                     doc.text(noAccents("Nahled drahy:"), 100, 50);
                     doc.addImage(imgData, 'PNG', 100, 55, pdfWidth, pdfHeight);
                 }
                 
                 // 4. G-Code
                 y = 120; 
                 doc.setFontSize(12);
                 doc.text("G-Code:", 15, y);
                 y += 10;
                 doc.setFont("courier", "normal");
                 doc.setFontSize(9);
                 
                 generatedCode.forEach(lineObj => {
                     if (y > 280) {
                         doc.addPage();
                         y = 20;
                     }
                     doc.text(noAccents(lineObj.text), 15, y);
                     y += 5;
                 });
                 
                 doc.save("CAM_Export.pdf");
            };

            useEffect(() => {
                document.body.className = `h-[100dvh] w-screen overflow-hidden flex flex-col font-sans transition-colors duration-300 ${theme === 'dark' ? 'bg-gray-900 text-gray-100' : 'bg-gray-50 text-gray-900'}`;
            }, [theme]);

            const fitView = useCallback(() => {
                if (!containerRef.current) return;
                const points = resolvePointsToAbsolute(contourPoints);
                if (points.length === 0) return;
                let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
                points.forEach(p => {
                    const x = params.mode === 'DIAMON' ? p.xAbs / 2 : p.xAbs;
                    const z = p.zAbs;
                    if(x < minX) minX = x; if(x > maxX) maxX = x;
                    if(z < minZ) minZ = z; if(z > maxZ) maxZ = z;
                });
                const pad = 20;
                
                const isCarousel = params.machineStructure === 'carousel';
                const visWidth = isCarousel ? (maxX - minX) : (maxZ - minZ);
                const visHeight = isCarousel ? (maxZ - minZ) : (maxX - minX);
                
                const width = visWidth + pad * 2;
                const height = visHeight + pad * 2;
                
                if (width <= 0 || height <= 0) return;
                const contW = containerRef.current.clientWidth;
                const contH = containerRef.current.clientHeight;
                if (contW === 0 || contH === 0) return;
                const scaleX = contW / width;
                const scaleY = contH / height;
                let newScale = Math.min(scaleX, scaleY) * 0.8; 
                if (newScale > 10) newScale = 10;
                if (newScale < 0.1) newScale = 0.1;
                
                const midZ = (minZ + maxZ) / 2;
                const midX = (minX + maxX) / 2;
                
                if (isCarousel) {
                    setView({ scale: newScale, panX: contW/2 - midX * newScale, panY: contH/2 + midZ * newScale });
                } else {
                    setView({ scale: newScale, panX: contW/2 - midZ * newScale, panY: contH/2 + midX * newScale });
                }
                
            }, [contourPoints, params.mode, params.machineStructure]);

            useEffect(() => { setTimeout(fitView, 100); }, [mobileTab, params.machineStructure]); 

            const resolvePointsToAbsolute = (pts) => {
                let lastX = 0; let lastZ = 0;
                return pts.map((p, index) => {
                    let valX = parseFloat(p.x); if(isNaN(valX)) valX = 0;
                    let valZ = parseFloat(p.z); if(isNaN(valZ)) valZ = 0;
                    let absX = valX; let absZ = valZ;
                    if (p.mode === 'INC') { absX = lastX + valX; absZ = lastZ + valZ; } else { absX = valX; absZ = valZ; }
                    lastX = absX; lastZ = absZ;
                    let rVal = parseFloat(p.r); if(isNaN(rVal)) rVal = 0;
                    return { ...p, xAbs: absX, zAbs: absZ, rVal };
                });
            };

            const handleAutoStock = () => {
                const absPts = resolvePointsToAbsolute(contourPoints);
                if (absPts.length === 0) return;
                let minZ = Infinity, maxZ = -Infinity;
                let maxD = 0;
                
                absPts.forEach(p => {
                    const x = params.mode === 'DIAMON' ? p.xAbs : p.xAbs * 2; 
                    if (Math.abs(x) > maxD) maxD = Math.abs(x);
                    if (p.zAbs < minZ) minZ = p.zAbs;
                    if (p.zAbs > maxZ) maxZ = p.zAbs;
                });
                
                const margin = parseFloat(params.stockMargin) || 5;
                const stockD = Math.ceil(maxD + margin*2); 
                const stockL = Math.ceil(Math.abs(minZ) + margin); 
                const stockF = 2.0;

                setParams(p => ({
                    ...p,
                    stockDiameter: stockD,
                    stockLength: stockL,
                    stockFace: stockF
                }));
            };

            const generateDefaultStock = () => {
                const absPts = resolvePointsToAbsolute(contourPoints);
                if (absPts.length === 0) return;
                let minZ = Infinity;
                let maxX = 0;
                
                absPts.forEach(p => {
                    const x = params.mode === 'DIAMON' ? p.xAbs/2 : p.xAbs;
                    if (Math.abs(x) > maxX) maxX = Math.abs(x);
                    if (p.zAbs < minZ) minZ = p.zAbs;
                });
                
                const sR = maxX + 5;
                const sL = minZ - 5;
                
                const newStock = [
                     { id: Date.now(), type: 'G0', x: sR, z: 2, r: 0, mode: 'ABS' },
                     { id: Date.now()+1, type: 'G1', x: sR, z: sL, r: 0, mode: 'ABS' },
                     { id: Date.now()+2, type: 'G1', x: 0, z: sL, r: 0, mode: 'ABS' }
                ];
                setStockPoints(newStock);
            };

            const calculatedData = useMemo(() => {
                const absContour = resolvePointsToAbsolute(contourPoints);
                const absStock = resolvePointsToAbsolute(stockPoints);
                const worldPoints = absContour.map(p => ({ ...p, xReal: params.mode === 'DIAMON' ? p.xAbs / 2 : p.xAbs, zReal: p.zAbs }));
                const stockWorldPoints = absStock.map(p => ({ ...p, xReal: params.mode === 'DIAMON' ? p.xAbs / 2 : p.xAbs, zReal: p.zAbs }));

                const tipR = parseFloat(params.toolRadius) || 0;
                const allowanceX = parseFloat(params.allowanceX) || 0;
                const allowanceZ = parseFloat(params.allowanceZ) || 0;
                const totalOffset = tipR + Math.max(allowanceX, allowanceZ);
                const retractDist = parseFloat(params.retractDistance) || 2.0; 
                
                let contourSegments = [];
                let rawOffsets = []; 
                let finishOffsetPath = [];
                let stockPathSegments = []; 
                const foundErrors = [];

                for (let i = 0; i < worldPoints.length - 1; i++) {
                    const p1 = worldPoints[i]; const p2 = worldPoints[i+1]; const type = p2.type;
                    if (type === 'G0' || type === 'G1') {
                        contourSegments.push({ type: 'line', p1: {x:p1.xReal, z:p1.zReal}, p2: {x:p2.xReal, z:p2.zReal}, orig: p2 });
                    } else if (type === 'G2' || type === 'G3') {
                        const arc = getArcParams({x:p1.xReal, z:p1.zReal}, {x:p2.xReal, z:p2.zReal}, p2.rVal, type);
                        if (arc.error) foundErrors.push(`Řádek ${i+2}: Rádius R${p2.r} je příliš malý.`);
                        else if (arc.r < totalOffset) foundErrors.push(`KOLIZE (Řádek ${i+2}): Rádius kontury menší než nástroj.`);
                        contourSegments.push({ type: 'arc', ...arc, p1: {x:p1.xReal, z:p1.zReal}, p2: {x:p2.xReal, z:p2.zReal}, dir: type });
                    }
                }
                for (let i = 0; i < stockWorldPoints.length - 1; i++) {
                    const p1 = stockWorldPoints[i]; const p2 = stockWorldPoints[i+1]; const type = p2.type;
                    if (type === 'G0' || type === 'G1') {
                        stockPathSegments.push({ type: 'line', p1: {x:p1.xReal, z:p1.zReal}, p2: {x:p2.xReal, z:p2.zReal} });
                    } else if (type === 'G2' || type === 'G3') {
                        const arc = getArcParams({x:p1.xReal, z:p1.zReal}, {x:p2.xReal, z:p2.zReal}, p2.rVal, type);
                        const startAngle = Math.atan2(p1.xReal - arc.cx, p1.zReal - arc.cz);
                        const endAngle = Math.atan2(p2.xReal - arc.cx, p2.zReal - arc.cz);
                        stockPathSegments.push({ type: 'arc', ...arc, dir: type, startAngle, endAngle });
                    }
                }

                let incompleteMachiningCount = 0;
                
                // 1. GENERATE RAW OFFSETS (Skipping impossible arcs)
                for (let i = 0; i < contourSegments.length; i++) {
                    const seg = contourSegments[i];
                    let offSeg = null;
                    if (seg.type === 'line') {
                        const n = getNormal(seg.p1, seg.p2);
                        offSeg = { type: 'line', p1: { x: seg.p1.x + n.x * totalOffset, z: seg.p1.z + n.z * totalOffset }, p2: { x: seg.p2.x + n.x * totalOffset, z: seg.p2.z + n.z * totalOffset } };
                    } else if (seg.type === 'arc') {
                        let rNew = (seg.dir === 'G3') ? seg.r + totalOffset : seg.r - totalOffset;
                        
                        // FIX: If rNew is approximately 0 (concave corner with Tool Radius >= Part Radius),
                        // simply SKIP the segment. The trimming/connecting logic will bridge the gap.
                        if (rNew <= 1.5) { // Increased threshold to catch R=ToolR cases (degenerate)
                            incompleteMachiningCount++;
                            offSeg = null; // SKIP DEGENERATE
                        } else {
                            const startAngle = Math.atan2(seg.p1.x - seg.cx, seg.p1.z - seg.cz);
                            const endAngle = Math.atan2(seg.p2.x - seg.cx, seg.p2.z - seg.cz);
                            offSeg = { type: 'arc', cx: seg.cx, cz: seg.cz, r: rNew, dir: seg.dir, refP1: seg.p1, refP2: seg.p2, startAngle, endAngle, dir: seg.dir };
                        }
                    }
                    if (offSeg) rawOffsets.push(offSeg);
                }
                
                // 2. LOCAL TRIMMING & CONNECTING
                let trimmedOffsetPath = [];
                if (rawOffsets.length > 0) {
                    trimmedOffsetPath.push(JSON.parse(JSON.stringify(rawOffsets[0])));
                    
                    for (let i = 0; i < rawOffsets.length - 1; i++) {
                        let prevOff = trimmedOffsetPath[trimmedOffsetPath.length - 1]; 
                        let nextOff = JSON.parse(JSON.stringify(rawOffsets[i+1])); 
                        
                        let intersection = null;
                        
                        // Intersection Check
                        if (prevOff.type === 'line' && nextOff.type === 'line') {
                            intersection = intersectLines(prevOff.p1, prevOff.p2, nextOff.p1, nextOff.p2);
                        } else if (prevOff.type === 'line' && nextOff.type === 'arc') {
                            const ints = intersectLineCircle(prevOff.p1, prevOff.p2, {x:nextOff.cx, z:nextOff.cz}, nextOff.r);
                            if (ints && ints.length > 0) {
                                const d1 = Math.hypot(ints[0].x - prevOff.p2.x, ints[0].z - prevOff.p2.z);
                                const d2 = Math.hypot(ints[1].x - prevOff.p2.x, ints[1].z - prevOff.p2.z);
                                intersection = d1 < d2 ? ints[0] : ints[1];
                            }
                        } else if (prevOff.type === 'arc' && nextOff.type === 'line') {
                            const ints = intersectLineCircle(nextOff.p1, nextOff.p2, {x:prevOff.cx, z:prevOff.cz}, prevOff.r);
                            if (ints && ints.length > 0) {
                                const d1 = Math.hypot(ints[0].x - nextOff.p1.x, ints[0].z - nextOff.p1.z);
                                const d2 = Math.hypot(ints[1].x - nextOff.p1.x, ints[1].z - nextOff.p1.z);
                                intersection = d1 < d2 ? ints[0] : ints[1];
                            }
                        }

                        if (intersection) {
                            // Trim segments to intersection
                            if (prevOff.type === 'line') prevOff.p2 = intersection;
                            else prevOff.endAngle = Math.atan2(intersection.x - prevOff.cx, intersection.z - prevOff.cz);

                            if (nextOff.type === 'line') nextOff.p1 = intersection;
                            else nextOff.startAngle = Math.atan2(intersection.x - nextOff.cx, intersection.z - nextOff.cz);
                            
                            trimmedOffsetPath.push(nextOff);
                        } else {
                            // NO INTERSECTION FOUND (Gap exists)
                            // User request: "Kolmo nahoru a pak doleva" (Up then Left)
                            // This is a "Dog-Leg" connection.
                            
                            // 1. Try infinite intersection first (Best for Line-Line square corners)
                            let corner = null;
                            if (prevOff.type === 'line' && nextOff.type === 'line') {
                                corner = intersectLinesInfinite(prevOff.p1, prevOff.p2, nextOff.p1, nextOff.p2);
                            }

                            if (corner) {
                                // If we found a mathematical corner, snap to it
                                prevOff.p2 = corner;
                                nextOff.p1 = corner;
                            } else {
                                // If parallel or arcs involved, create a Dog-Leg Bridge
                                // "Up" (Match Next X) then "Left" (Match Next Z)
                                // We create an intermediate segment to bridge the gap orthogonally
                                
                                // End of Prev
                                const pStart = (prevOff.type === 'line') ? prevOff.p2 : {x: prevOff.cx + Math.sin(prevOff.endAngle)*prevOff.r, z: prevOff.cz + Math.cos(prevOff.endAngle)*prevOff.r};
                                // Start of Next
                                const pEnd = (nextOff.type === 'line') ? nextOff.p1 : {x: nextOff.cx + Math.sin(nextOff.startAngle)*nextOff.r, z: nextOff.cz + Math.cos(nextOff.startAngle)*nextOff.r};

                                // Insert Segment 1: (Xp, Zp) -> (Xn, Zp) [Vertical Step Up]
                                // Insert Segment 2: (Xn, Zp) -> (Xn, Zn) [Horizontal Step Left]
                                
                                trimmedOffsetPath.push({ type: 'line', p1: pStart, p2: {x: pEnd.x, z: pStart.z} }); // Vertical
                                if (Math.abs(pEnd.z - pStart.z) > 0.001) {
                                    trimmedOffsetPath.push({ type: 'line', p1: {x: pEnd.x, z: pStart.z}, p2: pEnd }); // Horizontal
                                }
                            }
                            
                            trimmedOffsetPath.push(nextOff);
                        }
                    }
                }
                
                // 3. GLOBAL LOOP REMOVAL (Improved Tolerance & Furthest Intersection)
                if (trimmedOffsetPath.length > 2) {
                    let loopFound = true;
                    let iterations = 0;
                    while (loopFound && iterations < 5) { // safety break
                        loopFound = false;
                        iterations++;
                        
                        outerLoop:
                        for (let i = 0; i < trimmedOffsetPath.length - 2; i++) {
                            for (let j = i + 2; j < trimmedOffsetPath.length; j++) {
                                const s1 = trimmedOffsetPath[i];
                                const s2 = trimmedOffsetPath[j];
                                
                                if (s1.isDegenerate || s2.isDegenerate) continue;
                                
                                let intersection = null;
                                // Simple Line-Line check
                                if (s1.type === 'line' && s2.type === 'line') {
                                    intersection = intersectLines(s1.p1, s1.p2, s2.p1, s2.p2);
                                    
                                    if (intersection) {
                                         // RELAXED TOLERANCE for physical existence
                                         const tol = 0.5; // Relaxed from 0.001 to catch slightly out-of-bounds intersections in deep grooves
                                         const minX1 = Math.min(s1.p1.x, s1.p2.x) - tol; const maxX1 = Math.max(s1.p1.x, s1.p2.x) + tol;
                                         const minZ1 = Math.min(s1.p1.z, s1.p2.z) - tol; const maxZ1 = Math.max(s1.p1.z, s1.p2.z) + tol;
                                         const minX2 = Math.min(s2.p1.x, s2.p2.x) - tol; const maxX2 = Math.max(s2.p1.x, s2.p2.x) + tol;
                                         const minZ2 = Math.min(s2.p1.z, s2.p2.z) - tol; const maxZ2 = Math.max(s2.p1.z, s2.p2.z) + tol;
                                         
                                         if (!(intersection.x >= minX1 && intersection.x <= maxX1 && intersection.z >= minZ1 && intersection.z <= maxZ1 &&
                                               intersection.x >= minX2 && intersection.x <= maxX2 && intersection.z >= minZ2 && intersection.z <= maxZ2)) {
                                             intersection = null;
                                         }
                                    }
                                }
                                

                                if (intersection) {
                                    // Trim s1 to end at intersection
                                    if (s1.type === 'line') s1.p2 = intersection;
                                    else s1.endAngle = Math.atan2(intersection.x - s1.cx, intersection.z - s1.cz); 
                                    
                                    // Trim s2 to start at intersection
                                    if (s2.type === 'line') s2.p1 = intersection;
                                    else s2.startAngle = Math.atan2(intersection.x - s2.cx, intersection.z - s2.cz);
                                    
                                    // Remove segments between i and j (exclusive)
                                    // And merge i and j into new list
                                    trimmedOffsetPath.splice(i + 1, j - (i + 1));
                                    loopFound = true; 
                                    break outerLoop; // Restart scan
                                }
                            }
                        }
                    }
                }

                const offsetPath = trimmedOffsetPath; 
                
                if (params.doFinishing) {
                    let finRaw = [];
                    for (let i = 0; i < contourSegments.length; i++) {
                        const seg = contourSegments[i];
                         if (seg.type === 'line') {
                            const n = getNormal(seg.p1, seg.p2);
                            finRaw.push({ type: 'line', p1: { x: seg.p1.x + n.x * tipR, z: seg.p1.z + n.z * tipR }, p2: { x: seg.p2.x + n.x * tipR, z: seg.p2.z + n.z * tipR } });
                        } else if (seg.type === 'arc') {
                            let rNew = (seg.dir === 'G3') ? seg.r + tipR : seg.r - tipR;
                            if (rNew <= 1.5) {
                                // Skip degenerate
                            } else {
                                const startAngle = Math.atan2(seg.p1.x - seg.cx, seg.p1.z - seg.cz);
                                const endAngle = Math.atan2(seg.p2.x - seg.cx, seg.p2.z - seg.cz);
                                finRaw.push({ type: 'arc', cx: seg.cx, cz: seg.cz, r: rNew, dir: seg.dir, refP1: seg.p1, refP2: seg.p2, startAngle, endAngle });
                            }
                        }
                    }
                    
                    if (finRaw.length > 0) {
                         finishOffsetPath.push(JSON.parse(JSON.stringify(finRaw[0])));
                         for (let i = 0; i < finRaw.length - 1; i++) {
                            let prevOff = finishOffsetPath[finishOffsetPath.length - 1]; 
                            let nextOff = JSON.parse(JSON.stringify(finRaw[i+1])); 
                            
                            let intersection = null;
                            
                            if (prevOff.type === 'line' && nextOff.type === 'line') {
                                intersection = intersectLines(prevOff.p1, prevOff.p2, nextOff.p1, nextOff.p2);
                            } else if (prevOff.type === 'line' && nextOff.type === 'arc') {
                                const ints = intersectLineCircle(prevOff.p1, prevOff.p2, {x:nextOff.cx, z:nextOff.cz}, nextOff.r);
                                if(ints && ints.length > 0) {
                                    const d1 = Math.hypot(ints[0].x - prevOff.p2.x, ints[0].z - prevOff.p2.z);
                                    const d2 = Math.hypot(ints[1].x - prevOff.p2.x, ints[1].z - prevOff.p2.z);
                                    intersection = d1 < d2 ? ints[0] : ints[1];
                                }
                            } else if (prevOff.type === 'arc' && nextOff.type === 'line') {
                                const ints = intersectLineCircle(nextOff.p1, nextOff.p2, {x:prevOff.cx, z:prevOff.cz}, prevOff.r);
                                if(ints && ints.length > 0) {
                                    const d1 = Math.hypot(ints[0].x - nextOff.p1.x, ints[0].z - nextOff.p1.z);
                                    const d2 = Math.hypot(ints[1].x - nextOff.p1.x, ints[1].z - nextOff.p1.z);
                                    intersection = d1 < d2 ? ints[0] : ints[1];
                                }
                            }
                            
                            if (intersection) {
                                if (prevOff.type === 'line') prevOff.p2 = intersection;
                                else prevOff.endAngle = Math.atan2(intersection.x - prevOff.cx, intersection.z - prevOff.cz);
                                if (nextOff.type === 'line') nextOff.p1 = intersection;
                                else nextOff.startAngle = Math.atan2(intersection.x - nextOff.cx, intersection.z - nextOff.cz);
                                finishOffsetPath.push(nextOff);
                            } else {
                                // GAP FILLING FOR FINISHING (Same Logic)
                                let corner = null;
                                if (prevOff.type === 'line' && nextOff.type === 'line') {
                                    corner = intersectLinesInfinite(prevOff.p1, prevOff.p2, nextOff.p1, nextOff.p2);
                                }
                                if(corner) {
                                    prevOff.p2 = corner;
                                    nextOff.p1 = corner;
                                } else {
                                    // Dog-leg bridge fallback
                                    const pStart = (prevOff.type === 'line') ? prevOff.p2 : {x: prevOff.cx + Math.sin(prevOff.endAngle)*prevOff.r, z: prevOff.cz + Math.cos(prevOff.endAngle)*prevOff.r};
                                    const pEnd = (nextOff.type === 'line') ? nextOff.p1 : {x: nextOff.cx + Math.sin(nextOff.startAngle)*nextOff.r, z: nextOff.cz + Math.cos(nextOff.startAngle)*nextOff.r};

                                    finishOffsetPath.push({ type: 'line', p1: pStart, p2: {x: pEnd.x, z: pStart.z} }); // Vertical
                                    if (Math.abs(pEnd.z - pStart.z) > 0.001) {
                                        finishOffsetPath.push({ type: 'line', p1: {x: pEnd.x, z: pStart.z}, p2: pEnd }); // Horizontal
                                    }
                                }
                                finishOffsetPath.push(nextOff);
                            }
                         }
                    }
                    
                    // APPLY LOOP REMOVAL TO FINISHING PATH AS WELL (Fixes Groove Gouging for Finish)
                    if (finishOffsetPath.length > 2) {
                        let loopFound = true;
                        let iterations = 0;
                        while (loopFound && iterations < 5) { 
                            loopFound = false;
                            iterations++;
                            
                            outerLoopFin:
                            for (let i = 0; i < finishOffsetPath.length - 2; i++) {
                                for (let j = i + 2; j < finishOffsetPath.length; j++) {
                                    const s1 = finishOffsetPath[i];
                                    const s2 = finishOffsetPath[j];
                                    
                                    if (s1.isDegenerate || s2.isDegenerate) continue;
                                    
                                    let intersection = null;
                                    if (s1.type === 'line' && s2.type === 'line') {
                                        intersection = intersectLines(s1.p1, s1.p2, s2.p1, s2.p2);
                                        if (intersection) {
                                             const tol = 0.5;
                                             const minX1 = Math.min(s1.p1.x, s1.p2.x) - tol; const maxX1 = Math.max(s1.p1.x, s1.p2.x) + tol;
                                             const minZ1 = Math.min(s1.p1.z, s1.p2.z) - tol; const maxZ1 = Math.max(s1.p1.z, s1.p2.z) + tol;
                                             const minX2 = Math.min(s2.p1.x, s2.p2.x) - tol; const maxX2 = Math.max(s2.p1.x, s2.p2.x) + tol;
                                             const minZ2 = Math.min(s2.p1.z, s2.p2.z) - tol; const maxZ2 = Math.max(s2.p1.z, s2.p2.z) + tol;
                                             
                                             if (!(intersection.x >= minX1 && intersection.x <= maxX1 && intersection.z >= minZ1 && intersection.z <= maxZ1 &&
                                                   intersection.x >= minX2 && intersection.x <= maxX2 && intersection.z >= minZ2 && intersection.z <= maxZ2)) {
                                                 intersection = null;
                                             }
                                        }
                                    }
                                    if (intersection) {
                                        if (s1.type === 'line') s1.p2 = intersection;
                                        else s1.endAngle = Math.atan2(intersection.x - s1.cx, intersection.z - s1.cz); 
                                        if (s2.type === 'line') s2.p1 = intersection;
                                        else s2.startAngle = Math.atan2(intersection.x - s2.cx, intersection.z - s2.cz);
                                        finishOffsetPath.splice(i + 1, j - (i + 1));
                                        loopFound = true; 
                                        break outerLoopFin;
                                    }
                                }
                            }
                        }
                    }
                }
                
                if (incompleteMachiningCount > 0) foundErrors.push({ type: 'warning', msg: `POZNÁMKA: V ${incompleteMachiningCount} místech nedojde ke kompletnímu obrobení.` });
                setErrors(foundErrors);

                const passes = [];
                const step = parseFloat(params.depthOfCut) || 1;
                const sRad = (parseFloat(params.stockDiameter) || 100)/2;
                const stockFace = parseFloat(params.stockFace) || 0;
                
                if (params.roughingStrategy === 'face') {
                    let currentZ = stockFace;
                    const minZPart = -1000;
                    let safe = 0;
                    while (currentZ > minZPart && safe < 500) {
                        currentZ -= step; safe++;
                        let xsEnd = [];
                        offsetPath.forEach(os => {
                            if (os.isDegenerate) return;
                            if (os.type === 'line') {
                                const x = intersectVerticalLineSegment(currentZ, os.p1, os.p2);
                                if (x !== null) xsEnd.push(x);
                            } else if (os.type === 'arc') {
                                const res = intersectVerticalLineArc(currentZ, {x: os.cx, z: os.cz}, os.r);
                                res.forEach(x => {
                                    const angle = Math.atan2(x - os.cx, currentZ - os.cz);
                                    if (isAngleBetween(angle, os.startAngle, os.endAngle, os.dir === 'G2')) xsEnd.push(x);
                                });
                            }
                        });
                        xsEnd.sort((a, b) => a - b); 
                        let xTarget = 0;
                        if (xsEnd.length > 0) {
                            const validXs = xsEnd.filter(x => x < sRad + 1);
                            if (validXs.length > 0) xTarget = validXs[validXs.length - 1]; 
                        } else {
                            let maxOZ = -9999;
                            offsetPath.forEach(p => { 
                                if(p.isDegenerate) return;
                                const z1 = p.type==='line' ? p.p1.z : p.cz + p.r; 
                                const z2 = p.type==='line' ? p.p2.z : p.cz - p.r; 
                                maxOZ = Math.max(maxOZ, z1, z2);
                            });
                            if (currentZ > maxOZ) xTarget = -1; else continue; 
                        }
                        if (xTarget >= sRad - 0.01) continue;
                        passes.push({ type: 'face', z: currentZ, xStart: sRad + 2, xEnd: xTarget });
                        if (currentZ < -200) break; 
                    }
                } else {
                    let currentX = sRad;
                    if (params.stockMode === 'casting' && stockWorldPoints.length > 0) {
                       let maxStockX = -9999;
                       stockWorldPoints.forEach(p => { if (p.xReal > maxStockX) maxStockX = p.xReal; });
                       currentX = maxStockX; 
                    }
                    const cylStockZ = (parseFloat(params.stockLength) || 100) * -1;
                    let safe = 0;
                    while (currentX > -50 && safe < 500) {
                        currentX -= step; safe++;
                        let zsEnd = [];
                        offsetPath.forEach(os => {
                            if(os.isDegenerate) return;
                            if (os.type === 'line') {
                                const z = intersectHorizontalLineSegment(currentX, os.p1, os.p2);
                                if (z !== null) zsEnd.push(z);
                            } else if (os.type === 'arc') {
                                const res = intersectHorizontalLineArc(currentX, {x: os.cx, z: os.cz}, os.r);
                                res.forEach(z => {
                                    const angle = Math.atan2(currentX - os.cx, z - os.cz);
                                    if (isAngleBetween(angle, os.startAngle, os.endAngle, os.dir === 'G2')) zsEnd.push(z);
                                });
                            }
                        });
                        zsEnd.sort((a, b) => b - a);
                        zsEnd = zsEnd.filter((z, i) => i === 0 || Math.abs(z - zsEnd[i-1]) > 0.01);

                        if (zsEnd.length > 0) {
                            let zTarget = zsEnd[0];
                            let zStartCut = allowanceZ;
                            if (params.stockMode === 'casting') {
                                let zsStart = [];
                                stockPathSegments.forEach(ss => {
                                    if (ss.type === 'line') {
                                        const z = intersectHorizontalLineSegment(currentX, ss.p1, ss.p2);
                                        if (z !== null) zsStart.push(z);
                                    } else if (ss.type === 'arc') {
                                        const res = intersectHorizontalLineArc(currentX, {x: ss.cx, z: ss.cz}, ss.r);
                                        res.forEach(z => {
                                            const angle = Math.atan2(currentX - ss.cx, z - ss.cz);
                                            if (isAngleBetween(angle, ss.startAngle, ss.endAngle, ss.dir === 'G2')) zsStart.push(z);
                                        });
                                    }
                                });
                                zsStart.sort((a, b) => b - a);
                                const validStarts = zsStart.filter(z => z > zTarget + 0.01);
                                if (validStarts.length > 0) zStartCut = validStarts[0];
                                else if (zsStart.length === 0) continue; 
                            } else {
                                if (currentX > sRad) continue; 
                                if (zTarget < cylStockZ) zTarget = cylStockZ;
                                zStartCut = stockFace;
                            }
                            if (zStartCut > zTarget) {
                                passes.push({ type: 'long', x: currentX, zStart: zStartCut, zEnd: zTarget });
                            }
                        }
                        let minPartX = 9999;
                        offsetPath.forEach(os => {
                           if(os.isDegenerate) return;
                           if (os.type === 'line') minPartX = Math.min(minPartX, os.p1.x, os.p2.x);
                           else minPartX = Math.min(minPartX, os.cx - os.r); 
                        });
                        if (currentX < minPartX - 1) break; 
                    }
                }

                const simPath = [];
                simPath.push({x: params.safeX/2, z: params.safeZ, type: 'G0'});
                
                // Initialize current tool position for Dog-leg calculation
                let currentSimX = params.safeX/2;
                let currentSimZ = params.safeZ;

                passes.forEach(pass => {
                    const tx = pass.type === 'long' ? (pass.type==='long' ? pass.x : pass.xStart) : pass.xStart; // Target X for cut start
                    const tz = pass.type === 'long' ? pass.zStart + 1 : pass.z; // Target Z for cut start (with small safety)
                    
                    // Dog-leg Rapid Approach: Move Z first, then X (Safest for external turning)
                    // 1. Move Z to target Z at current X (or Safe X)
                    if (Math.abs(currentSimZ - tz) > 0.001) {
                        simPath.push({x: currentSimX, z: tz, type: 'G0'});
                        currentSimZ = tz;
                    }
                    // 2. Move X down to cut start
                    if (Math.abs(currentSimX - tx) > 0.001) {
                         simPath.push({x: tx, z: tz, type: 'G0'});
                         currentSimX = tx;
                    }

                    if (pass.type === 'long') {
                        const xRetract = pass.x + retractDist; 
                        const xCut = pass.x;
                        
                        // We are at start point (xCut, zStart+1)
                        simPath.push({x: xCut, z: pass.zEnd, type: 'G1'});          
                        simPath.push({x: xRetract, z: pass.zEnd + retractDist, type: 'G1'});   
                        simPath.push({x: xRetract, z: pass.zStart + 1, type: 'G0'});   
                        
                        currentSimX = xRetract;
                        currentSimZ = pass.zStart + 1;
                    } else {
                        const zRetract = pass.z + retractDist; 
                        const zCut = pass.z;
                        
                        // We are at start point (xStart, zCut)
                        simPath.push({x: pass.xEnd, z: zCut, type: 'G1'}); 
                        simPath.push({x: pass.xEnd, z: zRetract, type: 'G1'}); 
                        simPath.push({x: pass.xStart, z: zRetract, type: 'G0'}); 
                        
                        currentSimX = pass.xStart;
                        currentSimZ = zRetract;
                    }
                });
                
                simPath.push({x: params.safeX/2, z: params.safeZ, type: 'G0'});

                if (params.doFinishing && finishOffsetPath.length > 0) {
                     const startSeg = finishOffsetPath[0];
                     const startX = startSeg.type === 'line' ? startSeg.p1.x : (startSeg.cx + Math.sin(startSeg.startAngle)*startSeg.r);
                     const startZ = startSeg.type === 'line' ? startSeg.p1.z : (startSeg.cz + Math.cos(startSeg.startAngle)*startSeg.r);
                     
                     simPath.push({x: startX + 2, z: startZ, type: 'G0'}); 
                     simPath.push({x: startX, z: startZ, type: 'G1'}); 

                     finishOffsetPath.forEach(seg => {
                         if (seg.isDegenerate) return;
                         if (seg.type === 'line') {
                             simPath.push({x: seg.p2.x, z: seg.p2.z, type: 'G1'});
                         } else {
                             const steps = 10;
                             let sA = seg.startAngle;
                             let eA = seg.endAngle;
                             
                             if (seg.dir === 'G2' && eA > sA) eA -= 2*Math.PI;
                             if (seg.dir === 'G3' && eA < sA) eA += 2*Math.PI;
                             
                             for(let j=1; j<=steps; j++) {
                                 const a = sA + (eA - sA) * (j/steps);
                                 simPath.push({x: seg.cx + Math.sin(a)*seg.r, z: seg.cz + Math.cos(a)*seg.r, type: seg.dir});
                             }
                         }
                     });
                     
                     const lastPt = simPath[simPath.length-1];
                     simPath.push({x: lastPt.x + 2, z: lastPt.z + 2, type: 'G0'});
                     simPath.push({x: params.safeX/2, z: params.safeZ, type: 'G0'});
                }

                return { worldPoints, stockWorldPoints, offsetPath, finishOffsetPath, stockPathSegments, passes, simPath, retractDist };
            }, [contourPoints, stockPoints, params]);

            // --- G-Code and Mapping Generation ---
            useEffect(() => {
                let animationFrameId; let startTime;
                const animate = (time) => {
                    if (!startTime) startTime = time;
                    if (simRunning) {
                        setSimProgress(prev => { 
                            // ZPOMALENO z 0.003 na 0.0015
                            const next = prev + 0.0015; 
                            if (next >= 1) { 
                                setSimRunning(false); 
                                return 1; 
                            } 
                            return next; 
                        });
                        animationFrameId = requestAnimationFrame(animate);
                    }
                };
                if (simRunning) animationFrameId = requestAnimationFrame(animate);
                return () => cancelAnimationFrame(animationFrameId);
            }, [simRunning]);

            useEffect(() => {
                const d = new Date();
                const lines = []; 
                const add = (text, simIdx = null) => lines.push({ text, simIdx });
                
                const cmt = (text) => {
                    if (params.controlSystem === 'fanuc') return `( ${text} )`;
                    return `; ${text}`;
                };
                const addCmt = (text) => add(cmt(text), null);
                
                // Block number counter
                let blockNum = 10;
                const N = () => {
                    const s = `N${blockNum} `;
                    blockNum += 10;
                    return s;
                };

                // Helper for lines with block numbers
                const addN = (text, simIdx = null) => {
                    add(`${N()}${text}`, simIdx);
                };

                const note = (cmd, text) => ` ${cmd}${cmt(text)}`; 

                // Konfigurace pro jednotlivé systémy
                // FIX: Added parseFloat(r) || 0 to prevent crashes when input is invalid or empty
                let arcR = (r) => `CR=${(parseFloat(r) || 0).toFixed(3)}`; // Default Sinumerik

                if (params.controlSystem === 'sinumerik') {
                    addCmt(`Vygenerovaný kód SINUMERIK 840D`);
                    addCmt(`Datum: ${d.toLocaleDateString()}`);
                    addN(`G18${note('', 'Rovina ZX')}`);
                    addN(`G90${note('', 'Absolutní programování')}`);
                    addN(`G54${note('', 'Posunutí počátku')}`);
                    addN(`G95${note('', 'Posuv na otáčku')}`);
                    addN(`G75 Z0${note('', 'Nájezd do ref. bodu')}`);
                    addN(`G75 X0`);
                    addN(`LIMS=2000${note('', 'Limit otáček')}`);
                    addN(`G96 S${params.speed} ${params.machineType}${note('', 'Konst. řezná rychlost')}`);
                    
                    const diamNote = params.mode === 'DIAMON' ? 'Programování průměru' : 'Programování poloměru';
                    addN(`${params.mode}${note('', diamNote)}`);

                    addN(`T="${params.toolName}" D1 M6${note('', 'Výměna nástroje')}`);
                    addN(`M3${note('', 'Vřeteno CW')}`);
                    addN(`M8${note('', 'Chlazení ZAP')}`);

                    // FIX: Safe parsing for radius
                    arcR = (r) => `CR=${(parseFloat(r) || 0).toFixed(3)}`;
                } else if (params.controlSystem === 'fanuc') {
                    addCmt(`Vygenerovaný kód FANUC`);
                    addCmt(`Datum: ${d.toLocaleDateString()}`);
                    addN(`G21${note('', 'Metrický vstup')}`);
                    addN(`G40${note('', 'Zrušení kompenzace')}`);
                    addN(`G99${note('', 'Posuv mm/ot')}`);
                    addN(`G18${note('', 'Rovina ZX')}`);
                    addN(`G28 U0 W0${note('', 'Referenční bod')}`);
                    addN(`G50 S2000${note('', 'Max otáčky')}`);
                    addN(`G96 S${params.speed} M3${note('', 'Konst. řezná rychlost')}`);
                    addN(`T0101${note('', 'Nástroj 1 / Korekce 1')}`);
                    addN(`M8${note('', 'Chlazení ZAP')}`);
                    // FIX: Safe parsing for radius
                    arcR = (r) => `R${(parseFloat(r) || 0).toFixed(3)}`;
                } else if (params.controlSystem === 'heidenhain') {
                    addCmt(`Vygenerovaný kód HEIDENHAIN ISO`);
                    addCmt(`Datum: ${d.toLocaleDateString()}`);
                    addN(`G18${note('', 'Rovina ZX')}`);
                    addN(`G90${note('', 'Absolutní')}`);
                    addN(`G71${note('', 'Metrický systém')}`);
                    addN(`G54${note('', 'Nulový bod')}`);
                    addN(`G96 S${params.speed} M3${note('', 'Řezná rychlost')}`);
                    addN(`T1 M6${note('', 'Nástroj')}`);
                    addN(`M8`);
                    // FIX: Safe parsing for radius
                    arcR = (r) => `R${(parseFloat(r) || 0).toFixed(3)}`;
                }
                
                let simCounter = 0; 
                addN(`G0 X${params.safeX} Z${params.safeZ}${note('', 'Rychloposuv')}`, 0); 

                const rDist = calculatedData.retractDist || 2.0;

                addCmt(`--- HRUBOVANI (${params.roughingStrategy === 'face' ? 'CELNI' : 'PODELNE'}) ---`);
                
                calculatedData.passes.forEach((pass, i) => {
                    addCmt(`Průchod ${i+1}`);
                    if (pass.type === 'long') {
                        const xVal = params.mode === 'DIAMON' ? (pass.x * 2).toFixed(3) : pass.x.toFixed(3);
                        const xRetract = params.mode === 'DIAMON' ? ((pass.x + rDist) * 2).toFixed(3) : (pass.x + rDist).toFixed(3);
                        simCounter += 1; addN(`G0 X${xRetract} Z${(pass.zStart + 1).toFixed(3)}`, simCounter);
                        // FIX: Restored increment to ensure 1:1 mapping with simPath
                        simCounter += 1; addN(`G1 X${xVal} F${params.feed}`, simCounter); 
                        simCounter += 1; addN(`G1 Z${pass.zEnd.toFixed(3)}`, simCounter);
                        simCounter += 1; addN(`G1 X${xRetract} Z${(pass.zEnd + rDist).toFixed(3)}`, simCounter);
                        simCounter += 1; addN(`G0 Z${(pass.zStart + 1).toFixed(3)}`, simCounter);
                    } else {
                        const zVal = pass.z.toFixed(3);
                        const zRetract = (pass.z + rDist).toFixed(3);
                        const xStart = params.mode === 'DIAMON' ? (pass.xStart * 2).toFixed(3) : pass.xStart.toFixed(3);
                        const xEnd = params.mode === 'DIAMON' ? (pass.xEnd * 2).toFixed(3) : pass.xEnd.toFixed(3);
                        const xEndRetract = params.mode === 'DIAMON' ? ((pass.xEnd + rDist) * 2).toFixed(3) : (pass.xEnd + rDist).toFixed(3);
                        simCounter += 1; addN(`G0 X${xStart} Z${zRetract}`, simCounter);
                        // FIX: Restored increment to ensure 1:1 mapping with simPath
                        simCounter += 1; addN(`G1 Z${zVal} F${params.feed}`, simCounter);
                        simCounter += 1; addN(`G1 X${xEnd}`, simCounter);
                        simCounter += 1; addN(`G1 X${xEndRetract} Z${zRetract}`, simCounter);
                        simCounter += 1; addN(`G0 X${xStart}`, simCounter);
                    }
                });

                simCounter += 1;
                addN(`G0 X${params.safeX} Z${params.safeZ}`, simCounter);

                if (params.doFinishing && calculatedData.finishOffsetPath.length > 0) {
                    addCmt(`--- DOKONCOVANI ---`);
                    const startSeg = calculatedData.finishOffsetPath[0];
                    // FIX: Swapped cos/sin to match atan2(x,z) logic where X=Sin, Z=Cos
                    const sX = startSeg.type === 'line' ? startSeg.p1.x : (startSeg.cx + Math.sin(startSeg.startAngle)*startSeg.r);
                    const sZ = startSeg.type === 'line' ? startSeg.p1.z : (startSeg.cz + Math.cos(startSeg.startAngle)*startSeg.r);
                    const sX_out = params.mode === 'DIAMON' ? (sX * 2).toFixed(3) : sX.toFixed(3);
                    simCounter += 1; addN(`G0 X${sX_out} Z${sZ.toFixed(3)}`, simCounter);
                    simCounter += 1; addN(`G1 X${sX_out} Z${sZ.toFixed(3)}`, simCounter); 

                    calculatedData.finishOffsetPath.forEach(seg => {
                        if(seg.isDegenerate) return;
                        if (seg.type === 'line') {
                             const eX = params.mode === 'DIAMON' ? (seg.p2.x * 2).toFixed(3) : seg.p2.x.toFixed(3);
                             simCounter += 1;
                             addN(`G1 X${eX} Z${seg.p2.z.toFixed(3)}`, simCounter);
                        } else {
                             simCounter += 10;
                             // FIX: Swapped cos/sin to match atan2(x,z) logic where X=Sin, Z=Cos
                             const eX = params.mode === 'DIAMON' ? ((seg.cx + Math.sin(seg.endAngle)*seg.r) * 2).toFixed(3) : (seg.cx + Math.sin(seg.endAngle)*seg.r).toFixed(3);
                             const eZ = (seg.cz + Math.cos(seg.endAngle)*seg.r).toFixed(3);
                             addN(`${seg.dir} X${eX} Z${eZ} ${arcR(seg.r)} ${seg.isCornerRoll ? cmt('Obeplutí rohu') : ''}`, simCounter);
                        }
                    });
                    simCounter += 2; 
                    addN(`G0 X${params.safeX} Z${params.safeZ}`, simCounter);
                }

                if (params.controlSystem === 'fanuc') {
                    addN(`M9`);
                    addN(`M5`);
                    addN(`G28 U0 W0`);
                    addN(`M30${note('', 'Konec programu')}`);
                } else if (params.controlSystem === 'heidenhain') {
                    addN(`M9`);
                    addN(`M5`);
                    addN(`M30`);
                } else {
                    addN(`M30${note('', 'Konec programu')}`);
                }
                
                addCmt(`--- KONTURA (Pro referenci) ---`);
                contourPoints.forEach(p => {
                    // FIX: Safe access to properties and radius to prevent crash
                    let line = `${p.type} X${(parseFloat(p.x)||0)} Z${(parseFloat(p.z)||0)}`;
                    if (p.type === 'G2' || p.type === 'G3') line += ` ${arcR(p.r)}`; 
                    addCmt(line); 
                });

                setGeneratedCode(lines);
            }, [calculatedData, params, contourPoints]);

            const handleLineClick = (simIdx) => {
                if (simIdx !== null && calculatedData.simPath.length > 0) {
                    const progress = simIdx / (calculatedData.simPath.length - 1);
                    setSimProgress(progress);
                }
            };
            
            const toggleSimulation = () => {
                if (simRunning) {
                    setSimRunning(false);
                } else {
                    if (simProgress >= 1) {
                        setSimProgress(0);
                    }
                    setSimRunning(true);
                }
            };

            const stopSimulation = () => {
                setSimRunning(false);
                setSimProgress(0);
            };
            
            useEffect(() => {
                if (!codeContainerRef.current) return;
                const activeEl = codeContainerRef.current.querySelector('.code-line.active');
                if (activeEl) {
                    activeEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }, [simProgress]);
            
            // New active line logic based on finding the next target index
            const currentSimIdx = Math.floor(simProgress * (calculatedData.simPath.length - 1));
            // Find the first line where the simulation index is GREATER than current index (Look Ahead)
            const activeLineIndex = generatedCode.findIndex(line => line.simIdx !== null && line.simIdx > currentSimIdx);
            // If we are at the end, default to the last line with an index
            const highlightIndex = activeLineIndex === -1 ? generatedCode.findLastIndex(l => l.simIdx !== null) : activeLineIndex;


            const draw = useCallback(() => {
                const canvas = canvasRef.current;
                const container = containerRef.current;
                if (!canvas || !container) return;
                
                const ctx = canvas.getContext('2d');
                const w = container.clientWidth;
                const h = container.clientHeight;
                if (canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h; }

                const colors = theme === 'dark' ? {
                    bg: '#111827', grid: '#374151', axis: '#ef4444', stock: '#9ca3af',
                    contour: '#3b82f6', offset: '#a855f7', pass: '#22c55e', finish: '#f472b6', error: '#ef4444', text: '#9ca3af', tool: '#facc15'
                } : {
                    bg: '#ffffff', grid: '#e5e7eb', axis: '#ef4444', stock: '#6b7280',
                    contour: '#2563eb', offset: '#9333ea', pass: '#16a34a', finish: '#db2777', error: '#ef4444', text: '#6b7280', tool: '#fbbf24'
                };

                ctx.fillStyle = colors.bg; ctx.fillRect(0, 0, w, h);
                const toScreen = (x, z) => {
                    // Guard against NaN
                    if(isNaN(x) || isNaN(z)) return {x:0, y:0};
                    
                    if (params.machineStructure === 'carousel') {
                        return { x: view.panX + x * view.scale, y: view.panY - z * view.scale };
                    } else {
                        return { x: view.panX + z * view.scale, y: view.panY - x * view.scale };
                    }
                };

                ctx.strokeStyle = colors.grid; ctx.lineWidth = 1; ctx.beginPath();
                
                ctx.fillStyle = theme === 'dark' ? '#6b7280' : '#9ca3af';
                ctx.font = "10px sans-serif";
                
                for (let i=-500; i<=500; i+=20) {
                     const p1 = toScreen(-500, i); const p2 = toScreen(500, i);
                     ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                     
                     const p3 = toScreen(i, -500); const p4 = toScreen(i, 500);
                     ctx.moveTo(p3.x, p3.y); ctx.lineTo(p4.x, p4.y);
                }
                ctx.stroke();

                for (let i=-500; i<=500; i+=20) {
                    if (i === 0) continue; 

                    const ptHoriz = toScreen(0, i); 
                    
                    if (params.machineStructure === 'carousel') {
                        const ptX = toScreen(i, 0); 
                        ctx.textAlign = "center"; 
                        ctx.textBaseline = "top";
                        ctx.fillText(i.toString(), ptX.x, ptX.y + 2);

                        const ptZ = toScreen(0, i); 
                        ctx.textAlign = "right"; 
                        ctx.textBaseline = "middle";
                        ctx.fillText(i.toString(), ptZ.x - 4, ptZ.y);
                    } else {
                        const ptZ = toScreen(0, i);
                        ctx.textAlign = "center"; 
                        ctx.textBaseline = "top";
                        ctx.fillText(i.toString(), ptZ.x, ptZ.y + 2);

                        const ptX = toScreen(i, 0);
                        ctx.textAlign = "right"; 
                        ctx.textBaseline = "middle";
                        ctx.fillText(i.toString(), ptX.x - 4, ptX.y);
                    }
                }

                const zero = toScreen(0,0);
                ctx.strokeStyle = colors.axis; ctx.lineWidth = 2; ctx.beginPath();
                ctx.moveTo(0, zero.y); ctx.lineTo(w, zero.y);
                ctx.moveTo(zero.x, 0); ctx.lineTo(zero.x, h);
                ctx.stroke();
                ctx.fillStyle = colors.axis; ctx.font = "bold 12px monospace";
                ctx.textAlign = "left"; ctx.textBaseline = "alphabetic";
                
                if (params.machineStructure === 'carousel') {
                    ctx.fillText("X+", w - 20, zero.y + 15); 
                    ctx.fillText("Z+", zero.x + 10, 15);
                } else {
                    ctx.fillText("Z+", w - 20, zero.y + 15); 
                    ctx.fillText("X+", zero.x + 10, 15);
                }
                ctx.fillText("X0 Z0", zero.x + 4, zero.y - 4); 

                if (params.stockMode === 'cylinder') {
                    const sRad = (parseFloat(params.stockDiameter) || 0)/2;
                    const sLen = parseFloat(params.stockLength) || 0;
                    const sFace = parseFloat(params.stockFace) || 0;
                    const s1 = toScreen(sRad, sFace); 
                    const s2 = toScreen(sRad, -sLen); 
                    const s3 = toScreen(0, -sLen);
                    const sStart = toScreen(0, sFace);
                    ctx.fillStyle = theme === 'dark' ? 'rgba(100,100,100,0.1)' : 'rgba(200,200,200,0.3)';
                    ctx.beginPath(); ctx.moveTo(sStart.x, sStart.y); ctx.lineTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.lineTo(s3.x, s3.y); ctx.fill();
                    ctx.strokeStyle = colors.stock; ctx.setLineDash([5, 5]); ctx.beginPath();
                    ctx.moveTo(sStart.x, sStart.y); ctx.lineTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.lineTo(s3.x, s3.y);
                    ctx.stroke(); ctx.setLineDash([]);
                } else if (calculatedData.stockPathSegments.length > 0) {
                    ctx.beginPath();
                    calculatedData.stockPathSegments.forEach((seg, i) => {
                        if (seg.type === 'line') {
                            const p1 = toScreen(seg.p1.x, seg.p1.z); const p2 = toScreen(seg.p2.x, seg.p2.z);
                            if (i === 0) ctx.moveTo(p1.x, p1.y); else ctx.lineTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                        } else if (seg.type === 'arc') {
                             const c = toScreen(seg.cx, seg.cz);
                             const sa_scr = -seg.startAngle; 
                             const steps = 15;
                             let sA = seg.startAngle;
                             let eA = seg.endAngle;
                             if (seg.dir === 'G2' && eA > sA) eA -= 2*Math.PI;
                             if (seg.dir === 'G3' && eA < sA) eA += 2*Math.PI;
                             
                             for(let j=0; j<=steps; j++) {
                                 const a = sA + (eA - sA) * (j/steps);
                                 const px = seg.cx + Math.sin(a) * seg.r;
                                 const pz = seg.cz + Math.cos(a) * seg.r;
                                 const pt = toScreen(px, pz);
                                 if (j === 0 && i === 0) ctx.moveTo(pt.x, pt.y);
                                 else if (j===0) ctx.moveTo(pt.x, pt.y); 
                                 else ctx.lineTo(pt.x, pt.y);
                             }
                        }
                    });
                    ctx.strokeStyle = colors.stock; ctx.setLineDash([4, 4]); ctx.lineWidth = 1; ctx.stroke(); ctx.setLineDash([]);
                }

                if (calculatedData.worldPoints.length > 0) {
                    ctx.beginPath();
                    const start = toScreen(calculatedData.worldPoints[0].xReal, calculatedData.worldPoints[0].zReal);
                    ctx.moveTo(start.x, start.y);
                    for (let i = 0; i < calculatedData.worldPoints.length - 1; i++) {
                        const p1 = calculatedData.worldPoints[i];
                        const p2 = calculatedData.worldPoints[i+1];
                        const ptEnd = toScreen(p2.xReal, p2.zReal);
                        
                        if (p2.type === 'G0' || p2.type === 'G1') {
                            ctx.lineTo(ptEnd.x, ptEnd.y);
                        } else if (p2.type === 'G2' || p2.type === 'G3') {
                            // Draw arc using native Canvas Arc
                            const arc = getArcParams({x:p1.xReal, z:p1.zReal}, {x:p2.xReal, z:p2.zReal}, p2.rVal, p2.type);
                            if (!arc.error) {
                                // Angles from center
                                const startAng = Math.atan2(p1.xReal - arc.cx, p1.zReal - arc.cz);
                                const endAng = Math.atan2(p2.xReal - arc.cx, p2.zReal - arc.cz);
                                const center = toScreen(arc.cx, arc.cz);
                                const rScreen = arc.r * view.scale;
                                
                                // Canvas angles are inverted because Y-axis is inverted relative to math Y (CNC X)
                                // CNC G2 (CW) -> Canvas CW (false)
                                // CNC G3 (CCW) -> Canvas CCW (true)
                                const counterClockwise = (p2.type === 'G3');
                                
                                // Also invert angles: +Angle in CNC is towards +X (Up). +Angle in Canvas is towards +Y (Down).
                                // So angle_canvas = -angle_cnc
                                if(!isNaN(center.x) && !isNaN(center.y) && !isNaN(rScreen)) {
                                    ctx.arc(center.x, center.y, rScreen, -startAng, -endAng, counterClockwise);
                                } else {
                                    ctx.lineTo(ptEnd.x, ptEnd.y);
                                }
                            } else {
                                ctx.lineTo(ptEnd.x, ptEnd.y);
                            }
                        }
                    }
                    ctx.strokeStyle = colors.contour; ctx.lineWidth = 3; ctx.stroke();
                }

                if (calculatedData.offsetPath.length > 0) {
                    ctx.beginPath();
                    calculatedData.offsetPath.forEach((seg, i) => {
                        if(seg.isDegenerate) return;
                        if (seg.type === 'line') {
                            const p1 = toScreen(seg.p1.x, seg.p1.z); const p2 = toScreen(seg.p2.x, seg.p2.z);
                            if (i === 0) ctx.moveTo(p1.x, p1.y); else ctx.lineTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                        } else if (seg.type === 'arc') {
                             const center = toScreen(seg.cx, seg.cz);
                             const rScreen = seg.r * view.scale;
                             const counterClockwise = (seg.dir === 'G3');
                             if(!isNaN(center.x))
                                ctx.arc(center.x, center.y, rScreen, -seg.startAngle, -seg.endAngle, counterClockwise);
                        }
                    });
                    ctx.strokeStyle = colors.offset; ctx.lineWidth = 1; ctx.setLineDash([2,2]); ctx.stroke(); ctx.setLineDash([]);
                }
                
                if (params.doFinishing && calculatedData.finishOffsetPath.length > 0) {
                    ctx.beginPath();
                    calculatedData.finishOffsetPath.forEach((seg, i) => {
                        if(seg.isDegenerate) return;
                        if (seg.type === 'line') {
                            const p1 = toScreen(seg.p1.x, seg.p1.z); 
                            const p2 = toScreen(seg.p2.x, seg.p2.z);
                            if (i === 0) ctx.moveTo(p1.x, p1.y);
                            if (i > 0) ctx.lineTo(p1.x, p1.y); 
                            else ctx.moveTo(p1.x, p1.y);
                            
                            ctx.lineTo(p2.x, p2.y);
                        } else if (seg.type === 'arc') {
                             const center = toScreen(seg.cx, seg.cz);
                             const rScreen = seg.r * view.scale;
                             const counterClockwise = (seg.dir === 'G3');
                             const startX = center.x + rScreen * Math.cos(-seg.startAngle);
                             const startY = center.y + rScreen * Math.sin(-seg.startAngle);
                             if(i===0) ctx.moveTo(startX, startY);
                             else ctx.lineTo(startX, startY);
                             
                             if(!isNaN(center.x))
                                ctx.arc(center.x, center.y, rScreen, -seg.startAngle, -seg.endAngle, counterClockwise);
                        }
                    });
                    ctx.strokeStyle = colors.finish; ctx.lineWidth = 2; ctx.stroke();
                }

                ctx.beginPath();
                calculatedData.passes.forEach(pass => {
                    if (pass.type === 'long') {
                        const p1 = toScreen(pass.x, pass.zStart); const p2 = toScreen(pass.x, pass.zEnd);
                        ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                    } else {
                        const p1 = toScreen(pass.xStart, pass.z); const p2 = toScreen(pass.xEnd, pass.z);
                        ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                    }
                });
                ctx.strokeStyle = colors.pass; ctx.lineWidth = 1.5; ctx.stroke();

                if (calculatedData.simPath.length > 0) {
                    ctx.beginPath();
                    for (let i = 0; i < calculatedData.simPath.length - 1; i++) {
                        const p1 = calculatedData.simPath[i];
                        const p2 = calculatedData.simPath[i+1];
                        if (p2.type === 'G0') {
                            const s = toScreen(p1.x, p1.z);
                            const e = toScreen(p2.x, p2.z);
                            if (Math.abs(s.x - e.x) > 0.1 || Math.abs(s.y - e.y) > 0.1) {
                                ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y);
                            }
                        }
                    }
                    ctx.strokeStyle = theme === 'dark' ? '#ef4444' : '#ef4444'; ctx.lineWidth = 1.5; 
                    ctx.setLineDash([6, 6]); ctx.stroke(); ctx.setLineDash([]);
                }

                if ((simRunning || simProgress > 0) && calculatedData.simPath.length > 0) {
                    const totalPoints = calculatedData.simPath.length;
                    const floatIndex = simProgress * (totalPoints - 1);
                    const idx = Math.floor(floatIndex);
                    const t = floatIndex - idx;
                    const pCurrent = calculatedData.simPath[idx];
                    
                    if (pCurrent) {
                        const pNext = calculatedData.simPath[Math.min(idx + 1, totalPoints - 1)] || pCurrent;
                        const curX = pCurrent.x + (pNext.x - pCurrent.x) * t;
                        const curZ = pCurrent.z + (pNext.z - pCurrent.z) * t;
                        const pt = toScreen(curX, curZ);
                        
                        const tRad = parseFloat(params.toolRadius) || 0.8;
                        const rPix = tRad * view.scale; 

                        ctx.fillStyle = colors.tool; 
                        ctx.strokeStyle = theme === 'dark' ? '#000' : '#000'; 
                        ctx.lineWidth = 1;

                        if (params.toolShape === 'round') {
                            ctx.beginPath();
                            ctx.arc(pt.x, pt.y, rPix, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                        } else if (params.toolShape === 'polygon') {
                            const lenPix = (parseFloat(params.toolLength) || 10) * view.scale;
                            const rotRad = -(parseFloat(params.toolAngle) || 0) * (Math.PI / 180);
                            const tipAng = (parseFloat(params.toolTipAngle) || 90) * (Math.PI / 180);

                            const a1 = rotRad; 
                            const a2 = rotRad - tipAng; 

                            const distToCorner = rPix / Math.sin(tipAng / 2);
                            
                            const bisector = (a1 + a2) / 2;
                            const cornerX = Math.cos(bisector + Math.PI) * distToCorner;
                            const cornerY = Math.sin(bisector + Math.PI) * distToCorner;

                            ctx.save();
                            ctx.translate(pt.x, pt.y); // Move to circle center
                            
                            ctx.beginPath();
                            ctx.moveTo(cornerX, cornerY);
                            
                            const x1 = cornerX + Math.cos(a1) * lenPix;
                            const y1 = cornerY + Math.sin(a1) * lenPix;
                            ctx.lineTo(x1, y1);
                            
                            const x2 = cornerX + Math.cos(a2) * lenPix;
                            const y2 = cornerY + Math.sin(a2) * lenPix;
                            ctx.lineTo(x2, y2);
                            
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            
                            ctx.restore();
                            
                            ctx.beginPath(); ctx.arc(pt.x, pt.y, rPix, 0, Math.PI * 2); ctx.stroke();
                        }
                        
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(pt.x, pt.y, 1, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                if (!simRunning) {
                    const activePoints = editMode === 'contour' ? calculatedData.worldPoints : calculatedData.stockWorldPoints;
                    ctx.font = "bold 11px sans-serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                    if(activePoints) {
                        activePoints.forEach((p, i) => {
                            if (!p) return;
                            const pt = toScreen(p.xReal, p.zReal);
                            
                            const isHovered = (i === hoverPointId);
                            const isDragged = (i === draggedPointId);
                            const radius = (isHovered || isDragged) ? 8 : 4; 

                            ctx.fillStyle = editMode === 'contour' ? colors.contour : colors.pass;
                            if (isHovered || isDragged) ctx.fillStyle = '#f59e0b'; 

                            ctx.beginPath(); 
                            ctx.arc(pt.x, pt.y, radius, 0, Math.PI*2); 
                            ctx.fill();
                            
                            if (!isHovered && !isDragged) {
                                const label = `${i+1}`; 
                                const tx = pt.x + 8; const ty = pt.y - 8;
                                ctx.fillStyle = theme === 'dark' ? '#fbbf24' : '#d97706'; 
                                ctx.fillText(label, tx, ty);
                            }
                        });
                    }
                }

            }, [calculatedData, view, theme, params, editMode, mobileTab, simRunning, simProgress, draggedPointId, hoverPointId]);

            useEffect(() => {
                if (!containerRef.current || !canvasRef.current) return;
                const resizeObserver = new ResizeObserver(() => { draw(); });
                resizeObserver.observe(containerRef.current);
                return () => resizeObserver.disconnect();
            }, [draw]);

            // Handlers ... (same)
            const handleWheel = (e) => { const s = Math.max(0.2, Math.min(view.scale * (1 - Math.sign(e.deltaY)*0.15), 50)); setView(v => ({...v, scale: s})); };
            
            const getPointAt = (clientX, clientY) => {
                if (!canvasRef.current || simRunning) return null;
                const rect = canvasRef.current.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                
                const activePoints = editMode === 'contour' ? calculatedData.worldPoints : calculatedData.stockWorldPoints;
                if (!activePoints) return null;

                const threshold = 15; 

                const toScreen = (xReal, zReal) => {
                     if (params.machineStructure === 'carousel') {
                        return { x: view.panX + xReal * view.scale, y: view.panY - zReal * view.scale };
                    } else {
                        return { x: view.panX + zReal * view.scale, y: view.panY - xReal * view.scale };
                    }
                };

                for (let i = 0; i < activePoints.length; i++) {
                    const p = activePoints[i];
                    if (!p) continue;
                    const pt = toScreen(p.xReal, p.zReal);
                    const d = Math.hypot(pt.x - x, pt.y - y);
                    if (d < threshold) return i;
                }
                return null;
            };

            const handleInsertAfter = (index) => {
                 pushHistory();
                 const list = editMode === 'contour' ? contourPoints : stockPoints; 
                 const setList = editMode === 'contour' ? setContourPoints : setStockPoints; 
                 const prev = list[index]; 
                 const newPoint = { ...prev, id: Date.now(), z: parseFloat(prev.z) - 5 }; 
                 const newList = [...list]; 
                 newList.splice(index + 1, 0, newPoint); 
                 setList(newList);
                 
                 setActiveTab('editor');
                 setMobileTab('editor');
            };

            const handleMouseDown = (e) => { 
                const pointIdx = getPointAt(e.clientX, e.clientY);
                
                if (addPointMode) {
                    if (pointIdx !== null) {
                        handleInsertAfter(pointIdx);
                        setAddPointMode(false); 
                    }
                    return; 
                }

                if (pointIdx !== null) {
                    pushHistory(); 
                    setDraggedPointId(pointIdx);
                    setIsDragging(true); 
                } else {
                    setIsDragging(true); 
                }
                lastMousePos.current = { x: e.clientX, y: e.clientY }; 
            };

            const handleMouseMove = (e) => {
                const pointIdx = getPointAt(e.clientX, e.clientY);
                
                if (addPointMode) {
                    if (canvasRef.current) canvasRef.current.style.cursor = pointIdx !== null ? 'pointer' : 'copy'; 
                    setHoverPointId(pointIdx);
                    return; 
                }

                if (!isDragging) {
                    setHoverPointId(pointIdx);
                    if (canvasRef.current) canvasRef.current.style.cursor = pointIdx !== null ? 'move' : 'crosshair';
                }

                if (!isDragging) return;

                const dx = e.clientX - lastMousePos.current.x; 
                const dy = e.clientY - lastMousePos.current.y;
                lastMousePos.current = { x: e.clientX, y: e.clientY };

                if (draggedPointId !== null) {
                    let dX_unit = 0;
                    let dZ_unit = 0;

                    if (params.machineStructure === 'carousel') {
                        dX_unit = dx / view.scale;
                        dZ_unit = -dy / view.scale;
                    } else {
                        dZ_unit = dx / view.scale;
                        dX_unit = -dy / view.scale; 
                    }

                    const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                    
                    setList(prev => {
                        const newList = [...prev];
                        const pt = {...newList[draggedPointId]};
                        pt.x = parseFloat(pt.x) + dX_unit;
                        pt.z = parseFloat(pt.z) + dZ_unit;
                        newList[draggedPointId] = pt;
                        return newList;
                    });

                } else {
                    setView(v => ({ ...v, panX: v.panX + dx, panY: v.panY + dy }));
                }
            };
            
            const handleMouseUp = () => {
                 setIsDragging(false);
                 setDraggedPointId(null);
            };

            const handleTouchStart = (e) => {
                if (e.touches.length === 1) {
                    const t = e.touches[0];
                    const pointIdx = getPointAt(t.clientX, t.clientY);

                    if (addPointMode) {
                        if (pointIdx !== null) {
                            handleInsertAfter(pointIdx);
                            setAddPointMode(false);
                        }
                        return;
                    }

                    if (pointIdx !== null) {
                         pushHistory();
                         setDraggedPointId(pointIdx);
                         setIsDragging(true);
                    } else {
                         setIsDragging(true);
                    }
                    lastMousePos.current = { x: t.clientX, y: t.clientY };
                } else if (e.touches.length === 2) {
                    const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    lastPinchDist.current = dist;
                }
            };

            const handleTouchMove = (e) => {
                if (addPointMode) return; 

                if (isDragging && e.touches.length === 1) {
                    const t = e.touches[0];
                    const dx = t.clientX - lastMousePos.current.x;
                    const dy = t.clientY - lastMousePos.current.y;
                    lastMousePos.current = { x: t.clientX, y: t.clientY };

                    if (draggedPointId !== null) {
                         let dX_unit = 0; let dZ_unit = 0;
                         if (params.machineStructure === 'carousel') {
                            dX_unit = dx / view.scale; dZ_unit = -dy / view.scale;
                         } else {
                            dZ_unit = dx / view.scale; dX_unit = -dy / view.scale; 
                         }
                         const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                         setList(prev => {
                            const newList = [...prev];
                            const pt = {...newList[draggedPointId]};
                            pt.x = parseFloat(pt.x) + dX_unit;
                            pt.z = parseFloat(pt.z) + dZ_unit;
                            newList[draggedPointId] = pt;
                            return newList;
                        });
                    } else {
                        setView(v => ({ ...v, panX: v.panX + dx, panY: v.panY + dy }));
                    }
                }
                if (e.touches.length === 2 && lastPinchDist.current) {
                    const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    const zoomFactor = dist / lastPinchDist.current;
                    setView(v => { const newScale = Math.max(0.2, Math.min(v.scale * zoomFactor, 50)); return { ...v, scale: newScale }; });
                    lastPinchDist.current = dist;
                }
            };

            const handleTouchEnd = () => {
                setIsDragging(false);
                setDraggedPointId(null);
                lastPinchDist.current = null;
            };

            const processGCodeString = (text) => {
                pushHistory();
                const lines = text.split('\n'); const newPoints = []; let currentType = 'G1'; let idCounter = Date.now(); let lastX = 100; let lastZ = 0;
                lines.forEach(line => {
                    const clean = line.toUpperCase().trim(); if (!clean || clean.startsWith(';')) return;
                    const gMatch = clean.match(/G([0-3])/); if (gMatch) currentType = 'G' + gMatch[1];
                    const xMatch = clean.match(/X([-]?\d+\.?\d*)/); const zMatch = clean.match(/Z([-]?\d+\.?\d*)/); const rMatch = clean.match(/(?:R|CR=)([-]?\d+\.?\d*)/);
                    if (xMatch || zMatch) {
                        const newX = xMatch ? parseFloat(xMatch[1]) : lastX; const newZ = zMatch ? parseFloat(zMatch[1]) : lastZ;
                        newPoints.push({ id: idCounter++, type: currentType, x: newX, z: newZ, r: rMatch ? parseFloat(rMatch[1]) : 0, mode: 'ABS' });
                        lastX = newX; lastZ = newZ;
                    }
                });
                if (newPoints.length > 0) {
                    if (editMode === 'contour') setContourPoints(newPoints); else setStockPoints(newPoints); 
                    setErrors([]); fitView(); 
                } else alert("Nepodařilo se rozpoznat žádné body v G-kódu.");
            };
            const parseGCode = () => processGCodeString(gCodeInput);
            const handleCopyGCode = () => { /* ... same ... */ };
            const handleDownload = () => { /* ... same ... */ };
            
            const toggleMode = (id) => { 
                pushHistory();
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                setList(prev => prev.map(p => p.id===id ? {...p, mode: p.mode==='ABS'?'INC':'ABS'} : p));
            };
            
            const updatePoint = (id, f, v) => {
                pushHistory();
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                setList(prev => prev.map(p => p.id===id ? {...p, [f]: v} : p));
            };
            
            const addPoint = () => { 
                pushHistory();
                const list = editMode === 'contour' ? contourPoints : stockPoints; 
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints; 
                const last = list.length > 0 ? list[list.length - 1] : { x: 100, z: 0 }; 
                setList([...list, {id: Date.now(), type:'G1', x:last.x, z: parseFloat(last.z)-10, r:0, mode: 'ABS'}]); 
            };
            
            const insertPoint = (index) => { 
                pushHistory();
                const list = editMode === 'contour' ? contourPoints : stockPoints; 
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints; 
                const prev = list[index]; 
                const newPoint = { ...prev, id: Date.now(), z: parseFloat(prev.z) - 5 }; 
                const newList = [...list]; newList.splice(index + 1, 0, newPoint); 
                setList(newList); 
            };
            
            const removePoint = (id) => { 
                const list = editMode === 'contour' ? contourPoints : stockPoints; 
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints; 
                if (list.length > 1) {
                    pushHistory();
                    setList(list.filter(p=>p.id!==id)); 
                }
            };
            
            const currentPoints = editMode === 'contour' ? contourPoints : stockPoints;

            return (
                <div className="flex flex-col md:flex-row h-full">
                    <div className={`${mobileTab === 'editor' ? 'flex' : 'hidden'} md:flex w-full md:w-96 flex-col border-r shadow-xl z-10 h-full overflow-hidden ${theme === 'dark' ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'}`}>
                        <div className={`p-4 border-b flex justify-between items-center ${theme === 'dark' ? 'bg-gray-900 border-gray-700' : 'bg-gray-100 border-gray-200'}`}>
                            <div className="flex items-center gap-2">
                                <h1 className="font-bold text-lg text-blue-500">Sinumerik CAM <span className="text-xs text-gray-400 font-normal">v1.5</span></h1>
                                <div className="flex gap-1 ml-2">
                                    <button onClick={undo} disabled={past.length===0} className={`p-1 rounded ${past.length===0 ? 'text-gray-300' : 'text-gray-600 hover:bg-gray-200 dark:text-gray-400 dark:hover:bg-gray-700'}`} title="Zpět"><IconUndo /></button>
                                    <button onClick={redo} disabled={future.length===0} className={`p-1 rounded ${future.length===0 ? 'text-gray-300' : 'text-gray-600 hover:bg-gray-200 dark:text-gray-400 dark:hover:bg-gray-700'}`} title="Vpřed"><IconRedo /></button>
                                </div>
                            </div>
                            <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')} className="p-2 rounded hover:bg-gray-700 hover:text-white transition-colors">
                                {theme === 'light' ? <IconMoon /> : <IconSun />}
                            </button>
                        </div>
                        {errors.length > 0 && (
                            <div className="bg-red-50 border-l-4 border-red-500 text-red-700 p-2 text-xs">
                                <div className="font-bold flex gap-2 items-center"><IconWarning /> Nalezeny problémy:</div>
                                <ul className="list-disc pl-6 mt-1 space-y-1">{errors.map((e, i) => <li key={i}>{e.msg || e}</li>)}</ul>
                            </div>
                        )}
                        <div className="flex border-b border-gray-200 dark:border-gray-700">
                             {['editor', 'params', 'import', 'AI'].map(tab => (
                                <button key={tab} onClick={() => setActiveTab(tab)} 
                                    className={`flex-1 p-3 text-sm font-medium capitalize ${activeTab===tab ? 'bg-blue-100 text-blue-700' : 'text-gray-500'}`}>
                                    {tab === 'AI' ? (
                                        <div className="flex items-center justify-center gap-1">
                                            <IconVoiceChat /> Chat
                                        </div>
                                    ) : tab}
                                </button>
                            ))}
                        </div>
                         <div className="flex-1 overflow-y-auto p-4 custom-scrollbar pb-20 md:pb-4">
                            {activeTab === 'editor' && (
                                <div className="space-y-3">
                                    <div className="flex gap-2 mb-2 bg-gray-200 p-1 rounded dark:bg-gray-700">
                                        <button onClick={() => setEditMode('contour')} className={`flex-1 flex items-center justify-center gap-2 text-xs py-1.5 rounded font-bold transition-all ${editMode==='contour' ? 'bg-white shadow text-blue-600 dark:bg-gray-600 dark:text-blue-300' : 'text-gray-500 hover:text-gray-700'}`}><IconEdit /> Kontura</button>
                                        <button onClick={() => { setEditMode('stock'); if(stockPoints.length === 0) generateDefaultStock(); }} className={`flex-1 flex items-center justify-center gap-2 text-xs py-1.5 rounded font-bold transition-all ${editMode==='stock' ? 'bg-white shadow text-green-600 dark:bg-gray-600 dark:text-green-300' : 'text-gray-500 hover:text-gray-700'}`}><IconBox /> Polotovar</button>
                                    </div>
                                    <div className="flex gap-1 px-2 text-xs font-bold text-gray-500 mb-1">
                                        <div className="w-6 text-center">#</div>
                                        <div className="w-14">Typ</div>
                                        <div className="w-8 text-center">Mód</div>
                                        <div className="w-16 text-center">X/U</div>
                                        <div className="w-16 text-center">Z/W</div>
                                        <div className="w-10 text-center">R</div>
                                    </div>
                                    {currentPoints.map((p, index) => (
                                        <div key={p.id} className={`border rounded p-2 flex flex-wrap gap-1 items-center ${theme === 'dark' ? 'bg-gray-750 border-gray-600' : 'bg-gray-50 border-gray-300'} ${editMode==='stock' ? 'border-l-4 border-l-green-500' : 'border-l-4 border-l-blue-500'}`}>
                                            <div className="w-6 font-mono text-xs text-gray-500 font-bold">{index+1}</div>
                                            <select value={p.type} onChange={(e) => updatePoint(p.id, 'type', e.target.value)} className={`border rounded text-xs px-1 py-1 w-14 ${theme==='dark'?'bg-gray-900 border-gray-600':'bg-white border-gray-300'}`}><option>G0</option><option>G1</option><option>G2</option><option>G3</option></select>
                                            <button onClick={() => toggleMode(p.id)} className={`w-8 h-6 flex items-center justify-center rounded text-xs font-bold ${p.mode==='INC' ? 'bg-purple-100 text-purple-700 border border-purple-300' : 'bg-gray-100 text-gray-600 border border-gray-300'}`} title={p.mode === 'INC' ? 'Přírůstkově' : 'Absolutně'}>{p.mode === 'INC' ? 'INC' : 'ABS'}</button>
                                            <SmartInput type="number" value={p.x} onValueChange={(v) => updatePoint(p.id, 'x', v)} className={`border rounded text-sm w-16 px-1 py-1 ${theme==='dark'?'bg-gray-900 border-gray-600':'bg-white border-gray-300'}`} placeholder={p.mode==='INC' ? 'U' : 'X'} />
                                            <SmartInput type="number" value={p.z} onValueChange={(v) => updatePoint(p.id, 'z', v)} className={`border rounded text-sm w-16 px-1 py-1 ${theme==='dark'?'bg-gray-900 border-gray-600':'bg-white border-gray-300'}`} placeholder={p.mode==='INC' ? 'W' : 'Z'} />
                                            {(p.type === 'G2' || p.type === 'G3') && <SmartInput type="number" value={p.r} onValueChange={(v) => updatePoint(p.id, 'r', v)} className={`border rounded text-sm w-10 px-1 py-1 ${theme==='dark'?'bg-gray-900 border-gray-600':'bg-white border-gray-300'}`} placeholder="R" />}
                                            <div className="flex ml-auto gap-1">
                                                <button onClick={() => insertPoint(index)} className="text-blue-500 hover:text-blue-700 p-1" title="Vložit řádek za"><IconInsert /></button>
                                                <button onClick={() => removePoint(p.id)} className="text-red-400 hover:text-red-600 p-1" title="Smazat řádek"><IconTrash /></button>
                                            </div>
                                        </div>
                                    ))}
                                    <div className="grid grid-cols-2 gap-2">
                                        <button onClick={addPoint} className={`col-span-2 py-2 text-white rounded text-sm font-bold flex justify-center items-center gap-2 ${editMode==='stock'?'bg-green-600 hover:bg-green-500':'bg-blue-600 hover:bg-blue-500'}`}><IconPlus /> Přidat bod</button>
                                        <button onClick={handleCopyGCode} className={`py-2 text-white rounded text-sm font-bold flex justify-center items-center gap-2 transition-all ${copyFeedback ? 'bg-green-600' : 'bg-gray-600 hover:bg-gray-500'}`}><IconClipboard /> {copyFeedback ? "Zkopírováno" : "Kopírovat"}</button>
                                        <button onClick={handleDownload} className="py-2 text-white rounded text-sm font-bold flex justify-center items-center gap-2 bg-purple-600 hover:bg-purple-500"><IconDownload /> Uložit MPF</button>
                                        <button onClick={handleExportPDF} className="py-2 text-white rounded text-sm font-bold flex justify-center items-center gap-2 bg-indigo-600 hover:bg-indigo-500"><IconFileText /> Export PDF</button>
                                    </div>
                                </div>
                            )}
                             {activeTab === 'params' && (
                                <div className="space-y-4">
                                    <h3 className={`font-bold border-b pb-1 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Konfigurace</h3>
                                    <div className="flex gap-2 mb-2">
                                        <button onClick={() => setParams({...params, machineStructure: 'lathe'})} className={`flex-1 py-1 text-xs border rounded flex items-center justify-center gap-1 ${params.machineStructure==='lathe' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Soustruh</button>
                                        <button onClick={() => setParams({...params, machineStructure: 'carousel'})} className={`flex-1 py-1 text-xs border rounded flex items-center justify-center gap-1 ${params.machineStructure==='carousel' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Karusel</button>
                                    </div>

                                    <h3 className={`font-bold border-b pb-1 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Řídicí systém</h3>
                                    <div className="flex gap-1 mb-2">
                                        <button onClick={() => setParams({...params, controlSystem: 'sinumerik'})} className={`flex-1 py-1 text-[10px] border rounded flex items-center justify-center gap-1 ${params.controlSystem==='sinumerik' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Sinumerik</button>
                                        <button onClick={() => setParams({...params, controlSystem: 'fanuc'})} className={`flex-1 py-1 text-[10px] border rounded flex items-center justify-center gap-1 ${params.controlSystem==='fanuc' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Fanuc</button>
                                        <button onClick={() => setParams({...params, controlSystem: 'heidenhain'})} className={`flex-1 py-1 text-[10px] border rounded flex items-center justify-center gap-1 ${params.controlSystem==='heidenhain' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Heidenhain</button>
                                    </div>

                                    <h3 className={`font-bold border-b pb-1 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Polotovar</h3>
                                    <div className="flex gap-2 mb-2">
                                        <button onClick={() => setParams({...params, stockMode: 'cylinder'})} className={`flex-1 py-1 text-xs border rounded ${params.stockMode==='cylinder' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Válec</button>
                                        <button onClick={() => { setParams({...params, stockMode: 'casting'}); setActiveTab('editor'); setEditMode('stock'); if(stockPoints.length === 0) generateDefaultStock(); }} className={`flex-1 py-1 text-xs border rounded ${params.stockMode==='casting' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Vlastní tvar</button>
                                    </div>
                                    {params.stockMode === 'cylinder' ? (
                                        <div className="space-y-2">
                                            <div className="flex items-end gap-2">
                                                <div className="flex-1"><label className="text-xs text-gray-500">Průměr (D)</label><SmartInput type="number" value={params.stockDiameter} onValueChange={v=>setParams({...params, stockDiameter:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                                <div className="flex-1"><label className="text-xs text-gray-500">Délka (Z-)</label><SmartInput type="number" value={params.stockLength} onValueChange={v=>setParams({...params, stockLength:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                            </div>
                                            <div className="flex items-end gap-2">
                                                <div className="flex-1"><label className="text-xs text-gray-500">Přídavek čelo (Z+)</label><SmartInput type="number" value={params.stockFace} onValueChange={v=>setParams({...params, stockFace:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                                <div className="flex-1"><label className="text-xs text-gray-500">Přídavek (pro Auto)</label><SmartInput type="number" value={params.stockMargin} onValueChange={v=>setParams({...params, stockMargin:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                            </div>
                                            <button onClick={handleAutoStock} className="w-full py-1.5 bg-indigo-600 text-white rounded text-xs font-bold flex items-center justify-center gap-1 hover:bg-indigo-500"><IconMagic /> Auto-rozměr</button>
                                        </div>
                                    ) : (
                                        <div className="text-xs text-gray-500 italic p-2 bg-gray-100 rounded dark:bg-gray-800">Pro definici tvarového polotovaru (odlitku) použijte přepínač "Polotovar" v záložce <b>Editor</b> a nakreslete jeho tvar.</div>
                                    )}
                                    
                                    <h3 className={`font-bold border-b pb-1 mt-4 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Bezpečná poloha (Nájezd)</h3>
                                    <div className="flex gap-2 mb-2">
                                        <div className="flex-1"><label className="text-xs text-gray-500">X (Průměr)</label><SmartInput type="number" value={params.safeX} onValueChange={v=>setParams({...params, safeX:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                        <div className="flex-1"><label className="text-xs text-gray-500">Z</label><SmartInput type="number" value={params.safeZ} onValueChange={v=>setParams({...params, safeZ:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                    </div>

                                    <h3 className={`font-bold border-b pb-1 mt-4 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Hrubování</h3>
                                    <div className="flex gap-2 mb-2">
                                        <button onClick={() => setParams({...params, roughingStrategy: 'longitudinal', toolAngle: 15})} className={`flex-1 py-1 text-xs border rounded flex items-center justify-center gap-1 ${params.roughingStrategy==='longitudinal' ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-700'}`}><IconArrowRight /> Podélně (Z)</button>
                                        <button onClick={() => setParams({...params, roughingStrategy: 'face', toolAngle: -15})} className={`flex-1 py-1 text-xs border rounded flex items-center justify-center gap-1 ${params.roughingStrategy==='face' ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-700'}`}><IconArrowDown /> Čelně (X)</button>
                                    </div>
                                    <div className="grid grid-cols-2 gap-2">
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Hloubka (ap)</label><SmartInput type="number" step="0.5" value={params.depthOfCut} onValueChange={v=>setParams({...params, depthOfCut:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Posuv (F)</label><SmartInput type="number" step="0.05" value={params.feed} onValueChange={v=>setParams({...params, feed:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                        <div className="flex flex-col col-span-2"><label className="text-xs text-gray-500">Odskok (G1 -> G0)</label><SmartInput type="number" step="0.5" value={params.retractDistance} onValueChange={v=>setParams({...params, retractDistance:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                    </div>
                                    <h3 className={`font-bold border-b pb-1 mt-4 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Nástroj</h3>
                                    <div className="grid grid-cols-2 gap-2">
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Rádius (R)</label><SmartInput type="number" step="0.1" value={params.toolRadius} onValueChange={v=>setParams({...params, toolRadius:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Přídavek X</label><SmartInput type="number" step="0.1" value={params.allowanceX} onValueChange={v=>setParams({...params, allowanceX:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Přídavek Z</label><SmartInput type="number" step="0.1" value={params.allowanceZ} onValueChange={v=>setParams({...params, allowanceZ:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                    </div>
                                    {/* Tool Shape Selector */}
                                    <div className="mt-2">
                                        <label className="text-xs text-gray-500 mb-1 block">Tvar destičky</label>
                                        <div className="flex gap-1">
                                            <button onClick={() => setParams({...params, toolShape: 'round'})} className={`flex-1 py-1 border rounded flex items-center justify-center gap-1 ${params.toolShape==='round' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`} title="Kulatá"><IconShapeCircle /></button>
                                            <button onClick={() => setParams({...params, toolShape: 'polygon', toolTipAngle: 90})} className={`flex-1 py-1 border rounded flex items-center justify-center gap-1 ${params.toolShape==='polygon' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`} title="Hranatá"><IconShapePolygon /></button>
                                        </div>
                                        {params.toolShape === 'polygon' && (
                                            <div className="flex gap-2 mt-2">
                                                <div className="flex-1"><label className="text-xs text-gray-500">Délka hrany (L)</label><SmartInput type="number" value={params.toolLength} onValueChange={v=>setParams({...params, toolLength:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                                <div className="flex-1"><label className="text-xs text-gray-500">Natočení (°)</label><SmartInput type="number" value={params.toolAngle} onValueChange={v=>setParams({...params, toolAngle:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                                <div className="flex-1"><label className="text-xs text-gray-500">Vrcholový úhel (ε)</label><SmartInput type="number" value={params.toolTipAngle} onValueChange={v=>setParams({...params, toolTipAngle:v})} className={`border rounded px-2 py-1 w-full text-sm ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-gray-900'}`}/></div>
                                            </div>
                                        )}
                                    </div>
                                    <div className="mt-4 pt-2 border-t dark:border-gray-700">
                                        <label className="flex items-center space-x-2 cursor-pointer">
                                            <input type="checkbox" checked={params.doFinishing} onChange={e => setParams({...params, doFinishing: e.target.checked})} className="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600" />
                                            <span className="text-sm font-bold text-gray-700 dark:text-gray-300">Dokončovací operace (Na čisto)</span>
                                        </label>
                                        <p className="text-xs text-gray-500 mt-1 pl-6">Vygeneruje dráhu nástroje přesně po kontuře (pouze s korekcí R, bez přídavku).</p>
                                    </div>
                                    
                                    <div className="mt-8 pt-4 border-t dark:border-gray-700 flex justify-center">
                                        <button onClick={handleResetApp} className="text-xs text-red-500 hover:text-red-700 flex items-center gap-1">
                                            <IconRefresh /> Resetovat vše (Vymazat uložené)
                                        </button>
                                    </div>
                                </div>
                            )}
                            {activeTab === 'AI' && (
                                <AiAssistant 
                                    contourPoints={contourPoints} 
                                    stockPoints={stockPoints} 
                                    params={params} 
                                    onUpdateContour={(pts) => {
                                        // Auto-add IDs if missing from AI
                                        const newPts = pts.map((p, i) => ({...p, id: p.id || Date.now() + i}));
                                        pushHistory();
                                        setContourPoints(newPts);
                                        setActiveTab('editor');
                                        setEditMode('contour');
                                    }}
                                    theme={theme}
                                />
                            )}
                             {activeTab === 'import' && (
                                <div className="flex flex-col h-full">
                                    <textarea className="flex-1 border p-2 font-mono text-xs mb-2" value={gCodeInput} onChange={e=>setGCodeInput(e.target.value)} placeholder="G1 X... Z..."></textarea>
                                    <button onClick={parseGCode} className="bg-green-600 text-white py-2 rounded">Import</button>
                                </div>
                            )}
                        </div>
                    </div>

                     <div className={`${mobileTab === 'preview' ? 'flex' : 'hidden'} md:flex flex-1 flex-col relative pb-20 md:pb-0 ${theme === 'dark' ? 'bg-gray-900' : 'bg-gray-50'}`}>
                        <div className="absolute top-4 right-4 z-10 flex gap-2">
                            <div className="bg-white p-1 rounded shadow flex gap-1 items-center">
                                <button onClick={toggleSimulation} className={`p-1 rounded hover:bg-green-100 ${simRunning ? 'text-green-600' : 'text-gray-600'}`} title={simRunning ? "Pauza" : "Spustit"}>
                                    {simRunning ? <IconPause /> : <IconPlay />}
                                </button>
                                <button onClick={stopSimulation} className="p-1 rounded hover:bg-red-100 text-gray-600" title="Stop"><IconStop /></button>
                            </div>
                            
                            <div className="bg-white p-1 rounded shadow flex gap-1 items-center">
                                <button 
                                    onClick={() => setAddPointMode(!addPointMode)} 
                                    className={`p-1 rounded hover:bg-blue-100 ${addPointMode ? 'text-blue-600 bg-blue-50' : 'text-gray-600'}`} 
                                    title="Vložit za bod"
                                >
                                    <IconPlusCircle />
                                </button>
                            </div>

                            <button onClick={fitView} className="bg-white p-2 rounded shadow text-gray-700 hover:text-blue-600" title="Centrovat pohled"><IconTarget /></button>
                        </div>
                        <div ref={containerRef} className={`flex-1 overflow-hidden relative canvas-container`}
                             onWheel={handleWheel} 
                             onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp}
                             onTouchStart={handleTouchStart} onTouchMove={handleTouchMove} onTouchEnd={handleTouchEnd}>
                            <canvas ref={canvasRef} className="block" />
                        </div>
                        <div ref={codeContainerRef} className={`h-48 border-t flex flex-col overflow-y-auto ${theme === 'dark' ? 'bg-gray-950 border-gray-700' : 'bg-white border-gray-300'}`}>
                             {/* nahrazeno textarea za interaktivní seznam */}
                             <div className="font-mono text-xs p-2">
                                {generatedCode.map((line, idx) => (
                                    <div 
                                        key={idx} 
                                        onClick={() => handleLineClick(line.simIdx)}
                                        className={`code-line whitespace-pre px-2 py-0.5 cursor-pointer ${idx === highlightIndex ? 'active' : ''} ${theme === 'dark' ? 'text-green-300' : 'text-gray-800'}`}
                                    >
                                        {line.text}
                                    </div>
                                ))}
                             </div>
                        </div>
                    </div>

                    <div className="md:hidden fixed bottom-0 left-0 right-0 h-16 bg-white border-t border-gray-200 flex z-50 safe-pb dark:bg-gray-900 dark:border-gray-700">
                        <button onClick={() => setMobileTab('editor')} className={`flex-1 flex flex-col items-center justify-center ${mobileTab==='editor' ? 'text-blue-600' : 'text-gray-500'}`}>
                            <IconEdit />
                            <span className="text-xs font-bold mt-1">Editor</span>
                        </button>
                        <button onClick={() => setMobileTab('preview')} className={`flex-1 flex flex-col items-center justify-center ${mobileTab==='preview' ? 'text-blue-600' : 'text-gray-500'}`}>
                            <IconEye />
                            <span className="text-xs font-bold mt-1">Náhled</span>
                        </button>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
