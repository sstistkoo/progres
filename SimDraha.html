<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Generátor CAM pro Sinumerik 840D (Auto-Trim)</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel Standalone -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { overscroll-behavior: none; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #9ca3af; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        .canvas-container { cursor: crosshair; touch-action: none; background-image: radial-gradient(#ccc 1px, transparent 1px); background-size: 20px 20px; }
        .dark .canvas-container { background-image: radial-gradient(#333 1px, transparent 1px); }
        .safe-pb { padding-bottom: env(safe-area-inset-bottom); }
        /* Styl pro aktivní řádek kódu */
        .code-line.active { background-color: rgba(59, 130, 246, 0.2); font-weight: bold; border-left: 3px solid #3b82f6; }
        .dark .code-line.active { background-color: rgba(59, 130, 246, 0.3); border-left: 3px solid #60a5fa; }
    </style>
</head>
<body class="h-[100dvh] w-screen overflow-hidden flex flex-col font-sans transition-colors duration-300">

    <div id="root" class="h-full w-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        // --- ICONS ---
        const IconTrash = () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;
        const IconPlus = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>;
        const IconSun = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>;
        const IconMoon = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>;
        const IconEdit = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path></svg>;
        const IconBox = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>;
        const IconMagic = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><path d="m12 2 2.5 5.5L20 9l-4 3.5L17.5 18 12 15l-5.5 3L8 12.5 4 9l5.5-1.5L12 2z"></path></svg>;
        const IconClipboard = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>;
        const IconInsert = () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>;
        const IconTarget = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line></svg>;
        const IconEye = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>;
        const IconPlay = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M5 3l14 9-14 9V3z"/></svg>;
        const IconPause = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>;
        const IconStop = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="6" y="6" width="12" height="12" /></svg>;
        const IconDownload = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>;
        const IconArrowRight = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>;
        const IconArrowDown = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline></svg>;
        const IconWarning = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ef4444" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>;
        const IconInfo = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>;
        const IconRefresh = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>;

        // --- COMPONENTS ---
        
        const SmartInput = ({ value, onValueChange, className, placeholder, type = "text", step }) => {
            const [localVal, setLocalVal] = useState(value);
            const [isDirty, setIsDirty] = useState(false);

            useEffect(() => { setLocalVal(value); }, [value]);

            useEffect(() => {
                if (!isDirty) return;
                const handler = setTimeout(() => { onValueChange(localVal); setIsDirty(false); }, 600); 
                return () => clearTimeout(handler);
            }, [localVal, isDirty, onValueChange]);

            const handleChange = (e) => { setLocalVal(e.target.value); setIsDirty(true); };
            const handleBlur = () => { if (isDirty) { onValueChange(localVal); setIsDirty(false); } };
            const handleKeyDown = (e) => { if (e.key === 'Enter') { if (isDirty) { onValueChange(localVal); setIsDirty(false); } e.target.blur(); } };

            return (
                <input type={type} className={className} placeholder={placeholder} value={localVal} onChange={handleChange} onBlur={handleBlur} onKeyDown={handleKeyDown} step={step} />
            );
        };

        // --- MATH HELPERS ---
        const dist = (p1, p2) => Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.z - p1.z, 2));

        const getNormal = (p1, p2) => {
            const dx = p2.x - p1.x; const dz = p2.z - p1.z; const l = Math.sqrt(dx*dx + dz*dz);
            if (l===0) return {x:0, z:0}; return { x: -dz/l, z: dx/l };
        };

        const intersectLines = (p1, p2, p3, p4) => {
            const d = (p1.x - p2.x) * (p3.z - p4.z) - (p1.z - p2.z) * (p3.x - p4.x);
            if (Math.abs(d) < 1e-9) return null; 
            const t = ((p1.x - p3.x) * (p3.z - p4.z) - (p1.z - p3.z) * (p3.x - p4.x)) / d;
            return { x: p1.x + t * (p2.x - p1.x), z: p1.z + t * (p2.z - p1.z) };
        };

        const intersectLineCircle = (p1, p2, center, r) => {
            const dx = p2.x - p1.x; const dz = p2.z - p1.z; const fx = p1.x - center.x; const fz = p1.z - center.z;
            const a = dx*dx + dz*dz; const b = 2*(fx*dx + fz*dz); const c = (fx*fx + fz*fz) - r*r;
            let discriminant = b*b - 4*a*c; if (discriminant < 0) return null;
            discriminant = Math.sqrt(discriminant);
            const t1 = (-b - discriminant) / (2*a); const t2 = (-b + discriminant) / (2*a);
            return [{ x: p1.x + t1*dx, z: p1.z + t1*dz }, { x: p1.x + t2*dx, z: p1.z + t2*dz }];
        };

        const getArcParams = (p1, p2, r, type) => {
            const d2 = Math.pow(p2.x - p1.x, 2) + Math.pow(p2.z - p1.z, 2); const d = Math.sqrt(d2);
            const isLongArc = r < 0; const absR = Math.abs(r); let safeR = absR; let error = false;
            if (d2 === 0) return { error: true, cx: p1.x, cz: p1.z, r: 0 };
            if (absR < d/2 - 0.001) { error = true; safeR = d/2 + 0.001; }
            const mx = (p1.x + p2.x) / 2; const mz = (p1.z + p2.z) / 2;
            const h = Math.sqrt(Math.max(0, safeR*safeR - d2/4));
            const dx = p2.x - p1.x; const dz = p2.z - p1.z;
            const ox = -dz / d; const oz = dx / d;
            let sign = (type === 'G3') ? -1 : 1; if (isLongArc) sign *= -1;
            const cx = mx + sign * h * ox; const cz = mz + sign * h * oz;
            return { cx, cz, r: safeR, error };
        };

        const isAngleBetween = (target, start, end, isG2) => {
            const t = (target % (2*Math.PI) + 2*Math.PI) % (2*Math.PI);
            const s = (start % (2*Math.PI) + 2*Math.PI) % (2*Math.PI);
            const e = (end % (2*Math.PI) + 2*Math.PI) % (2*Math.PI);
            if (isG2) { if (s >= e) return t <= s && t >= e; return t <= s || t >= e; } else { if (e >= s) return t >= s && t <= e; return t >= s || t <= e; }
        };

        const intersectHorizontalLineSegment = (xLine, p1, p2) => {
            const minX = Math.min(p1.x, p2.x); const maxX = Math.max(p1.x, p2.x);
            if (xLine < minX || xLine > maxX) return null; if (Math.abs(p2.x - p1.x) < 1e-6) return null;
            const t = (xLine - p1.x) / (p2.x - p1.x); return p1.z + t * (p2.z - p1.z);
        };
        const intersectHorizontalLineArc = (xLine, center, radius) => {
            const term = radius*radius - Math.pow(xLine - center.x, 2); if (term < 0) return [];
            const sqrtTerm = Math.sqrt(term); return [center.z - sqrtTerm, center.z + sqrtTerm];
        };
        const intersectVerticalLineSegment = (zLine, p1, p2) => {
            const minZ = Math.min(p1.z, p2.z); const maxZ = Math.max(p1.z, p2.z);
            if (zLine < minZ || zLine > maxZ) return null; if (Math.abs(p2.z - p1.z) < 1e-6) return null;
            const t = (zLine - p1.z) / (p2.z - p1.z); return p1.x + t * (p2.x - p1.x);
        };
        const intersectVerticalLineArc = (zLine, center, radius) => {
            const term = radius*radius - Math.pow(zLine - center.z, 2); if (term < 0) return [];
            const sqrtTerm = Math.sqrt(term); return [center.x - sqrtTerm, center.x + sqrtTerm];
        };

        // --- APP ---
        const App = () => {
            const [theme, setTheme] = useState('light');
            const [editMode, setEditMode] = useState('contour'); 
            const [mobileTab, setMobileTab] = useState('editor'); 
            const [copyFeedback, setCopyFeedback] = useState(false);
            
            const [simRunning, setSimRunning] = useState(false);
            const [simProgress, setSimProgress] = useState(0); 
            
            // Flag for LocalStorage Loading
            const [isLoaded, setIsLoaded] = useState(false);

            const [params, setParams] = useState({
                machineType: 'LIMS=2000',
                mode: 'DIAMON',
                toolName: 'ROUGHER_T1',
                speed: 200,
                feed: 0.25,
                depthOfCut: 2.0,
                retractDistance: 2.0,
                allowanceX: 0.5,
                allowanceZ: 0.1,
                toolRadius: 0.8,
                doFinishing: true, 
                roughingStrategy: 'longitudinal',
                stockMode: 'cylinder', 
                stockMargin: 5.0, 
                stockDiameter: 100, 
                stockLength: 100,
                stockFace: 2.0,
                safeX: 150,
                safeZ: 5
            });

            const [contourPoints, setContourPoints] = useState([
                { id: 1, type: 'G0', x: 100, z: 0, r: 0, mode: 'ABS' },
                { id: 2, type: 'G1', x: 20, z: 0, r: 0, mode: 'ABS' },     
                { id: 3, type: 'G1', x: 20, z: -15, r: 0, mode: 'ABS' },   
                { id: 4, type: 'G1', x: 30, z: -15, r: 0, mode: 'ABS' },   
                { id: 5, type: 'G1', x: 35, z: -25, r: 0, mode: 'ABS' },   
                { id: 6, type: 'G1', x: 35, z: -40, r: 0, mode: 'ABS' },   
                { id: 7, type: 'G2', x: 55, z: -50, r: 10, mode: 'ABS' },  
                { id: 8, type: 'G1', x: 55, z: -65, r: 0, mode: 'ABS' },   
                { id: 9, type: 'G3', x: 65, z: -75, r: 12, mode: 'ABS' },  
                { id: 10, type: 'G1', x: 80, z: -100, r: 0, mode: 'ABS' }  
            ]);

            const [stockPoints, setStockPoints] = useState([
                { id: 101, type: 'G0', x: 85, z: 2, r: 0, mode: 'ABS' },
                { id: 102, type: 'G1', x: 85, z: -105, r: 0, mode: 'ABS' },
                { id: 103, type: 'G1', x: 0, z: -105, r: 0, mode: 'ABS' }
            ]);
            
            const [errors, setErrors] = useState([]);
            const [gCodeInput, setGCodeInput] = useState('');
            // Změna: generatedCode nyní není string, ale pole objektů pro interaktivitu
            const [generatedCode, setGeneratedCode] = useState([]);
            const [activeTab, setActiveTab] = useState('editor');
            
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const codeContainerRef = useRef(null);
            const [view, setView] = useState({ scale: 3, panX: 600, panY: 350 });
            const [isDragging, setIsDragging] = useState(false);
            const lastMousePos = useRef({ x: 0, y: 0 });
            const lastPinchDist = useRef(null);
            
            // --- LOCAL STORAGE LOGIC ---
            const STORAGE_KEY = 'sinumerik_cam_save_v1';

            // 1. Load on mount
            useEffect(() => {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        if (parsed.params) setParams(prev => ({...prev, ...parsed.params}));
                        if (parsed.contourPoints && parsed.contourPoints.length > 0) setContourPoints(parsed.contourPoints);
                        if (parsed.stockPoints && parsed.stockPoints.length > 0) setStockPoints(parsed.stockPoints);
                        if (parsed.theme) setTheme(parsed.theme);
                    } catch (e) {
                        console.error("Failed to load local storage:", e);
                    }
                }
                setIsLoaded(true); // Mark as loaded so we can start saving
            }, []);

            // 2. Save on change (only if loaded)
            useEffect(() => {
                if (!isLoaded) return;
                const dataToSave = {
                    params,
                    contourPoints,
                    stockPoints,
                    theme
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
            }, [isLoaded, params, contourPoints, stockPoints, theme]);

            // 3. Reset Function
            const handleResetApp = () => {
                if(confirm("Opravdu chcete vymazat veškerou uloženou práci a resetovat aplikaci?")) {
                    localStorage.removeItem(STORAGE_KEY);
                    window.location.reload();
                }
            };

            useEffect(() => {
                document.body.className = `h-[100dvh] w-screen overflow-hidden flex flex-col font-sans transition-colors duration-300 ${theme === 'dark' ? 'bg-gray-900 text-gray-100' : 'bg-gray-50 text-gray-900'}`;
            }, [theme]);

            const fitView = useCallback(() => {
                if (!containerRef.current) return;
                const points = resolvePointsToAbsolute(contourPoints);
                if (points.length === 0) return;
                let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
                points.forEach(p => {
                    const x = params.mode === 'DIAMON' ? p.xAbs / 2 : p.xAbs;
                    const z = p.zAbs;
                    if(x < minX) minX = x; if(x > maxX) maxX = x;
                    if(z < minZ) minZ = z; if(z > maxZ) maxZ = z;
                });
                const pad = 20;
                const width = maxZ - minZ + pad*2;
                const height = maxX - minX + pad*2;
                if (width <= 0 || height <= 0) return;
                const contW = containerRef.current.clientWidth;
                const contH = containerRef.current.clientHeight;
                if (contW === 0 || contH === 0) return;
                const scaleX = contW / width;
                const scaleY = contH / height;
                let newScale = Math.min(scaleX, scaleY) * 0.8; 
                if (newScale > 10) newScale = 10;
                if (newScale < 0.1) newScale = 0.1;
                const midZ = (minZ + maxZ) / 2;
                const midX = (minX + maxX) / 2;
                setView({ scale: newScale, panX: contW/2 - midZ * newScale, panY: contH/2 + midX * newScale });
            }, [contourPoints, params.mode]);

            useEffect(() => { setTimeout(fitView, 100); }, [mobileTab]); 

            const resolvePointsToAbsolute = (pts) => {
                let lastX = 0; let lastZ = 0;
                return pts.map((p, index) => {
                    const valX = parseFloat(p.x) || 0; const valZ = parseFloat(p.z) || 0;
                    let absX = valX; let absZ = valZ;
                    if (p.mode === 'INC') { absX = lastX + valX; absZ = lastZ + valZ; } else { absX = valX; absZ = valZ; }
                    lastX = absX; lastZ = absZ;
                    return { ...p, xAbs: absX, zAbs: absZ, rVal: parseFloat(p.r) || 0 };
                });
            };
            const handleAutoStock = () => { /* ... same ... */ };
            const generateDefaultStock = () => { /* ... same ... */ };

            const calculatedData = useMemo(() => {
                const absContour = resolvePointsToAbsolute(contourPoints);
                const absStock = resolvePointsToAbsolute(stockPoints);
                const worldPoints = absContour.map(p => ({ ...p, xReal: params.mode === 'DIAMON' ? p.xAbs / 2 : p.xAbs, zReal: p.zAbs }));
                const stockWorldPoints = absStock.map(p => ({ ...p, xReal: params.mode === 'DIAMON' ? p.xAbs / 2 : p.xAbs, zReal: p.zAbs }));

                const tipR = parseFloat(params.toolRadius) || 0;
                const allowanceX = parseFloat(params.allowanceX) || 0;
                const allowanceZ = parseFloat(params.allowanceZ) || 0;
                const totalOffset = tipR + Math.max(allowanceX, allowanceZ);
                const retractDist = parseFloat(params.retractDistance) || 2.0; 
                
                let contourSegments = [];
                let offsetPath = [];
                let finishOffsetPath = [];
                let stockPathSegments = []; 
                const foundErrors = [];

                for (let i = 0; i < worldPoints.length - 1; i++) {
                    const p1 = worldPoints[i]; const p2 = worldPoints[i+1]; const type = p2.type;
                    if (type === 'G0' || type === 'G1') {
                        contourSegments.push({ type: 'line', p1: {x:p1.xReal, z:p1.zReal}, p2: {x:p2.xReal, z:p2.zReal}, orig: p2 });
                    } else if (type === 'G2' || type === 'G3') {
                        const arc = getArcParams({x:p1.xReal, z:p1.zReal}, {x:p2.xReal, z:p2.zReal}, p2.rVal, type);
                        if (arc.error) foundErrors.push(`Řádek ${i+2}: Rádius R${p2.r} je příliš malý.`);
                        else if (arc.r < totalOffset) foundErrors.push(`KOLIZE (Řádek ${i+2}): Rádius kontury menší než nástroj.`);
                        contourSegments.push({ type: 'arc', ...arc, p1: {x:p1.xReal, z:p1.zReal}, p2: {x:p2.xReal, z:p2.zReal}, dir: type });
                    }
                }
                for (let i = 0; i < stockWorldPoints.length - 1; i++) {
                    const p1 = stockWorldPoints[i]; const p2 = stockWorldPoints[i+1]; const type = p2.type;
                    if (type === 'G0' || type === 'G1') {
                        stockPathSegments.push({ type: 'line', p1: {x:p1.xReal, z:p1.zReal}, p2: {x:p2.xReal, z:p2.zReal} });
                    } else if (type === 'G2' || type === 'G3') {
                        const arc = getArcParams({x:p1.xReal, z:p1.zReal}, {x:p2.xReal, z:p2.zReal}, p2.rVal, type);
                        const startAngle = Math.atan2(p1.xReal - arc.cx, p1.zReal - arc.cz);
                        const endAngle = Math.atan2(p2.xReal - arc.cx, p2.zReal - arc.cz);
                        stockPathSegments.push({ type: 'arc', ...arc, dir: type, startAngle, endAngle });
                    }
                }

                let incompleteMachiningCount = 0;
                for (let i = 0; i < contourSegments.length; i++) {
                    const seg = contourSegments[i];
                    let offSeg = null;
                    if (seg.type === 'line') {
                        const n = getNormal(seg.p1, seg.p2);
                        offSeg = { type: 'line', p1: { x: seg.p1.x + n.x * totalOffset, z: seg.p1.z + n.z * totalOffset }, p2: { x: seg.p2.x + n.x * totalOffset, z: seg.p2.z + n.z * totalOffset } };
                    } else if (seg.type === 'arc') {
                        let rNew = (seg.dir === 'G3') ? seg.r + totalOffset : seg.r - totalOffset;
                        if (rNew < 0) { rNew = 0.001; incompleteMachiningCount++; }
                        const startAngle = Math.atan2(seg.p1.x - seg.cx, seg.p1.z - seg.cz);
                        const endAngle = Math.atan2(seg.p2.x - seg.cx, seg.p2.z - seg.cz);
                        offSeg = { type: 'arc', cx: seg.cx, cz: seg.cz, r: rNew, dir: seg.dir, refP1: seg.p1, refP2: seg.p2, startAngle, endAngle };
                    }
                    if (offSeg) offsetPath.push(offSeg);
                }
                if (incompleteMachiningCount > 0) foundErrors.push({ type: 'warning', msg: `POZNÁMKA: V ${incompleteMachiningCount} místech nedojde ke kompletnímu obrobení.` });

                if (params.doFinishing) {
                    for (let i = 0; i < contourSegments.length; i++) {
                        const seg = contourSegments[i];
                        let offSeg = null;

                        if (seg.type === 'line') {
                            const n = getNormal(seg.p1, seg.p2);
                            offSeg = { type: 'line', p1: { x: seg.p1.x + n.x * tipR, z: seg.p1.z + n.z * tipR }, p2: { x: seg.p2.x + n.x * tipR, z: seg.p2.z + n.z * tipR } };
                        } else if (seg.type === 'arc') {
                            let rNew = (seg.dir === 'G3') ? seg.r + tipR : seg.r - tipR;
                            if (rNew < 0) rNew = 0.001;
                            const startAngle = Math.atan2(seg.p1.x - seg.cx, seg.p1.z - seg.cz);
                            const endAngle = Math.atan2(seg.p2.x - seg.cx, seg.p2.z - seg.cz);
                            offSeg = { type: 'arc', cx: seg.cx, cz: seg.cz, r: rNew, dir: seg.dir, refP1: seg.p1, refP2: seg.p2, startAngle, endAngle };
                        }

                        if (offSeg) {
                            if (finishOffsetPath.length > 0) {
                                let prevOff = finishOffsetPath[finishOffsetPath.length - 1];
                                
                                let prevEnd = {x:0, z:0};
                                if (prevOff.type === 'line') prevEnd = prevOff.p2;
                                else prevEnd = { x: prevOff.cx + Math.cos(prevOff.endAngle) * prevOff.r, z: prevOff.cz + Math.sin(prevOff.endAngle) * prevOff.r };

                                let currStart = {x:0, z:0};
                                if (offSeg.type === 'line') currStart = offSeg.p1;
                                else currStart = { x: offSeg.cx + Math.cos(offSeg.startAngle) * offSeg.r, z: offSeg.cz + Math.sin(offSeg.startAngle) * offSeg.r };

                                const distGap = Math.hypot(currStart.x - prevEnd.x, currStart.z - prevEnd.z);
                                
                                let intersection = null;
                                if (prevOff.type === 'line' && offSeg.type === 'line') {
                                    intersection = intersectLines(prevOff.p1, prevOff.p2, offSeg.p1, offSeg.p2);
                                }
                                else if (prevOff.type === 'line' && offSeg.type === 'arc') {
                                    const intersects = intersectLineCircle(prevOff.p1, prevOff.p2, {x:offSeg.cx, z:offSeg.cz}, offSeg.r);
                                    if(intersects) {
                                        const d1 = Math.hypot(intersects[0].x - prevEnd.x, intersects[0].z - prevEnd.z);
                                        const d2 = Math.hypot(intersects[1].x - prevEnd.x, intersects[1].z - prevEnd.z);
                                        intersection = d1 < d2 ? intersects[0] : intersects[1];
                                    }
                                }
                                else if (prevOff.type === 'arc' && offSeg.type === 'line') {
                                    const intersects = intersectLineCircle(offSeg.p1, offSeg.p2, {x:prevOff.cx, z:prevOff.cz}, prevOff.r);
                                    if(intersects) {
                                        const d1 = Math.hypot(intersects[0].x - currStart.x, intersects[0].z - currStart.z);
                                        const d2 = Math.hypot(intersects[1].x - currStart.x, intersects[1].z - currStart.z);
                                        intersection = d1 < d2 ? intersects[0] : intersects[1];
                                    }
                                }

                                if (intersection && distGap > 0.001) {
                                    const distPrevStartToI = Math.hypot(intersection.x - (prevOff.type==='line'?prevOff.p1.x:prevOff.cx), intersection.z - (prevOff.type==='line'?prevOff.p1.z:prevOff.cz)); 
                                    const distPrevStartToEnd = Math.hypot(prevEnd.x - (prevOff.type==='line'?prevOff.p1.x:prevOff.cx), prevEnd.z - (prevOff.type==='line'?prevOff.p1.z:prevOff.cz)); 
                                    
                                    if (distPrevStartToI < distPrevStartToEnd - 0.001) {
                                        if(prevOff.type === 'line') prevOff.p2 = intersection;
                                        else { prevOff.endAngle = Math.atan2(intersection.x - prevOff.cx, intersection.z - prevOff.cz); }
                                        if(offSeg.type === 'line') offSeg.p1 = intersection;
                                        else { offSeg.startAngle = Math.atan2(intersection.x - offSeg.cx, intersection.z - offSeg.cz); }
                                    } else {
                                        const vertex = contourSegments[i].p1; 
                                        const angleStart = Math.atan2(prevEnd.x - vertex.x, prevEnd.z - vertex.z);
                                        const angleEnd = Math.atan2(currStart.x - vertex.x, currStart.z - vertex.z);
                                        let diff = angleEnd - angleStart;
                                        while (diff <= -Math.PI) diff += 2*Math.PI; while (diff > Math.PI) diff -= 2*Math.PI;
                                        const rollDir = diff > 0 ? 'G3' : 'G2';
                                        finishOffsetPath.push({ type: 'arc', cx: vertex.x, cz: vertex.z, r: tipR, dir: rollDir, startAngle: angleStart, endAngle: angleEnd, isCornerRoll: true });
                                    }
                                } else if (distGap > 0.01) {
                                    const vertex = contourSegments[i].p1; 
                                    const angleStart = Math.atan2(prevEnd.x - vertex.x, prevEnd.z - vertex.z);
                                    const angleEnd = Math.atan2(currStart.x - vertex.x, currStart.z - vertex.z);
                                    let diff = angleEnd - angleStart;
                                    while (diff <= -Math.PI) diff += 2*Math.PI; while (diff > Math.PI) diff -= 2*Math.PI;
                                    const rollDir = diff > 0 ? 'G3' : 'G2';
                                    finishOffsetPath.push({ type: 'arc', cx: vertex.x, cz: vertex.z, r: tipR, dir: rollDir, startAngle: angleStart, endAngle: angleEnd, isCornerRoll: true });
                                }
                            }
                            finishOffsetPath.push(offSeg);
                        }
                    }
                }
                
                setErrors(foundErrors);

                const passes = [];
                const step = parseFloat(params.depthOfCut) || 1;
                const sRad = (parseFloat(params.stockDiameter) || 100)/2;
                const stockFace = parseFloat(params.stockFace) || 0;
                
                if (params.roughingStrategy === 'face') {
                    let currentZ = stockFace;
                    const minZPart = -1000;
                    let safe = 0;
                    while (currentZ > minZPart && safe < 500) {
                        currentZ -= step; safe++;
                        let xsEnd = [];
                        offsetPath.forEach(os => {
                            if (os.type === 'line') {
                                const x = intersectVerticalLineSegment(currentZ, os.p1, os.p2);
                                if (x !== null) xsEnd.push(x);
                            } else if (os.type === 'arc') {
                                const res = intersectVerticalLineArc(currentZ, {x: os.cx, z: os.cz}, os.r);
                                res.forEach(x => {
                                    const angle = Math.atan2(x - os.cx, currentZ - os.cz);
                                    if (isAngleBetween(angle, os.startAngle, os.endAngle, os.dir === 'G2')) xsEnd.push(x);
                                });
                            }
                        });
                        xsEnd.sort((a, b) => a - b); 
                        let xTarget = 0;
                        if (xsEnd.length > 0) {
                            const validXs = xsEnd.filter(x => x < sRad + 1);
                            if (validXs.length > 0) xTarget = validXs[validXs.length - 1]; 
                        } else {
                            let maxOZ = -9999;
                            offsetPath.forEach(p => { 
                                const z1 = p.type==='line' ? p.p1.z : p.cz + p.r; 
                                const z2 = p.type==='line' ? p.p2.z : p.cz - p.r; 
                                maxOZ = Math.max(maxOZ, z1, z2);
                            });
                            if (currentZ > maxOZ) xTarget = -1; else continue; 
                        }
                        if (xTarget >= sRad - 0.01) continue;
                        passes.push({ type: 'face', z: currentZ, xStart: sRad + 2, xEnd: xTarget });
                        if (currentZ < -200) break; 
                    }
                } else {
                    let currentX = sRad;
                    if (params.stockMode === 'casting' && stockWorldPoints.length > 0) {
                       let maxStockX = -9999;
                       stockWorldPoints.forEach(p => { if (p.xReal > maxStockX) maxStockX = p.xReal; });
                       currentX = maxStockX; 
                    }
                    const cylStockZ = (parseFloat(params.stockLength) || 100) * -1;
                    let safe = 0;
                    while (currentX > -50 && safe < 500) {
                        currentX -= step; safe++;
                        let zsEnd = [];
                        offsetPath.forEach(os => {
                            if (os.type === 'line') {
                                const z = intersectHorizontalLineSegment(currentX, os.p1, os.p2);
                                if (z !== null) zsEnd.push(z);
                            } else if (os.type === 'arc') {
                                const res = intersectHorizontalLineArc(currentX, {x: os.cx, z: os.cz}, os.r);
                                res.forEach(z => {
                                    const angle = Math.atan2(currentX - os.cx, z - os.cz);
                                    if (isAngleBetween(angle, os.startAngle, os.endAngle, os.dir === 'G2')) zsEnd.push(z);
                                });
                            }
                        });
                        zsEnd.sort((a, b) => b - a);
                        zsEnd = zsEnd.filter((z, i) => i === 0 || Math.abs(z - zsEnd[i-1]) > 0.01);

                        if (zsEnd.length > 0) {
                            let zTarget = zsEnd[0];
                            let zStartCut = allowanceZ;
                            if (params.stockMode === 'casting') {
                                let zsStart = [];
                                stockPathSegments.forEach(ss => {
                                    if (ss.type === 'line') {
                                        const z = intersectHorizontalLineSegment(currentX, ss.p1, ss.p2);
                                        if (z !== null) zsStart.push(z);
                                    } else if (ss.type === 'arc') {
                                        const res = intersectHorizontalLineArc(currentX, {x: ss.cx, z: ss.cz}, ss.r);
                                        res.forEach(z => {
                                            const angle = Math.atan2(currentX - ss.cx, z - ss.cz);
                                            if (isAngleBetween(angle, ss.startAngle, ss.endAngle, ss.dir === 'G2')) zsStart.push(z);
                                        });
                                    }
                                });
                                zsStart.sort((a, b) => b - a);
                                const validStarts = zsStart.filter(z => z > zTarget + 0.01);
                                if (validStarts.length > 0) zStartCut = validStarts[0];
                                else if (zsStart.length === 0) continue; 
                            } else {
                                if (currentX > sRad) continue; 
                                if (zTarget < cylStockZ) zTarget = cylStockZ;
                                zStartCut = stockFace;
                            }
                            if (zStartCut > zTarget) {
                                passes.push({ type: 'long', x: currentX, zStart: zStartCut, zEnd: zTarget });
                            }
                        }
                        let minPartX = 9999;
                        offsetPath.forEach(os => {
                           if (os.type === 'line') minPartX = Math.min(minPartX, os.p1.x, os.p2.x);
                           else minPartX = Math.min(minPartX, os.cx - os.r); 
                        });
                        if (currentX < minPartX - 1) break; 
                    }
                }

                const simPath = [];
                simPath.push({x: params.safeX/2, z: params.safeZ, type: 'G0'});
                
                passes.forEach(pass => {
                    if (pass.type === 'long') {
                        const xRetract = pass.x + retractDist; 
                        const xCut = pass.x;
                        simPath.push({x: xRetract, z: pass.zStart + 1, type: 'G0'}); 
                        simPath.push({x: xCut, z: pass.zStart + 1, type: 'G0'});     
                        simPath.push({x: xCut, z: pass.zEnd, type: 'G1'});          
                        simPath.push({x: xRetract, z: pass.zEnd + retractDist, type: 'G1'});   
                        simPath.push({x: xRetract, z: pass.zStart + 1, type: 'G0'});   
                    } else {
                        const zRetract = pass.z + retractDist; 
                        const zCut = pass.z;
                        simPath.push({x: pass.xStart, z: zRetract, type: 'G0'});
                        simPath.push({x: pass.xStart, z: zCut, type: 'G0'});
                        simPath.push({x: pass.xEnd, z: zCut, type: 'G1'}); 
                        simPath.push({x: pass.xEnd, z: zRetract, type: 'G1'}); 
                        simPath.push({x: pass.xStart, z: zRetract, type: 'G0'}); 
                    }
                });
                
                simPath.push({x: params.safeX/2, z: params.safeZ, type: 'G0'});

                if (params.doFinishing && finishOffsetPath.length > 0) {
                     const startSeg = finishOffsetPath[0];
                     const startX = startSeg.type === 'line' ? startSeg.p1.x : (startSeg.cx + Math.cos(startSeg.startAngle)*startSeg.r);
                     const startZ = startSeg.type === 'line' ? startSeg.p1.z : (startSeg.cz + Math.sin(startSeg.startAngle)*startSeg.r);
                     
                     simPath.push({x: params.safeX/2, z: params.safeZ, type: 'G0'});
                     simPath.push({x: startX + 2, z: startZ, type: 'G0'}); 
                     simPath.push({x: startX, z: startZ, type: 'G1'}); 

                     finishOffsetPath.forEach(seg => {
                         if (seg.type === 'line') {
                             simPath.push({x: seg.p2.x, z: seg.p2.z, type: 'G1'});
                         } else {
                             const steps = 10;
                             let sA = seg.startAngle;
                             let eA = seg.endAngle;
                             if (seg.dir === 'G2' && eA > sA) eA -= 2*Math.PI;
                             if (seg.dir === 'G3' && eA < sA) eA += 2*Math.PI;
                             for(let j=1; j<=steps; j++) {
                                 const a = sA + (eA - sA) * (j/steps);
                                 simPath.push({x: seg.cx + Math.cos(a)*seg.r, z: seg.cz + Math.sin(a)*seg.r, type: seg.dir});
                             }
                         }
                     });
                     
                     const lastPt = simPath[simPath.length-1];
                     simPath.push({x: lastPt.x + 2, z: lastPt.z + 2, type: 'G0'});
                     simPath.push({x: params.safeX/2, z: params.safeZ, type: 'G0'});
                }

                return { worldPoints, stockWorldPoints, offsetPath, finishOffsetPath, stockPathSegments, passes, simPath, retractDist };
            }, [contourPoints, stockPoints, params]);

            // --- G-Code and Mapping Generation ---
            useEffect(() => {
                let animationFrameId; let startTime;
                const animate = (time) => {
                    if (!startTime) startTime = time;
                    if (simRunning) {
                        setSimProgress(prev => { 
                            // ZPOMALENO z 0.003 na 0.0015
                            const next = prev + 0.0015; 
                            if (next >= 1) { 
                                setSimRunning(false); 
                                return 1; 
                            } 
                            return next; 
                        });
                        animationFrameId = requestAnimationFrame(animate);
                    }
                };
                if (simRunning) animationFrameId = requestAnimationFrame(animate);
                return () => cancelAnimationFrame(animationFrameId);
            }, [simRunning]);

            useEffect(() => {
                const d = new Date();
                const lines = []; // Store lines as { text: string, simIdx: number | null }
                
                // Helper to add lines
                const add = (text, simIdx = null) => lines.push({ text, simIdx });
                const addCmt = (text) => add(`; ${text}`, null);
                
                // Mapping counter: Corresponds to index in calculatedData.simPath
                // simPath starts with 1 point (Safe Pos) -> index 0
                let simCounter = 0; 

                add(`; Vygenerovaný kód SINUMERIK 840D`);
                add(`; Datum: ${d.toLocaleDateString()}`);
                add(`; G-kód s kompenzací rádiusu (rozepsaný)`);
                add(`G18 ; Rovina ZX`);
                add(`G90 ; Absolutní programování`);
                add(`G54 ; Posunutí počátku`);
                add(`G95 ; Posuv na otáčku`);
                add(`G75 Z0 ; Nájezd do ref. bodu`);
                add(`G75 X0`);
                add(`LIMS=2000 ; Limit otáček`);
                add(`G96 S${params.speed} ${params.machineType} ; Konst. řezná rychlost`);
                add(`${params.mode}`);
                add(`T="${params.toolName}" D1 M6 ; Výměna nástroje`);
                add(`M3 ; Vřeteno CW`);
                add(`M8 ; Chlazení ZAP`);
                
                // Start position in SimPath is index 0
                add(`G0 X${params.safeX} Z${params.safeZ} ; Rychloposuv (polohování)`, 0); 

                const rDist = calculatedData.retractDist || 2.0;

                addCmt(`--- HRUBOVANI (${params.roughingStrategy === 'face' ? 'CELNI' : 'PODELNE'}) ---`);
                
                calculatedData.passes.forEach((pass, i) => {
                    addCmt(`Průchod ${i+1}`);
                    
                    // Logic MUST match calculatedData simPath generation for Roughing
                    // Roughing adds 5 points per pass to simPath
                    
                    if (pass.type === 'long') {
                        const xVal = params.mode === 'DIAMON' ? (pass.x * 2).toFixed(3) : pass.x.toFixed(3);
                        const xRetract = params.mode === 'DIAMON' ? ((pass.x + rDist) * 2).toFixed(3) : (pass.x + rDist).toFixed(3);
                        
                        // 1. G0 Approach
                        simCounter += 1;
                        add(`G0 X${xRetract} Z${(pass.zStart + 1).toFixed(3)}`, simCounter);
                        
                        // 2. G0 Depth
                        simCounter += 1;
                        // Usually merged with approach in visuals but logic has it
                        // We attach it to the same or next
                        // add(`; (Najeť na hloubku)`, simCounter); 

                        // 3. G1 Cut
                        simCounter += 1; // Start of G1
                        add(`G1 X${xVal} F${params.feed}`, simCounter); 
                        
                        // 4. G1 End Cut
                        simCounter += 1; 
                        add(`G1 Z${pass.zEnd.toFixed(3)}`, simCounter);
                        
                        // 5. G1 Retract
                        simCounter += 1;
                        add(`G1 X${xRetract} Z${(pass.zEnd + rDist).toFixed(3)}`, simCounter);
                        
                        // 6. G0 Return
                        simCounter += 1;
                        add(`G0 Z${(pass.zStart + 1).toFixed(3)}`, simCounter);

                    } else {
                        // FACE
                        const zVal = pass.z.toFixed(3);
                        const zRetract = (pass.z + rDist).toFixed(3);
                        const xStart = params.mode === 'DIAMON' ? (pass.xStart * 2).toFixed(3) : pass.xStart.toFixed(3);
                        const xEnd = params.mode === 'DIAMON' ? (pass.xEnd * 2).toFixed(3) : pass.xEnd.toFixed(3);
                        const xEndRetract = params.mode === 'DIAMON' ? ((pass.xEnd + rDist) * 2).toFixed(3) : (pass.xEnd + rDist).toFixed(3);

                        simCounter += 1;
                        add(`G0 X${xStart} Z${zRetract}`, simCounter);

                        simCounter += 1; // Depth (visual logic step)
                        // add(`; Hloubka`, simCounter);

                        simCounter += 1;
                        add(`G1 Z${zVal} F${params.feed}`, simCounter);

                        simCounter += 1;
                        add(`G1 X${xEnd}`, simCounter);

                        simCounter += 1;
                        add(`G1 X${xEndRetract} Z${zRetract}`, simCounter);

                        simCounter += 1;
                        add(`G0 X${xStart}`, simCounter);
                    }
                });

                // SimPath adds 1 safe move after roughing
                simCounter += 1;
                add(`G0 X${params.safeX} Z${params.safeZ}`, simCounter);

                if (params.doFinishing && calculatedData.finishOffsetPath.length > 0) {
                    addCmt(`--- DOKONCOVANI ---`);
                    
                    const startSeg = calculatedData.finishOffsetPath[0];
                    const sX = startSeg.type === 'line' ? startSeg.p1.x : (startSeg.cx + Math.cos(startSeg.startAngle)*startSeg.r);
                    const sZ = startSeg.type === 'line' ? startSeg.p1.z : (startSeg.cz + Math.sin(startSeg.startAngle)*startSeg.r);
                    const sX_out = params.mode === 'DIAMON' ? (sX * 2).toFixed(3) : sX.toFixed(3);
                    
                    // Logic from simPath: 
                    // 1. Safe (already added above)
                    // 2. Approach (+2)
                    simCounter += 1;
                    add(`G0 X${sX_out} Z${sZ.toFixed(3)} ; Nájezd`, simCounter);
                    
                    // 3. Contact
                    simCounter += 1;
                    add(`G1 X${sX_out} Z${sZ.toFixed(3)}`, simCounter); // Actually usually same coords, just G1 switch

                    calculatedData.finishOffsetPath.forEach(seg => {
                        // SimPath generates varying points for Arcs, but 1 for Line.
                        // We map the END of the segment to the G-Code line.
                        
                        if (seg.type === 'line') {
                             const eX = params.mode === 'DIAMON' ? (seg.p2.x * 2).toFixed(3) : seg.p2.x.toFixed(3);
                             simCounter += 1;
                             add(`G1 X${eX} Z${seg.p2.z.toFixed(3)}`, simCounter);
                        } else {
                             // Arcs in simPath have 'steps' (10). 
                             // We need to advance simCounter by 'steps' so the next G-code line maps correctly.
                             simCounter += 10;
                             
                             const eX = params.mode === 'DIAMON' ? ((seg.cx + Math.cos(seg.endAngle)*seg.r) * 2).toFixed(3) : (seg.cx + Math.cos(seg.endAngle)*seg.r).toFixed(3);
                             const eZ = (seg.cz + Math.sin(seg.endAngle)*seg.r).toFixed(3);
                             add(`${seg.dir} X${eX} Z${eZ} CR=${seg.r.toFixed(3)} ${seg.isCornerRoll ? '; Obeplutí rohu' : ''}`, simCounter);
                        }
                    });
                    
                    // Retract logic from simPath
                    simCounter += 1;
                    // lastPt + 2
                    
                    simCounter += 1;
                    add(`G0 X${params.safeX} Z${params.safeZ}`, simCounter);
                }

                add(`M30 ; Konec programu`);
                
                addCmt(`--- KONTURA (Pro referenci) ---`);
                contourPoints.forEach(p => {
                    let line = `${p.type} X${p.x} Z${p.z}`;
                    if (p.type === 'G2' || p.type === 'G3') line += ` CR=${p.r}`; 
                    add(line);
                });

                setGeneratedCode(lines);
            }, [calculatedData, params, contourPoints]);

            // Handler for clicking a line
            const handleLineClick = (simIdx) => {
                if (simIdx !== null && calculatedData.simPath.length > 0) {
                    const progress = simIdx / (calculatedData.simPath.length - 1);
                    setSimProgress(progress);
                }
            };
            
            // --- Simulation Controls Logic ---
            const toggleSimulation = () => {
                if (simRunning) {
                    setSimRunning(false);
                } else {
                    if (simProgress >= 1) {
                        setSimProgress(0);
                    }
                    setSimRunning(true);
                }
            };

            const stopSimulation = () => {
                setSimRunning(false);
                setSimProgress(0);
            };
            
            // Auto-scroll to active line
            useEffect(() => {
                if (!codeContainerRef.current) return;
                const activeEl = codeContainerRef.current.querySelector('.code-line.active');
                if (activeEl) {
                    activeEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }, [simProgress]);


            const draw = useCallback(() => {
                const canvas = canvasRef.current;
                const container = containerRef.current;
                if (!canvas || !container) return;
                
                const ctx = canvas.getContext('2d');
                const w = container.clientWidth;
                const h = container.clientHeight;
                if (canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h; }

                const colors = theme === 'dark' ? {
                    bg: '#111827', grid: '#374151', axis: '#ef4444', stock: '#9ca3af',
                    contour: '#3b82f6', offset: '#a855f7', pass: '#22c55e', finish: '#f472b6', error: '#ef4444', text: '#9ca3af', tool: '#facc15'
                } : {
                    bg: '#ffffff', grid: '#e5e7eb', axis: '#ef4444', stock: '#6b7280',
                    contour: '#2563eb', offset: '#9333ea', pass: '#16a34a', finish: '#db2777', error: '#ef4444', text: '#6b7280', tool: '#fbbf24'
                };

                ctx.fillStyle = colors.bg; ctx.fillRect(0, 0, w, h);
                const toScreen = (x, z) => ({ x: view.panX + z * view.scale, y: view.panY - x * view.scale });

                // Grid
                ctx.strokeStyle = colors.grid; ctx.lineWidth = 1; ctx.beginPath();
                
                // Prepare text style for grid labels
                ctx.fillStyle = theme === 'dark' ? '#6b7280' : '#9ca3af';
                ctx.font = "10px sans-serif";
                
                for (let i=-500; i<=500; i+=20) {
                     // Vertical lines (Constant Z)
                     const p1 = toScreen(-500, i); const p2 = toScreen(500, i);
                     ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                     
                     // Horizontal lines (Constant X)
                     const p3 = toScreen(i, -500); const p4 = toScreen(i, 500);
                     ctx.moveTo(p3.x, p3.y); ctx.lineTo(p4.x, p4.y);
                }
                ctx.stroke();

                // Labels loop (separate to be on top of lines or just managed cleanly)
                for (let i=-500; i<=500; i+=20) {
                    if (i === 0) continue; // Skip 0, handled by axis label

                    // Label Z axis (ticks on horizontal line)
                    // The line is Vertical (Constant Z=i). It crosses X=0 axis at toScreen(0, i).
                    const ptZ = toScreen(0, i);
                    ctx.textAlign = "center"; 
                    ctx.textBaseline = "top";
                    ctx.fillText(i.toString(), ptZ.x, ptZ.y + 2);

                    // Label X axis (ticks on vertical line)
                    // The line is Horizontal (Constant X=i). It crosses Z=0 axis at toScreen(i, 0).
                    const ptX = toScreen(i, 0);
                    ctx.textAlign = "right"; 
                    ctx.textBaseline = "middle";
                    ctx.fillText(i.toString(), ptX.x - 4, ptX.y);
                }

                // Axis
                const zero = toScreen(0,0);
                ctx.strokeStyle = colors.axis; ctx.lineWidth = 2; ctx.beginPath();
                ctx.moveTo(0, zero.y); ctx.lineTo(w, zero.y);
                ctx.moveTo(zero.x, 0); ctx.lineTo(zero.x, h);
                ctx.stroke();
                ctx.fillStyle = colors.axis; ctx.font = "bold 12px monospace";
                ctx.textAlign = "left"; ctx.textBaseline = "alphabetic"; // Reset alignment for axis labels
                ctx.fillText("Z+", w - 20, zero.y + 15); ctx.fillText("X+", zero.x + 10, 15);
                ctx.fillText("X0 Z0", zero.x + 4, zero.y - 4); 

                // Stock Visual
                if (params.stockMode === 'cylinder') {
                    const sRad = (parseFloat(params.stockDiameter) || 0)/2;
                    const sLen = parseFloat(params.stockLength) || 0;
                    const sFace = parseFloat(params.stockFace) || 0;
                    const s1 = toScreen(sRad, sFace); 
                    const s2 = toScreen(sRad, -sLen); 
                    const s3 = toScreen(0, -sLen);
                    const sStart = toScreen(0, sFace);
                    ctx.fillStyle = theme === 'dark' ? 'rgba(100,100,100,0.1)' : 'rgba(200,200,200,0.3)';
                    ctx.beginPath(); ctx.moveTo(sStart.x, sStart.y); ctx.lineTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.lineTo(s3.x, s3.y); ctx.fill();
                    ctx.strokeStyle = colors.stock; ctx.setLineDash([5, 5]); ctx.beginPath();
                    ctx.moveTo(sStart.x, sStart.y); ctx.lineTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.lineTo(s3.x, s3.y);
                    ctx.stroke(); ctx.setLineDash([]);
                } else if (calculatedData.stockPathSegments.length > 0) {
                    ctx.beginPath();
                    calculatedData.stockPathSegments.forEach((seg, i) => {
                        if (seg.type === 'line') {
                            const p1 = toScreen(seg.p1.x, seg.p1.z); const p2 = toScreen(seg.p2.x, seg.p2.z);
                            if (i === 0) ctx.moveTo(p1.x, p1.y); else ctx.lineTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                        } else if (seg.type === 'arc') {
                             const c = toScreen(seg.cx, seg.cz);
                             const sa_scr = -seg.startAngle; const ea_scr = -seg.endAngle;
                             const startX_scr = c.x + Math.cos(sa_scr) * seg.r * view.scale;
                             const startY_scr = c.y + Math.sin(sa_scr) * seg.r * view.scale;
                             if (i === 0) ctx.moveTo(startX_scr, startY_scr); else ctx.lineTo(startX_scr, startY_scr);
                             const isG2 = (seg.dir === 'G2');
                             ctx.arc(c.x, c.y, seg.r * view.scale, sa_scr, ea_scr, !isG2);
                        }
                    });
                    ctx.strokeStyle = colors.stock; ctx.setLineDash([4, 4]); ctx.lineWidth = 1; ctx.stroke(); ctx.setLineDash([]);
                }

                // Contour
                if (calculatedData.worldPoints.length > 0) {
                    ctx.beginPath();
                    const start = toScreen(calculatedData.worldPoints[0].xReal, calculatedData.worldPoints[0].zReal);
                    ctx.moveTo(start.x, start.y);
                    for (let i = 0; i < calculatedData.worldPoints.length - 1; i++) {
                        const p1 = calculatedData.worldPoints[i];
                        const p2 = calculatedData.worldPoints[i+1];
                        const ptEnd = toScreen(p2.xReal, p2.zReal);
                        if (p2.type === 'G0' || p2.type === 'G1') {
                            ctx.lineTo(ptEnd.x, ptEnd.y);
                        } else if (p2.type === 'G2' || p2.type === 'G3') {
                            const arc = getArcParams({x:p1.xReal, z:p1.zReal}, {x:p2.xReal, z:p2.zReal}, p2.rVal, p2.type);
                            if (!arc.error) {
                                const sc = toScreen(arc.cx, arc.cz);
                                const r = arc.r * view.scale;
                                const sa = Math.atan2(toScreen(p1.xReal, p1.zReal).y - sc.y, toScreen(p1.xReal, p1.zReal).x - sc.x);
                                const ea = Math.atan2(toScreen(p2.xReal, p2.zReal).y - sc.y, toScreen(p2.xReal, p2.zReal).x - sc.x);
                                const isG2 = (p2.type === 'G2');
                                ctx.arc(sc.x, sc.y, r, sa, ea, !isG2); 
                            } else {
                                ctx.lineTo(ptEnd.x, ptEnd.y);
                            }
                        }
                    }
                    ctx.strokeStyle = colors.contour; ctx.lineWidth = 3; ctx.stroke();
                }

                // Offset
                if (calculatedData.offsetPath.length > 0) {
                    ctx.beginPath();
                    calculatedData.offsetPath.forEach((seg, i) => {
                        if (seg.type === 'line') {
                            const p1 = toScreen(seg.p1.x, seg.p1.z); const p2 = toScreen(seg.p2.x, seg.p2.z);
                            if (i === 0) ctx.moveTo(p1.x, p1.y); else ctx.lineTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                        } else if (seg.type === 'arc') {
                             const c = toScreen(seg.cx, seg.cz);
                             const sa_scr = Math.atan2(toScreen(seg.refP1.x, seg.refP1.z).y - c.y, toScreen(seg.refP1.x, seg.refP1.z).x - c.x);
                             const ea_scr = Math.atan2(toScreen(seg.refP2.x, seg.refP2.z).y - c.y, toScreen(seg.refP2.x, seg.refP2.z).x - c.x);
                             const isG2 = (seg.dir === 'G2');
                             
                             const startX_scr = c.x + Math.cos(sa_scr) * (seg.r * view.scale);
                             const startY_scr = c.y + Math.sin(sa_scr) * (seg.r * view.scale);
                             
                             if (i === 0) ctx.moveTo(startX_scr, startY_scr); else ctx.lineTo(startX_scr, startY_scr); 
                             ctx.arc(c.x, c.y, seg.r * view.scale, sa_scr, ea_scr, !isG2);
                        }
                    });
                    ctx.strokeStyle = colors.offset; ctx.lineWidth = 1; ctx.setLineDash([2,2]); ctx.stroke(); ctx.setLineDash([]);
                }
                
                // Finish Path
                if (params.doFinishing && calculatedData.finishOffsetPath.length > 0) {
                    ctx.beginPath();
                    calculatedData.finishOffsetPath.forEach((seg, i) => {
                        if (seg.type === 'line') {
                            const p1 = toScreen(seg.p1.x, seg.p1.z); const p2 = toScreen(seg.p2.x, seg.p2.z);
                            if (i === 0) ctx.moveTo(p1.x, p1.y); else ctx.lineTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                        } else if (seg.type === 'arc') {
                             const c = toScreen(seg.cx, seg.cz);
                             const wsX = seg.cx + Math.sin(seg.startAngle) * seg.r;
                             const wsZ = seg.cz + Math.cos(seg.startAngle) * seg.r;
                             const weX = seg.cx + Math.sin(seg.endAngle) * seg.r;
                             const weZ = seg.cz + Math.cos(seg.endAngle) * seg.r;
                             
                             const ss = toScreen(wsX, wsZ);
                             const se = toScreen(weX, weZ);
                             const sc = toScreen(seg.cx, seg.cz);
                             
                             const sa_scr = Math.atan2(ss.y - sc.y, ss.x - sc.x);
                             const ea_scr = Math.atan2(se.y - sc.y, se.x - sc.x);
                             const isG2 = (seg.dir === 'G2');
                             
                             if (i === 0) ctx.moveTo(ss.x, ss.y); else ctx.lineTo(ss.x, ss.y); 
                             ctx.arc(sc.x, sc.y, seg.r * view.scale, sa_scr, ea_scr, !isG2);
                        }
                    });
                    ctx.strokeStyle = colors.finish; ctx.lineWidth = 2; ctx.stroke();
                }

                // Passes
                ctx.beginPath();
                calculatedData.passes.forEach(pass => {
                    if (pass.type === 'long') {
                        const p1 = toScreen(pass.x, pass.zStart); const p2 = toScreen(pass.x, pass.zEnd);
                        ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                    } else {
                        const p1 = toScreen(pass.xStart, pass.z); const p2 = toScreen(pass.xEnd, pass.z);
                        ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                    }
                });
                ctx.strokeStyle = colors.pass; ctx.lineWidth = 1.5; ctx.stroke();

                if (calculatedData.simPath.length > 0) {
                    ctx.beginPath();
                    for (let i = 0; i < calculatedData.simPath.length - 1; i++) {
                        const p1 = calculatedData.simPath[i];
                        const p2 = calculatedData.simPath[i+1];
                        if (p2.type === 'G0') {
                            const s = toScreen(p1.x, p1.z);
                            const e = toScreen(p2.x, p2.z);
                            if (Math.abs(s.x - e.x) > 0.1 || Math.abs(s.y - e.y) > 0.1) {
                                ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y);
                            }
                        }
                    }
                    ctx.strokeStyle = theme === 'dark' ? '#ef4444' : '#ef4444'; ctx.lineWidth = 1.5; 
                    ctx.setLineDash([6, 6]); ctx.stroke(); ctx.setLineDash([]);
                }

                if ((simRunning || simProgress > 0) && calculatedData.simPath.length > 0) {
                    const totalPoints = calculatedData.simPath.length;
                    const floatIndex = simProgress * (totalPoints - 1);
                    const idx = Math.floor(floatIndex);
                    const t = floatIndex - idx;
                    const pCurrent = calculatedData.simPath[idx];
                    
                    // Bezpečnostní kontrola: Zabrání pádu pokud indexy nesedí (např. při změně dat za běhu)
                    if (pCurrent) {
                        const pNext = calculatedData.simPath[Math.min(idx + 1, totalPoints - 1)] || pCurrent;
                        const curX = pCurrent.x + (pNext.x - pCurrent.x) * t;
                        const curZ = pCurrent.z + (pNext.z - pCurrent.z) * t;
                        const pt = toScreen(curX, curZ);
                        
                        ctx.fillStyle = colors.tool; ctx.beginPath();
                        ctx.moveTo(pt.x, pt.y); ctx.lineTo(pt.x + 8, pt.y + 12); ctx.lineTo(pt.x - 8, pt.y + 12);
                        ctx.closePath(); ctx.fill(); ctx.strokeStyle = 'black'; ctx.lineWidth = 1; ctx.stroke();
                    }
                }

                if (!simRunning) {
                    const activePoints = editMode === 'contour' ? calculatedData.worldPoints : calculatedData.stockWorldPoints;
                    ctx.font = "bold 11px sans-serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                    if(activePoints) {
                        activePoints.forEach((p, i) => {
                            if (!p) return;
                            const pt = toScreen(p.xReal, p.zReal);
                            ctx.fillStyle = editMode === 'contour' ? colors.contour : colors.pass;
                            ctx.beginPath(); ctx.arc(pt.x, pt.y, 3, 0, Math.PI*2); ctx.fill();
                            const label = `${i+1}`; const tx = pt.x + 8; const ty = pt.y - 8;
                            ctx.fillStyle = theme === 'dark' ? '#fbbf24' : '#d97706'; ctx.fillText(label, tx, ty);
                        });
                    }
                }

            }, [calculatedData, view, theme, params, editMode, mobileTab, simRunning, simProgress]);

            useEffect(() => {
                if (!containerRef.current || !canvasRef.current) return;
                const resizeObserver = new ResizeObserver(() => { draw(); });
                resizeObserver.observe(containerRef.current);
                return () => resizeObserver.disconnect();
            }, [draw]);

            const handleWheel = (e) => { const s = Math.max(0.2, Math.min(view.scale * (1 - Math.sign(e.deltaY)*0.15), 50)); setView(v => ({...v, scale: s})); };
            const handleMouseDown = (e) => { setIsDragging(true); lastMousePos.current = { x: e.clientX, y: e.clientY }; };
            const handleMouseMove = (e) => {
                if (!isDragging) return;
                const dx = e.clientX - lastMousePos.current.x; const dy = e.clientY - lastMousePos.current.y;
                setView(v => ({ ...v, panX: v.panX + dx, panY: v.panY + dy }));
                lastMousePos.current = { x: e.clientX, y: e.clientY };
            };
            const handleMouseUp = () => setIsDragging(false);

            const handleTouchStart = (e) => {
                if (e.touches.length === 1) {
                    setIsDragging(true);
                    lastMousePos.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2) {
                    const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    lastPinchDist.current = dist;
                }
            };

            const handleTouchMove = (e) => {
                if (isDragging && e.touches.length === 1) {
                    const dx = e.touches[0].clientX - lastMousePos.current.x;
                    const dy = e.touches[0].clientY - lastMousePos.current.y;
                    setView(v => ({ ...v, panX: v.panX + dx, panY: v.panY + dy }));
                    lastMousePos.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
                if (e.touches.length === 2 && lastPinchDist.current) {
                    const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    const zoomFactor = dist / lastPinchDist.current;
                    setView(v => { const newScale = Math.max(0.2, Math.min(v.scale * zoomFactor, 50)); return { ...v, scale: newScale }; });
                    lastPinchDist.current = dist;
                }
            };

            const handleTouchEnd = () => {
                setIsDragging(false);
                lastPinchDist.current = null;
            };

            const processGCodeString = (text) => {
                const lines = text.split('\n'); const newPoints = []; let currentType = 'G1'; let idCounter = Date.now(); let lastX = 100; let lastZ = 0;
                lines.forEach(line => {
                    const clean = line.toUpperCase().trim(); if (!clean || clean.startsWith(';')) return;
                    const gMatch = clean.match(/G([0-3])/); if (gMatch) currentType = 'G' + gMatch[1];
                    const xMatch = clean.match(/X([-]?\d+\.?\d*)/); const zMatch = clean.match(/Z([-]?\d+\.?\d*)/); const rMatch = clean.match(/(?:R|CR=)([-]?\d+\.?\d*)/);
                    if (xMatch || zMatch) {
                        const newX = xMatch ? parseFloat(xMatch[1]) : lastX; const newZ = zMatch ? parseFloat(zMatch[1]) : lastZ;
                        newPoints.push({ id: idCounter++, type: currentType, x: newX, z: newZ, r: rMatch ? parseFloat(rMatch[1]) : 0, mode: 'ABS' });
                        lastX = newX; lastZ = newZ;
                    }
                });
                if (newPoints.length > 0) {
                    if (editMode === 'contour') setContourPoints(newPoints); else setStockPoints(newPoints); 
                    setErrors([]); fitView(); 
                } else alert("Nepodařilo se rozpoznat žádné body v G-kódu.");
            };
            const parseGCode = () => processGCodeString(gCodeInput);
            const handleCopyGCode = () => { /* ... same ... */ };
            const handleDownload = () => { /* ... same ... */ };
            const toggleMode = (id) => { /* ... same ... */ };
            const updatePoint = (id, f, v) => {
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                setList(prev => prev.map(p => p.id===id ? {...p, [f]: v} : p));
            };
            const addPoint = () => { const list = editMode === 'contour' ? contourPoints : stockPoints; const setList = editMode === 'contour' ? setContourPoints : setStockPoints; const last = list.length > 0 ? list[list.length - 1] : { x: 100, z: 0 }; setList([...list, {id: Date.now(), type:'G1', x:last.x, z: parseFloat(last.z)-10, r:0, mode: 'ABS'}]); };
            const insertPoint = (index) => { const list = editMode === 'contour' ? contourPoints : stockPoints; const setList = editMode === 'contour' ? setContourPoints : setStockPoints; const prev = list[index]; const newPoint = { ...prev, id: Date.now(), z: parseFloat(prev.z) - 5 }; const newList = [...list]; newList.splice(index + 1, 0, newPoint); setList(newList); };
            const removePoint = (id) => { const list = editMode === 'contour' ? contourPoints : stockPoints; const setList = editMode === 'contour' ? setContourPoints : setStockPoints; if (list.length > 1) setList(list.filter(p=>p.id!==id)); };
            const currentPoints = editMode === 'contour' ? contourPoints : stockPoints;

            // Helper to check if a line is "active" based on simulation progress
            const isLineActive = (line, idx) => {
                if (line.simIdx === null) return false;
                const totalPoints = calculatedData.simPath.length;
                if (totalPoints === 0) return false;
                const currentIdx = Math.floor(simProgress * (totalPoints - 1));
                
                // Find next line with simIdx
                let nextSimIdx = null;
                for (let j = idx + 1; j < generatedCode.length; j++) {
                    if (generatedCode[j].simIdx !== null) {
                        nextSimIdx = generatedCode[j].simIdx;
                        break;
                    }
                }
                
                if (nextSimIdx === null) return currentIdx >= line.simIdx; // Last instruction
                return currentIdx >= line.simIdx && currentIdx < nextSimIdx;
            };

            return (
                <div className="flex flex-col md:flex-row h-full">
                    <div className={`${mobileTab === 'editor' ? 'flex' : 'hidden'} md:flex w-full md:w-96 flex-col border-r shadow-xl z-10 h-full overflow-hidden ${theme === 'dark' ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'}`}>
                        <div className={`p-4 border-b flex justify-between items-center ${theme === 'dark' ? 'bg-gray-900 border-gray-700' : 'bg-gray-100 border-gray-200'}`}>
                            <h1 className="font-bold text-lg text-blue-500">Sinumerik CAM <span className="text-xs text-gray-400 font-normal">v1.4</span></h1>
                            <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')} className="p-2 rounded hover:bg-gray-700 hover:text-white transition-colors">
                                {theme === 'light' ? <IconMoon /> : <IconSun />}
                            </button>
                        </div>
                        {errors.length > 0 && (
                            <div className="bg-red-50 border-l-4 border-red-500 text-red-700 p-2 text-xs">
                                <div className="font-bold flex gap-2 items-center"><IconWarning /> Nalezeny problémy:</div>
                                <ul className="list-disc pl-6 mt-1 space-y-1">{errors.map((e, i) => <li key={i}>{e.msg || e}</li>)}</ul>
                            </div>
                        )}
                        <div className="flex border-b border-gray-200 dark:border-gray-700">
                             {['editor', 'params', 'import'].map(tab => (
                                <button key={tab} onClick={() => setActiveTab(tab)} 
                                    className={`flex-1 p-3 text-sm font-medium capitalize ${activeTab===tab ? 'bg-blue-100 text-blue-700' : 'text-gray-500'}`}>
                                    {tab}
                                </button>
                            ))}
                        </div>
                         <div className="flex-1 overflow-y-auto p-4 custom-scrollbar pb-20 md:pb-4">
                            {activeTab === 'editor' && (
                                <div className="space-y-3">
                                    <div className="flex gap-2 mb-2 bg-gray-200 p-1 rounded dark:bg-gray-700">
                                        <button onClick={() => setEditMode('contour')} className={`flex-1 flex items-center justify-center gap-2 text-xs py-1.5 rounded font-bold transition-all ${editMode==='contour' ? 'bg-white shadow text-blue-600 dark:bg-gray-600 dark:text-blue-300' : 'text-gray-500 hover:text-gray-700'}`}><IconEdit /> Kontura</button>
                                        <button onClick={() => { setEditMode('stock'); if(stockPoints.length === 0) generateDefaultStock(); }} className={`flex-1 flex items-center justify-center gap-2 text-xs py-1.5 rounded font-bold transition-all ${editMode==='stock' ? 'bg-white shadow text-green-600 dark:bg-gray-600 dark:text-green-300' : 'text-gray-500 hover:text-gray-700'}`}><IconBox /> Polotovar</button>
                                    </div>
                                    <div className="flex gap-1 px-2 text-xs font-bold text-gray-500 mb-1">
                                        <div className="w-6 text-center">#</div>
                                        <div className="w-14">Typ</div>
                                        <div className="w-8 text-center">Mód</div>
                                        <div className="w-16 text-center">X/U</div>
                                        <div className="w-16 text-center">Z/W</div>
                                        <div className="w-10 text-center">R</div>
                                    </div>
                                    {currentPoints.map((p, index) => (
                                        <div key={p.id} className={`border rounded p-2 flex flex-wrap gap-1 items-center ${theme === 'dark' ? 'bg-gray-750 border-gray-600' : 'bg-gray-50 border-gray-300'} ${editMode==='stock' ? 'border-l-4 border-l-green-500' : 'border-l-4 border-l-blue-500'}`}>
                                            <div className="w-6 font-mono text-xs text-gray-500 font-bold">{index+1}</div>
                                            <select value={p.type} onChange={(e) => updatePoint(p.id, 'type', e.target.value)} className={`border rounded text-xs px-1 py-1 w-14 ${theme==='dark'?'bg-gray-900 border-gray-600':'bg-white border-gray-300'}`}><option>G0</option><option>G1</option><option>G2</option><option>G3</option></select>
                                            <button onClick={() => toggleMode(p.id)} className={`w-8 h-6 flex items-center justify-center rounded text-xs font-bold ${p.mode==='INC' ? 'bg-purple-100 text-purple-700 border border-purple-300' : 'bg-gray-100 text-gray-600 border border-gray-300'}`} title={p.mode === 'INC' ? 'Přírůstkově' : 'Absolutně'}>{p.mode === 'INC' ? 'INC' : 'ABS'}</button>
                                            <SmartInput type="number" value={p.x} onValueChange={(v) => updatePoint(p.id, 'x', v)} className={`border rounded text-sm w-16 px-1 py-1 ${theme==='dark'?'bg-gray-900 border-gray-600':'bg-white border-gray-300'}`} placeholder={p.mode==='INC' ? 'U' : 'X'} />
                                            <SmartInput type="number" value={p.z} onValueChange={(v) => updatePoint(p.id, 'z', v)} className={`border rounded text-sm w-16 px-1 py-1 ${theme==='dark'?'bg-gray-900 border-gray-600':'bg-white border-gray-300'}`} placeholder={p.mode==='INC' ? 'W' : 'Z'} />
                                            {(p.type === 'G2' || p.type === 'G3') && <SmartInput type="number" value={p.r} onValueChange={(v) => updatePoint(p.id, 'r', v)} className={`border rounded text-sm w-10 px-1 py-1 ${theme==='dark'?'bg-gray-900 border-gray-600':'bg-white border-gray-300'}`} placeholder="R" />}
                                            <div className="flex ml-auto gap-1">
                                                <button onClick={() => insertPoint(index)} className="text-blue-500 hover:text-blue-700 p-1" title="Vložit řádek za"><IconInsert /></button>
                                                <button onClick={() => removePoint(p.id)} className="text-red-400 hover:text-red-600 p-1" title="Smazat řádek"><IconTrash /></button>
                                            </div>
                                        </div>
                                    ))}
                                    <div className="grid grid-cols-2 gap-2">
                                        <button onClick={addPoint} className={`col-span-2 py-2 text-white rounded text-sm font-bold flex justify-center items-center gap-2 ${editMode==='stock'?'bg-green-600 hover:bg-green-500':'bg-blue-600 hover:bg-blue-500'}`}><IconPlus /> Přidat bod</button>
                                        <button onClick={handleCopyGCode} className={`py-2 text-white rounded text-sm font-bold flex justify-center items-center gap-2 transition-all ${copyFeedback ? 'bg-green-600' : 'bg-gray-600 hover:bg-gray-500'}`}><IconClipboard /> {copyFeedback ? "Zkopírováno" : "Kopírovat"}</button>
                                        <button onClick={handleDownload} className="py-2 text-white rounded text-sm font-bold flex justify-center items-center gap-2 bg-purple-600 hover:bg-purple-500"><IconDownload /> Uložit MPF</button>
                                    </div>
                                </div>
                            )}
                             {activeTab === 'params' && (
                                <div className="space-y-4">
                                    <h3 className={`font-bold border-b pb-1 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Polotovar</h3>
                                    <div className="flex gap-2 mb-2">
                                        <button onClick={() => setParams({...params, stockMode: 'cylinder'})} className={`flex-1 py-1 text-xs border rounded ${params.stockMode==='cylinder' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Válec</button>
                                        <button onClick={() => { setParams({...params, stockMode: 'casting'}); setActiveTab('editor'); setEditMode('stock'); if(stockPoints.length === 0) generateDefaultStock(); }} className={`flex-1 py-1 text-xs border rounded ${params.stockMode==='casting' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Vlastní tvar</button>
                                    </div>
                                    {params.stockMode === 'cylinder' ? (
                                        <div className="space-y-2">
                                            <div className="flex items-end gap-2">
                                                <div className="flex-1"><label className="text-xs text-gray-500">Průměr (D)</label><SmartInput type="number" value={params.stockDiameter} onValueChange={v=>setParams({...params, stockDiameter:v})} className="border rounded p-1 w-full"/></div>
                                                <div className="flex-1"><label className="text-xs text-gray-500">Délka (Z-)</label><SmartInput type="number" value={params.stockLength} onValueChange={v=>setParams({...params, stockLength:v})} className="border rounded p-1 w-full"/></div>
                                            </div>
                                            <div className="flex items-end gap-2">
                                                <div className="flex-1"><label className="text-xs text-gray-500">Přídavek čelo (Z+)</label><SmartInput type="number" value={params.stockFace} onValueChange={v=>setParams({...params, stockFace:v})} className="border rounded p-1 w-full"/></div>
                                                <div className="flex-1"><label className="text-xs text-gray-500">Přídavek (pro Auto)</label><SmartInput type="number" value={params.stockMargin} onValueChange={v=>setParams({...params, stockMargin:v})} className="border rounded p-1 w-full"/></div>
                                            </div>
                                            <button onClick={handleAutoStock} className="w-full py-1.5 bg-indigo-600 text-white rounded text-xs font-bold flex items-center justify-center gap-1 hover:bg-indigo-500"><IconMagic /> Auto-rozměr</button>
                                        </div>
                                    ) : (
                                        <div className="text-xs text-gray-500 italic p-2 bg-gray-100 rounded dark:bg-gray-800">Pro definici tvarového polotovaru (odlitku) použijte přepínač "Polotovar" v záložce <b>Editor</b> a nakreslete jeho tvar.</div>
                                    )}
                                    <h3 className={`font-bold border-b pb-1 mt-4 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Hrubování</h3>
                                    <div className="flex gap-2 mb-2">
                                        <button onClick={() => setParams({...params, roughingStrategy: 'longitudinal'})} className={`flex-1 py-1 text-xs border rounded flex items-center justify-center gap-1 ${params.roughingStrategy==='longitudinal' ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-700'}`}><IconArrowRight /> Podélně (Z)</button>
                                        <button onClick={() => setParams({...params, roughingStrategy: 'face'})} className={`flex-1 py-1 text-xs border rounded flex items-center justify-center gap-1 ${params.roughingStrategy==='face' ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-700'}`}><IconArrowDown /> Čelně (X)</button>
                                    </div>
                                    <div className="grid grid-cols-2 gap-2">
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Hloubka (ap)</label><SmartInput type="number" step="0.5" value={params.depthOfCut} onValueChange={v=>setParams({...params, depthOfCut:v})} className="border rounded p-1"/></div>
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Posuv (F)</label><SmartInput type="number" step="0.05" value={params.feed} onValueChange={v=>setParams({...params, feed:v})} className="border rounded p-1"/></div>
                                        <div className="flex flex-col col-span-2"><label className="text-xs text-gray-500">Odskok (G1 -> G0)</label><SmartInput type="number" step="0.5" value={params.retractDistance} onValueChange={v=>setParams({...params, retractDistance:v})} className="border rounded p-1"/></div>
                                    </div>
                                    <h3 className={`font-bold border-b pb-1 mt-4 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Nástroj</h3>
                                    <div className="grid grid-cols-2 gap-2">
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Rádius (R)</label><SmartInput type="number" step="0.1" value={params.toolRadius} onValueChange={v=>setParams({...params, toolRadius:v})} className="border rounded p-1"/></div>
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Přídavek X</label><SmartInput type="number" step="0.1" value={params.allowanceX} onValueChange={v=>setParams({...params, allowanceX:v})} className="border rounded p-1"/></div>
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Přídavek Z</label><SmartInput type="number" step="0.1" value={params.allowanceZ} onValueChange={v=>setParams({...params, allowanceZ:v})} className="border rounded p-1"/></div>
                                    </div>
                                    <div className="mt-4 pt-2 border-t dark:border-gray-700">
                                        <label className="flex items-center space-x-2 cursor-pointer">
                                            <input type="checkbox" checked={params.doFinishing} onChange={e => setParams({...params, doFinishing: e.target.checked})} className="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600" />
                                            <span className="text-sm font-bold text-gray-700 dark:text-gray-300">Dokončovací operace (Na čisto)</span>
                                        </label>
                                        <p className="text-xs text-gray-500 mt-1 pl-6">Vygeneruje dráhu nástroje přesně po kontuře (pouze s korekcí R, bez přídavku).</p>
                                    </div>
                                    
                                    <div className="mt-8 pt-4 border-t dark:border-gray-700 flex justify-center">
                                        <button onClick={handleResetApp} className="text-xs text-red-500 hover:text-red-700 flex items-center gap-1">
                                            <IconRefresh /> Resetovat vše (Vymazat uložené)
                                        </button>
                                    </div>
                                </div>
                            )}
                             {activeTab === 'import' && (
                                <div className="flex flex-col h-full">
                                    <textarea className="flex-1 border p-2 font-mono text-xs mb-2" value={gCodeInput} onChange={e=>setGCodeInput(e.target.value)} placeholder="G1 X... Z..."></textarea>
                                    <button onClick={parseGCode} className="bg-green-600 text-white py-2 rounded">Import</button>
                                </div>
                            )}
                        </div>
                    </div>

                     <div className={`${mobileTab === 'preview' ? 'flex' : 'hidden'} md:flex flex-1 flex-col relative pb-20 md:pb-0 ${theme === 'dark' ? 'bg-gray-900' : 'bg-gray-50'}`}>
                        <div className="absolute top-4 right-4 z-10 flex gap-2">
                            <div className="bg-white p-1 rounded shadow flex gap-1 items-center">
                                <button onClick={toggleSimulation} className={`p-1 rounded hover:bg-green-100 ${simRunning ? 'text-green-600' : 'text-gray-600'}`} title={simRunning ? "Pauza" : "Spustit"}>
                                    {simRunning ? <IconPause /> : <IconPlay />}
                                </button>
                                <button onClick={stopSimulation} className="p-1 rounded hover:bg-red-100 text-gray-600" title="Stop"><IconStop /></button>
                            </div>
                            <button onClick={fitView} className="bg-white p-2 rounded shadow text-gray-700 hover:text-blue-600" title="Centrovat pohled"><IconTarget /></button>
                        </div>
                        <div ref={containerRef} className={`flex-1 overflow-hidden relative canvas-container`}
                             onWheel={handleWheel} 
                             onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp}
                             onTouchStart={handleTouchStart} onTouchMove={handleTouchMove} onTouchEnd={handleTouchEnd}>
                            <canvas ref={canvasRef} className="block" />
                        </div>
                        <div ref={codeContainerRef} className={`h-48 border-t flex flex-col overflow-y-auto ${theme === 'dark' ? 'bg-gray-950 border-gray-700' : 'bg-white border-gray-300'}`}>
                             {/* nahrazeno textarea za interaktivní seznam */}
                             <div className="font-mono text-xs p-2">
                                {generatedCode.map((line, idx) => (
                                    <div 
                                        key={idx} 
                                        onClick={() => handleLineClick(line.simIdx)}
                                        className={`code-line whitespace-pre px-2 py-0.5 cursor-pointer ${isLineActive(line, idx) ? 'active' : ''} ${theme === 'dark' ? 'text-green-300' : 'text-gray-800'}`}
                                    >
                                        {line.text}
                                    </div>
                                ))}
                             </div>
                        </div>
                    </div>

                    <div className="md:hidden fixed bottom-0 left-0 right-0 h-16 bg-white border-t border-gray-200 flex z-50 safe-pb dark:bg-gray-900 dark:border-gray-700">
                        <button onClick={() => setMobileTab('editor')} className={`flex-1 flex flex-col items-center justify-center ${mobileTab==='editor' ? 'text-blue-600' : 'text-gray-500'}`}>
                            <IconEdit />
                            <span className="text-xs font-bold mt-1">Editor</span>
                        </button>
                        <button onClick={() => setMobileTab('preview')} className={`flex-1 flex flex-col items-center justify-center ${mobileTab==='preview' ? 'text-blue-600' : 'text-gray-500'}`}>
                            <IconEye />
                            <span className="text-xs font-bold mt-1">Náhled</span>
                        </button>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
