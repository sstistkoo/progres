<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Generátor CAM pro Sinumerik 840D (Auto-Fit)</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel Standalone -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { overscroll-behavior: none; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #9ca3af; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        .canvas-container { cursor: crosshair; touch-action: none; background-image: radial-gradient(#ccc 1px, transparent 1px); background-size: 20px 20px; }
        .dark .canvas-container { background-image: radial-gradient(#333 1px, transparent 1px); }
        .safe-pb { padding-bottom: env(safe-area-inset-bottom); }
    </style>
</head>
<body class="h-screen w-screen overflow-hidden flex flex-col font-sans transition-colors duration-300">

    <div id="root" class="h-full w-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        // --- ICONS ---
        const IconTrash = () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;
        const IconPlus = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>;
        const IconSun = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>;
        const IconMoon = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>;
        const IconEdit = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path></svg>;
        const IconBox = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>;
        const IconMagic = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><path d="m12 2 2.5 5.5L20 9l-4 3.5L17.5 18 12 15l-5.5 3L8 12.5 4 9l5.5-1.5L12 2z"></path></svg>;
        const IconClipboard = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>;
        const IconInsert = () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>;
        const IconTarget = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line></svg>;
        const IconEye = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>;
        const IconPlay = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M5 3l14 9-14 9V3z"/></svg>;
        const IconStop = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="none"><rect x="6" y="6" width="12" height="12" /></svg>;
        const IconDownload = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>;
        const IconArrowRight = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>;
        const IconArrowDown = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline></svg>;

        // --- MATH HELPERS ---
        const dist = (p1, p2) => Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.z - p1.z, 2));

        const getNormal = (p1, p2) => {
            const dx = p2.x - p1.x;
            const dz = p2.z - p1.z;
            const l = Math.sqrt(dx*dx + dz*dz);
            if (l===0) return {x:0, z:0};
            return { x: -dz/l, z: dx/l };
        };

        const getArcParams = (p1, p2, r, type) => {
            const d2 = Math.pow(p2.x - p1.x, 2) + Math.pow(p2.z - p1.z, 2);
            const d = Math.sqrt(d2);
            let safeR = r;
            let error = false;
            if (d2 === 0) return { error: true, cx: p1.x, cz: p1.z, r: 0 };
            if (Math.abs(r) < d/2) {
                error = true;
                safeR = d/2 + 0.001; 
            }
            const mx = (p1.x + p2.x) / 2;
            const mz = (p1.z + p2.z) / 2;
            const h = Math.sqrt(Math.max(0, safeR*safeR - d2/4));
            const dx = p2.x - p1.x;
            const dz = p2.z - p1.z;
            const ox = -dz / d;
            const oz = dx / d;
            const sign = (type === 'G3') ? -1 : 1; 
            const cx = mx + sign * h * ox;
            const cz = mz + sign * h * oz;
            return { cx, cz, r: safeR, error };
        };

        const isAngleBetween = (target, start, end, isG2) => {
            const t = (target % (2*Math.PI) + 2*Math.PI) % (2*Math.PI);
            const s = (start % (2*Math.PI) + 2*Math.PI) % (2*Math.PI);
            const e = (end % (2*Math.PI) + 2*Math.PI) % (2*Math.PI);
            if (isG2) { 
                if (s >= e) return t <= s && t >= e;
                return t <= s || t >= e; 
            } else { 
                if (e >= s) return t >= s && t <= e;
                return t >= s || t <= e; 
            }
        };

        const intersectHorizontalLineSegment = (xLine, p1, p2) => {
            const minX = Math.min(p1.x, p2.x);
            const maxX = Math.max(p1.x, p2.x);
            if (xLine < minX || xLine > maxX) return null;
            if (Math.abs(p2.x - p1.x) < 1e-6) return null;
            const t = (xLine - p1.x) / (p2.x - p1.x);
            return p1.z + t * (p2.z - p1.z);
        };

        const intersectHorizontalLineArc = (xLine, center, radius) => {
            const term = radius*radius - Math.pow(xLine - center.x, 2);
            if (term < 0) return [];
            const sqrtTerm = Math.sqrt(term);
            return [center.z - sqrtTerm, center.z + sqrtTerm];
        };

        const intersectVerticalLineSegment = (zLine, p1, p2) => {
            const minZ = Math.min(p1.z, p2.z);
            const maxZ = Math.max(p1.z, p2.z);
            if (zLine < minZ || zLine > maxZ) return null;
            if (Math.abs(p2.z - p1.z) < 1e-6) return null;
            const t = (zLine - p1.z) / (p2.z - p1.z);
            return p1.x + t * (p2.x - p1.x);
        };

        const intersectVerticalLineArc = (zLine, center, radius) => {
            const term = radius*radius - Math.pow(zLine - center.z, 2);
            if (term < 0) return [];
            const sqrtTerm = Math.sqrt(term);
            return [center.x - sqrtTerm, center.x + sqrtTerm];
        };

        // --- APP ---
        const App = () => {
            const [theme, setTheme] = useState('light');
            const [editMode, setEditMode] = useState('contour'); 
            const [mobileTab, setMobileTab] = useState('editor'); 
            const [copyFeedback, setCopyFeedback] = useState(false);
            
            const [simRunning, setSimRunning] = useState(false);
            const [simProgress, setSimProgress] = useState(0); 

            const [params, setParams] = useState({
                machineType: 'LIMS=2000',
                mode: 'DIAMON',
                toolName: 'ROUGHER_T1',
                speed: 200,
                feed: 0.25,
                depthOfCut: 2.0,
                allowanceX: 0.5,
                allowanceZ: 0.1,
                toolRadius: 0.8,
                doFinishing: true, 
                roughingStrategy: 'longitudinal',
                stockMode: 'cylinder', 
                stockMargin: 5.0, 
                stockDiameter: 100, 
                stockLength: 100,
                stockFace: 2.0,
                safeX: 150,
                safeZ: 5
            });

            const [contourPoints, setContourPoints] = useState([
                { id: 1, type: 'G0', x: 100, z: 0, r: 0, mode: 'ABS' },
                { id: 2, type: 'G1', x: 20, z: 0, r: 0, mode: 'ABS' },
                { id: 3, type: 'G1', x: 20, z: -20, r: 0, mode: 'ABS' },
                { id: 4, type: 'G2', x: 40, z: -30, r: 10, mode: 'ABS' },
                { id: 5, type: 'G1', x: 40, z: -50, r: 0, mode: 'ABS' },
                { id: 6, type: 'G1', x: 60, z: -60, r: 0, mode: 'ABS' }
            ]);

            const [stockPoints, setStockPoints] = useState([
                { id: 101, type: 'G0', x: 105, z: 2, r: 0, mode: 'ABS' },
                { id: 102, type: 'G1', x: 105, z: -100, r: 0, mode: 'ABS' },
                { id: 103, type: 'G1', x: 0, z: -100, r: 0, mode: 'ABS' }
            ]);
            
            const [errors, setErrors] = useState([]);
            const [gCodeInput, setGCodeInput] = useState('');
            const [generatedCode, setGeneratedCode] = useState('');
            const [activeTab, setActiveTab] = useState('editor');
            
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const [view, setView] = useState({ scale: 3, panX: 600, panY: 350 });
            const [isDragging, setIsDragging] = useState(false);
            const lastMousePos = useRef({ x: 0, y: 0 });

            useEffect(() => {
                document.body.className = `h-screen w-screen overflow-hidden flex flex-col font-sans transition-colors duration-300 ${theme === 'dark' ? 'bg-gray-900 text-gray-100' : 'bg-gray-50 text-gray-900'}`;
            }, [theme]);

            const fitView = useCallback(() => {
                if (!containerRef.current) return;
                const points = resolvePointsToAbsolute(contourPoints);
                if (points.length === 0) return;

                let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
                points.forEach(p => {
                    const x = params.mode === 'DIAMON' ? p.xAbs / 2 : p.xAbs;
                    const z = p.zAbs;
                    if(x < minX) minX = x; if(x > maxX) maxX = x;
                    if(z < minZ) minZ = z; if(z > maxZ) maxZ = z;
                });

                const pad = 20;
                const width = maxZ - minZ + pad*2;
                const height = maxX - minX + pad*2;
                if (width <= 0 || height <= 0) return;

                const contW = containerRef.current.clientWidth;
                const contH = containerRef.current.clientHeight;
                if (contW === 0 || contH === 0) return;

                const scaleX = contW / width;
                const scaleY = contH / height;
                let newScale = Math.min(scaleX, scaleY) * 0.8; 
                if (newScale > 10) newScale = 10;
                if (newScale < 0.1) newScale = 0.1;

                const midZ = (minZ + maxZ) / 2;
                const midX = (minX + maxX) / 2;
                
                setView({
                    scale: newScale,
                    panX: contW/2 - midZ * newScale,
                    panY: contH/2 + midX * newScale
                });

            }, [contourPoints, params.mode]);

            useEffect(() => {
                setTimeout(fitView, 100);
            }, [mobileTab]); 

            const handleAutoStock = () => {
                const points = resolvePointsToAbsolute(contourPoints);
                let maxD = 0;
                let minZ = 0;
                let maxZ = -9999;
                
                points.forEach(p => {
                    const xVal = p.xAbs; 
                    const zVal = p.zAbs;
                    let d = xVal;
                    if (params.mode !== 'DIAMON') d = xVal * 2;
                    
                    if (d > maxD) maxD = d;
                    if (zVal < minZ) minZ = zVal;
                    if (zVal > maxZ) maxZ = zVal;
                });

                if (maxZ === -9999) maxZ = 0;
                const margin = parseFloat(params.stockMargin) || 0;
                
                setParams(prev => ({
                    ...prev,
                    stockDiameter: Math.ceil(maxD + margin * 2),
                    stockLength: Math.ceil(Math.abs(minZ) + margin),
                    stockFace: Math.ceil(maxZ + margin)
                }));
            };

            const generateDefaultStock = () => {
                const points = resolvePointsToAbsolute(contourPoints);
                let maxX = 0; let minZ = 0;
                points.forEach(p => {
                    if(p.xAbs > maxX) maxX = p.xAbs;
                    if(p.zAbs < minZ) minZ = p.zAbs;
                });
                const stockX = maxX + 5;
                const stockZ = minZ - 5;
                setStockPoints([
                    { id: Date.now(), type: 'G0', x: stockX, z: 2, r: 0, mode: 'ABS' },
                    { id: Date.now()+1, type: 'G1', x: stockX, z: stockZ, r: 0, mode: 'ABS' },
                    { id: Date.now()+2, type: 'G1', x: 0, z: stockZ, r: 0, mode: 'ABS' }
                ]);
            };

            const resolvePointsToAbsolute = (pts) => {
                let lastX = 0; 
                let lastZ = 0;
                return pts.map((p, index) => {
                    const valX = parseFloat(p.x) || 0;
                    const valZ = parseFloat(p.z) || 0;
                    let absX = valX;
                    let absZ = valZ;

                    if (p.mode === 'INC') {
                        absX = lastX + valX;
                        absZ = lastZ + valZ;
                    } else {
                        absX = valX;
                        absZ = valZ;
                    }
                    
                    lastX = absX;
                    lastZ = absZ;

                    return { ...p, xAbs: absX, zAbs: absZ, rVal: parseFloat(p.r) || 0 };
                });
            };

            const calculatedData = useMemo(() => {
                const absContour = resolvePointsToAbsolute(contourPoints);
                const absStock = resolvePointsToAbsolute(stockPoints);

                const worldPoints = absContour.map(p => ({
                    ...p,
                    xReal: params.mode === 'DIAMON' ? p.xAbs / 2 : p.xAbs, 
                    zReal: p.zAbs
                }));

                const stockWorldPoints = absStock.map(p => ({
                    ...p,
                    xReal: params.mode === 'DIAMON' ? p.xAbs / 2 : p.xAbs, 
                    zReal: p.zAbs
                }));

                const tipR = parseFloat(params.toolRadius) || 0;
                const allowanceX = parseFloat(params.allowanceX) || 0;
                const allowanceZ = parseFloat(params.allowanceZ) || 0;
                const totalOffset = tipR + Math.max(allowanceX, allowanceZ);
                
                // IMPORTANT: Increase visual retract distance to be clearly visible
                const retractDist = 2.0; 
                
                let contourSegments = [];
                let offsetPath = [];
                let finishOffsetPath = [];
                let stockPathSegments = []; 
                const foundErrors = [];

                // --- Process Contour Segments ---
                for (let i = 0; i < worldPoints.length - 1; i++) {
                    const p1 = worldPoints[i];
                    const p2 = worldPoints[i+1];
                    const type = p2.type;
                    if (type === 'G0' || type === 'G1') {
                        contourSegments.push({ type: 'line', p1: {x:p1.xReal, z:p1.zReal}, p2: {x:p2.xReal, z:p2.zReal}, orig: p2 });
                    } else if (type === 'G2' || type === 'G3') {
                        const arc = getArcParams({x:p1.xReal, z:p1.zReal}, {x:p2.xReal, z:p2.zReal}, p2.rVal, type);
                        if (arc.error) foundErrors.push(`Kontura #${p2.id}: Rádius R${p2.r} je příliš malý.`);
                        contourSegments.push({ type: 'arc', ...arc, p1: {x:p1.xReal, z:p1.zReal}, p2: {x:p2.xReal, z:p2.zReal}, dir: type });
                    }
                }

                // --- Process Stock Segments ---
                for (let i = 0; i < stockWorldPoints.length - 1; i++) {
                    const p1 = stockWorldPoints[i];
                    const p2 = stockWorldPoints[i+1];
                    const type = p2.type;
                    if (type === 'G0' || type === 'G1') {
                        stockPathSegments.push({ type: 'line', p1: {x:p1.xReal, z:p1.zReal}, p2: {x:p2.xReal, z:p2.zReal} });
                    } else if (type === 'G2' || type === 'G3') {
                        const arc = getArcParams({x:p1.xReal, z:p1.zReal}, {x:p2.xReal, z:p2.zReal}, p2.rVal, type);
                        const startAngle = Math.atan2(p1.xReal - arc.cx, p1.zReal - arc.cz);
                        const endAngle = Math.atan2(p2.xReal - arc.cx, p2.zReal - arc.cz);
                        stockPathSegments.push({ type: 'arc', ...arc, dir: type, startAngle, endAngle });
                    }
                }

                // --- Generate Roughing Offset Path ---
                for (let i = 0; i < contourSegments.length; i++) {
                    const seg = contourSegments[i];
                    let offSeg = null;
                    if (seg.type === 'line') {
                        const n = getNormal(seg.p1, seg.p2);
                        offSeg = { type: 'line', p1: { x: seg.p1.x + n.x * totalOffset, z: seg.p1.z + n.z * totalOffset }, p2: { x: seg.p2.x + n.x * totalOffset, z: seg.p2.z + n.z * totalOffset } };
                    } else if (seg.type === 'arc') {
                        let rNew = (seg.dir === 'G3') ? seg.r + totalOffset : seg.r - totalOffset;
                        if (rNew < 0) rNew = 0.001; 
                        const startAngle = Math.atan2(seg.p1.x - seg.cx, seg.p1.z - seg.cz);
                        const endAngle = Math.atan2(seg.p2.x - seg.cx, seg.p2.z - seg.cz);
                        offSeg = { type: 'arc', cx: seg.cx, cz: seg.cz, r: rNew, dir: seg.dir, refP1: seg.p1, refP2: seg.p2, startAngle, endAngle };
                    }
                    if (offSeg) offsetPath.push(offSeg);
                }

                // --- Generate Finishing Offset Path ---
                if (params.doFinishing) {
                    for (let i = 0; i < contourSegments.length; i++) {
                        const seg = contourSegments[i];
                        let offSeg = null;
                        if (seg.type === 'line') {
                            const n = getNormal(seg.p1, seg.p2);
                            offSeg = { type: 'line', p1: { x: seg.p1.x + n.x * tipR, z: seg.p1.z + n.z * tipR }, p2: { x: seg.p2.x + n.x * tipR, z: seg.p2.z + n.z * tipR } };
                        } else if (seg.type === 'arc') {
                            let rNew = (seg.dir === 'G3') ? seg.r + tipR : seg.r - tipR;
                            if (rNew < 0) rNew = 0.001;
                            const startAngle = Math.atan2(seg.p1.x - seg.cx, seg.p1.z - seg.cz);
                            const endAngle = Math.atan2(seg.p2.x - seg.cx, seg.p2.z - seg.cz);
                            offSeg = { type: 'arc', cx: seg.cx, cz: seg.cz, r: rNew, dir: seg.dir, refP1: seg.p1, refP2: seg.p2, startAngle, endAngle };
                        }
                        if (offSeg) finishOffsetPath.push(offSeg);
                    }
                }
                
                setErrors(foundErrors);

                // --- ROUGHING LOGIC ---
                const passes = [];
                const step = parseFloat(params.depthOfCut) || 1;
                const sRad = (parseFloat(params.stockDiameter) || 100)/2;
                const stockFace = parseFloat(params.stockFace) || 0;
                
                if (params.roughingStrategy === 'face') {
                    // FACE TURNING
                    let currentZ = stockFace;
                    const minZPart = -1000;
                    let safe = 0;
                    while (currentZ > minZPart && safe < 500) {
                        currentZ -= step;
                        safe++;
                        let xsEnd = [];
                        offsetPath.forEach(os => {
                            if (os.type === 'line') {
                                const x = intersectVerticalLineSegment(currentZ, os.p1, os.p2);
                                if (x !== null) xsEnd.push(x);
                            } else if (os.type === 'arc') {
                                const res = intersectVerticalLineArc(currentZ, {x: os.cx, z: os.cz}, os.r);
                                res.forEach(x => {
                                    const angle = Math.atan2(x - os.cx, currentZ - os.cz);
                                    if (isAngleBetween(angle, os.startAngle, os.endAngle, os.dir === 'G2')) xsEnd.push(x);
                                });
                            }
                        });
                        xsEnd.sort((a, b) => a - b); 
                        let xTarget = 0;
                        if (xsEnd.length > 0) {
                            const validXs = xsEnd.filter(x => x < sRad + 1);
                            if (validXs.length > 0) xTarget = validXs[validXs.length - 1]; 
                        } else {
                            let maxOZ = -9999;
                            offsetPath.forEach(p => { 
                                const z1 = p.type==='line' ? p.p1.z : p.cz + p.r; 
                                const z2 = p.type==='line' ? p.p2.z : p.cz - p.r; 
                                maxOZ = Math.max(maxOZ, z1, z2);
                            });
                            if (currentZ > maxOZ) xTarget = -1; else continue; 
                        }
                        if (xTarget >= sRad - 0.01) continue;
                        passes.push({ type: 'face', z: currentZ, xStart: sRad + 2, xEnd: xTarget });
                        if (currentZ < -200) break; 
                    }
                } else {
                    // LONGITUDINAL TURNING
                    let currentX = sRad;
                    if (params.stockMode === 'casting' && stockWorldPoints.length > 0) {
                       let maxStockX = -9999;
                       stockWorldPoints.forEach(p => { if (p.xReal > maxStockX) maxStockX = p.xReal; });
                       currentX = maxStockX; 
                    }
                    const cylStockZ = (parseFloat(params.stockLength) || 100) * -1;
                    let safe = 0;
                    while (currentX > -50 && safe < 500) {
                        currentX -= step;
                        safe++;
                        let zsEnd = [];
                        offsetPath.forEach(os => {
                            if (os.type === 'line') {
                                const z = intersectHorizontalLineSegment(currentX, os.p1, os.p2);
                                if (z !== null) zsEnd.push(z);
                            } else if (os.type === 'arc') {
                                const res = intersectHorizontalLineArc(currentX, {x: os.cx, z: os.cz}, os.r);
                                res.forEach(z => {
                                    const angle = Math.atan2(currentX - os.cx, z - os.cz);
                                    if (isAngleBetween(angle, os.startAngle, os.endAngle, os.dir === 'G2')) zsEnd.push(z);
                                });
                            }
                        });
                        zsEnd.sort((a, b) => b - a);
                        zsEnd = zsEnd.filter((z, i) => i === 0 || Math.abs(z - zsEnd[i-1]) > 0.01);

                        if (zsEnd.length > 0) {
                            let zTarget = zsEnd[0];
                            let zStartCut = allowanceZ;
                            if (params.stockMode === 'casting') {
                                let zsStart = [];
                                stockPathSegments.forEach(ss => {
                                    if (ss.type === 'line') {
                                        const z = intersectHorizontalLineSegment(currentX, ss.p1, ss.p2);
                                        if (z !== null) zsStart.push(z);
                                    } else if (ss.type === 'arc') {
                                        const res = intersectHorizontalLineArc(currentX, {x: ss.cx, z: ss.cz}, ss.r);
                                        res.forEach(z => {
                                            const angle = Math.atan2(currentX - ss.cx, z - ss.cz);
                                            if (isAngleBetween(angle, ss.startAngle, ss.endAngle, ss.dir === 'G2')) zsStart.push(z);
                                        });
                                    }
                                });
                                zsStart.sort((a, b) => b - a);
                                const validStarts = zsStart.filter(z => z > zTarget + 0.01);
                                if (validStarts.length > 0) zStartCut = validStarts[0];
                                else if (zsStart.length === 0) continue; 
                            } else {
                                if (currentX > sRad) continue; 
                                if (zTarget < cylStockZ) zTarget = cylStockZ;
                                zStartCut = stockFace;
                            }
                            if (zStartCut > zTarget) {
                                passes.push({ type: 'long', x: currentX, zStart: zStartCut, zEnd: zTarget });
                            }
                        }
                        let minPartX = 9999;
                        offsetPath.forEach(os => {
                           if (os.type === 'line') minPartX = Math.min(minPartX, os.p1.x, os.p2.x);
                           else minPartX = Math.min(minPartX, os.cx - os.r); 
                        });
                        if (currentX < minPartX - 1) break; 
                    }
                }

                // --- Simulation Path Generation ---
                const simPath = [];
                simPath.push({x: params.safeX/2, z: params.safeZ, type: 'G0'});
                
                // Roughing simulation
                passes.forEach(pass => {
                    if (pass.type === 'long') {
                        const xRetract = pass.x + retractDist; // VISUAL FIX
                        const xCut = pass.x;
                        simPath.push({x: xRetract, z: pass.zStart + 1, type: 'G0'}); 
                        simPath.push({x: xCut, z: pass.zStart + 1, type: 'G0'});     
                        simPath.push({x: xCut, z: pass.zEnd, type: 'G1'});          
                        simPath.push({x: xRetract, z: pass.zEnd + retractDist, type: 'G1'});   
                        simPath.push({x: xRetract, z: pass.zStart + 1, type: 'G0'});   
                    } else {
                        // FACE
                        const zRetract = pass.z + retractDist; // VISUAL FIX
                        const zCut = pass.z;
                        simPath.push({x: pass.xStart, z: zRetract, type: 'G0'});
                        simPath.push({x: pass.xStart, z: zCut, type: 'G0'});
                        simPath.push({x: pass.xEnd, z: zCut, type: 'G1'}); 
                        simPath.push({x: pass.xEnd, z: zRetract, type: 'G1'}); 
                        simPath.push({x: pass.xStart, z: zRetract, type: 'G0'}); 
                    }
                });
                
                // Final retract
                simPath.push({x: params.safeX/2, z: params.safeZ, type: 'G0'});

                // Finishing simulation
                if (params.doFinishing && finishOffsetPath.length > 0) {
                     const startSeg = finishOffsetPath[0];
                     const startX = startSeg.type === 'line' ? startSeg.p1.x : (startSeg.cx + Math.cos(startSeg.startAngle)*startSeg.r);
                     const startZ = startSeg.type === 'line' ? startSeg.p1.z : (startSeg.cz + Math.sin(startSeg.startAngle)*startSeg.r);
                     
                     simPath.push({x: params.safeX/2, z: params.safeZ, type: 'G0'});
                     simPath.push({x: startX + 2, z: startZ, type: 'G0'}); 
                     simPath.push({x: startX, z: startZ, type: 'G1'}); 

                     finishOffsetPath.forEach(seg => {
                         if (seg.type === 'line') {
                             simPath.push({x: seg.p2.x, z: seg.p2.z, type: 'G1'});
                         } else {
                             const steps = 10;
                             let sA = seg.startAngle;
                             let eA = seg.endAngle;
                             if (seg.dir === 'G2' && eA > sA) eA -= 2*Math.PI;
                             if (seg.dir === 'G3' && eA < sA) eA += 2*Math.PI;
                             for(let j=1; j<=steps; j++) {
                                 const a = sA + (eA - sA) * (j/steps);
                                 simPath.push({x: seg.cx + Math.cos(a)*seg.r, z: seg.cz + Math.sin(a)*seg.r, type: seg.dir});
                             }
                         }
                     });
                     
                     const lastPt = simPath[simPath.length-1];
                     simPath.push({x: lastPt.x + 2, z: lastPt.z + 2, type: 'G0'});
                     simPath.push({x: params.safeX/2, z: params.safeZ, type: 'G0'});
                }

                return { worldPoints, stockWorldPoints, offsetPath, finishOffsetPath, stockPathSegments, passes, simPath, retractDist };
            }, [contourPoints, stockPoints, params]);

            useEffect(() => {
                let animationFrameId;
                let startTime;
                const animate = (time) => {
                    if (!startTime) startTime = time;
                    if (simRunning) {
                        setSimProgress(prev => {
                            const next = prev + 0.003; 
                            if (next >= 1) {
                                setSimRunning(false);
                                return 1;
                            }
                            return next;
                        });
                        animationFrameId = requestAnimationFrame(animate);
                    }
                };
                if (simRunning) animationFrameId = requestAnimationFrame(animate);
                return () => cancelAnimationFrame(animationFrameId);
            }, [simRunning]);

            // --- G-CODE EXPORT ---
            useEffect(() => {
                const d = new Date();
                const head = `; SINUMERIK 840D Generated Code
; Date: ${d.toLocaleDateString()}
G18 G90 G54
G96 S${params.speed} ${params.machineType}
${params.mode}
T="${params.toolName}" D1 M6
M3 M8
G0 X${params.safeX} Z${params.safeZ}`;

                // Use the same retract distance in G-code
                const rDist = calculatedData.retractDist || 2.0;

                const roughing = calculatedData.passes.map((pass, i) => {
                    if (pass.type === 'long') {
                        const xVal = params.mode === 'DIAMON' ? (pass.x * 2).toFixed(3) : pass.x.toFixed(3);
                        // Retract position (X start + retract)
                        const xRetract = params.mode === 'DIAMON' ? ((pass.x + rDist) * 2).toFixed(3) : (pass.x + rDist).toFixed(3);
                        
                        return `; Pass ${i+1} (Long)
G0 X${xRetract} Z${(pass.zStart + 1).toFixed(3)}
G1 X${xVal} F${params.feed}
G1 Z${pass.zEnd.toFixed(3)}
G1 X${xRetract} Z${(pass.zEnd + rDist).toFixed(3)} ; Retract 45deg
G0 Z${(pass.zStart + 1).toFixed(3)} ; Rapid back`;
                    } else {
                        // FACE
                        const zVal = pass.z.toFixed(3);
                        const zRetract = (pass.z + rDist).toFixed(3);
                        const xStart = params.mode === 'DIAMON' ? (pass.xStart * 2).toFixed(3) : pass.xStart.toFixed(3);
                        const xEnd = params.mode === 'DIAMON' ? (pass.xEnd * 2).toFixed(3) : pass.xEnd.toFixed(3);
                        // Retract X end
                        const xEndRetract = params.mode === 'DIAMON' ? ((pass.xEnd + rDist) * 2).toFixed(3) : (pass.xEnd + rDist).toFixed(3);
                        
                        return `; Pass ${i+1} (Face)
G0 X${xStart} Z${zRetract}
G1 Z${zVal} F${params.feed}
G1 X${xEnd}
G1 X${xEndRetract} Z${zRetract} ; Retract 45deg
G0 X${xStart} ; Rapid back`;
                    }
                }).join('\n');

                let finishing = '';
                if (params.doFinishing && calculatedData.finishOffsetPath.length > 0) {
                    const pathLines = [];
                    const startSeg = calculatedData.finishOffsetPath[0];
                    const sX = startSeg.type === 'line' ? startSeg.p1.x : (startSeg.cx + Math.cos(startSeg.startAngle)*startSeg.r);
                    const sZ = startSeg.type === 'line' ? startSeg.p1.z : (startSeg.cz + Math.sin(startSeg.startAngle)*startSeg.r);
                    const sX_out = params.mode === 'DIAMON' ? (sX * 2).toFixed(3) : sX.toFixed(3);
                    pathLines.push(`G0 X${sX_out} Z${sZ.toFixed(3)}`);

                    calculatedData.finishOffsetPath.forEach(seg => {
                        if (seg.type === 'line') {
                             const eX = params.mode === 'DIAMON' ? (seg.p2.x * 2).toFixed(3) : seg.p2.x.toFixed(3);
                             pathLines.push(`G1 X${eX} Z${seg.p2.z.toFixed(3)}`);
                        } else {
                             const eX = params.mode === 'DIAMON' ? ((seg.cx + Math.cos(seg.endAngle)*seg.r) * 2).toFixed(3) : (seg.cx + Math.cos(seg.endAngle)*seg.r).toFixed(3);
                             const eZ = (seg.cz + Math.sin(seg.endAngle)*seg.r).toFixed(3);
                             pathLines.push(`${seg.dir} X${eX} Z${eZ} CR=${seg.r.toFixed(3)}`);
                        }
                    });
                    finishing = `\n; --- DOKONCOVANI ---\n${pathLines.join('\n')}\n`;
                }

                const contourSub = contourPoints.map(p => {
                    let line = `${p.type} X${p.x} Z${p.z}`;
                    if (p.type === 'G2' || p.type === 'G3') line += ` CR=${p.r}`; 
                    return line;
                }).join('\n');
                
                setGeneratedCode(`${head}\n\n; --- HRUBOVANI (${params.roughingStrategy === 'face' ? 'CELNI' : 'PODELNE'}) ---\n${roughing}\n${finishing}\nG0 X${params.safeX} Z${params.safeZ}\nM30\n\n; --- KONTURA ---\n${contourSub}`);
            }, [calculatedData, params, contourPoints]);

            const draw = useCallback(() => {
                const canvas = canvasRef.current;
                const container = containerRef.current;
                if (!canvas || !container) return;
                
                const ctx = canvas.getContext('2d');
                const w = container.clientWidth;
                const h = container.clientHeight;
                
                if (canvas.width !== w || canvas.height !== h) {
                    canvas.width = w;
                    canvas.height = h;
                }

                const colors = theme === 'dark' ? {
                    bg: '#111827', grid: '#374151', axis: '#ef4444', stock: '#9ca3af',
                    contour: '#3b82f6', offset: '#a855f7', pass: '#22c55e', finish: '#f472b6', error: '#ef4444', text: '#9ca3af', tool: '#facc15'
                } : {
                    bg: '#ffffff', grid: '#e5e7eb', axis: '#ef4444', stock: '#6b7280',
                    contour: '#2563eb', offset: '#9333ea', pass: '#16a34a', finish: '#db2777', error: '#ef4444', text: '#6b7280', tool: '#fbbf24'
                };

                ctx.fillStyle = colors.bg; ctx.fillRect(0, 0, w, h);

                const toScreen = (x, z) => ({
                    x: view.panX + z * view.scale,
                    y: view.panY - x * view.scale
                });

                // Grid
                ctx.strokeStyle = colors.grid; ctx.lineWidth = 1; ctx.beginPath();
                for (let i=-500; i<=500; i+=20) {
                     const p1 = toScreen(-500, i); const p2 = toScreen(500, i);
                     ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                     const p3 = toScreen(i, -500); const p4 = toScreen(i, 500);
                     ctx.moveTo(p3.x, p3.y); ctx.lineTo(p4.x, p4.y);
                }
                ctx.stroke();

                // Axis
                const zero = toScreen(0,0);
                ctx.strokeStyle = colors.axis; ctx.lineWidth = 2; ctx.beginPath();
                ctx.moveTo(0, zero.y); ctx.lineTo(w, zero.y);
                ctx.moveTo(zero.x, 0); ctx.lineTo(zero.x, h);
                ctx.stroke();
                ctx.fillStyle = colors.axis; ctx.font = "bold 12px monospace";
                ctx.fillText("Z+", w - 20, zero.y + 15); ctx.fillText("X+", zero.x + 10, 15);

                // Stock Visual
                if (params.stockMode === 'cylinder') {
                    const sRad = (parseFloat(params.stockDiameter) || 0)/2;
                    const sLen = parseFloat(params.stockLength) || 0;
                    const sFace = parseFloat(params.stockFace) || 0;
                    const s1 = toScreen(sRad, sFace); 
                    const s2 = toScreen(sRad, -sLen); 
                    const s3 = toScreen(0, -sLen);
                    const sStart = toScreen(0, sFace);
                    ctx.strokeStyle = colors.stock; ctx.setLineDash([5, 5]); ctx.beginPath();
                    ctx.moveTo(sStart.x, sStart.y); ctx.lineTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.lineTo(s3.x, s3.y);
                    ctx.stroke(); ctx.setLineDash([]);
                } else if (calculatedData.stockPathSegments.length > 0) {
                    ctx.beginPath();
                    calculatedData.stockPathSegments.forEach((seg, i) => {
                        if (seg.type === 'line') {
                            const p1 = toScreen(seg.p1.x, seg.p1.z); const p2 = toScreen(seg.p2.x, seg.p2.z);
                            if (i === 0) ctx.moveTo(p1.x, p1.y); else ctx.lineTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                        } else if (seg.type === 'arc') {
                             const c = toScreen(seg.cx, seg.cz);
                             const sa_scr = -seg.startAngle; 
                             const ea_scr = -seg.endAngle;
                             const startX_scr = c.x + Math.cos(sa_scr) * seg.r * view.scale;
                             const startY_scr = c.y + Math.sin(sa_scr) * seg.r * view.scale;
                             if (i === 0) ctx.moveTo(startX_scr, startY_scr); else ctx.lineTo(startX_scr, startY_scr);
                             const isG2 = (seg.dir === 'G2');
                             ctx.arc(c.x, c.y, seg.r * view.scale, sa_scr, ea_scr, !isG2);
                        }
                    });
                    ctx.strokeStyle = colors.stock; ctx.setLineDash([4, 4]); ctx.lineWidth = 1; ctx.stroke(); ctx.setLineDash([]);
                }

                // Contour
                if (calculatedData.worldPoints.length > 0) {
                    ctx.beginPath();
                    const start = toScreen(calculatedData.worldPoints[0].xReal, calculatedData.worldPoints[0].zReal);
                    ctx.moveTo(start.x, start.y);
                    for (let i = 0; i < calculatedData.worldPoints.length - 1; i++) {
                        const p1 = calculatedData.worldPoints[i];
                        const p2 = calculatedData.worldPoints[i+1];
                        const ptEnd = toScreen(p2.xReal, p2.zReal);
                        if (p2.type === 'G0' || p2.type === 'G1') {
                            ctx.lineTo(ptEnd.x, ptEnd.y);
                        } else if (p2.type === 'G2' || p2.type === 'G3') {
                            const arc = getArcParams({x:p1.xReal, z:p1.zReal}, {x:p2.xReal, z:p2.zReal}, p2.rVal, p2.type);
                            if (!arc.error) {
                                const sc = toScreen(arc.cx, arc.cz);
                                const r = arc.r * view.scale;
                                const ptStart = toScreen(p1.xReal, p1.zReal);
                                const sa = Math.atan2(ptStart.y - sc.y, ptStart.x - sc.x);
                                const ea = Math.atan2(ptEnd.y - sc.y, ptEnd.x - sc.x);
                                const isG2 = (p2.type === 'G2');
                                ctx.arc(sc.x, sc.y, r, sa, ea, !isG2); 
                            } else {
                                ctx.lineTo(ptEnd.x, ptEnd.y);
                            }
                        }
                    }
                    ctx.strokeStyle = colors.contour; ctx.lineWidth = 3; ctx.stroke();
                }

                // Offset
                if (calculatedData.offsetPath.length > 0) {
                    ctx.beginPath();
                    calculatedData.offsetPath.forEach((seg, i) => {
                        if (seg.type === 'line') {
                            const p1 = toScreen(seg.p1.x, seg.p1.z); const p2 = toScreen(seg.p2.x, seg.p2.z);
                            if (i === 0) ctx.moveTo(p1.x, p1.y); else ctx.lineTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                        } else if (seg.type === 'arc') {
                             const c = toScreen(seg.cx, seg.cz);
                             const startX_scr = c.x + Math.cos(Math.atan2(toScreen(seg.refP1.x, seg.refP1.z).y - c.y, toScreen(seg.refP1.x, seg.refP1.z).x - c.x)) * (seg.r * view.scale);
                             const startY_scr = c.y + Math.sin(Math.atan2(toScreen(seg.refP1.x, seg.refP1.z).y - c.y, toScreen(seg.refP1.x, seg.refP1.z).x - c.x)) * (seg.r * view.scale);
                             if (i === 0) ctx.moveTo(startX_scr, startY_scr); else ctx.lineTo(startX_scr, startY_scr); 
                             const sa_scr = Math.atan2(toScreen(seg.refP1.x, seg.refP1.z).y - c.y, toScreen(seg.refP1.x, seg.refP1.z).x - c.x);
                             const ea_scr = Math.atan2(toScreen(seg.refP2.x, seg.refP2.z).y - c.y, toScreen(seg.refP2.x, seg.refP2.z).x - c.x);
                             const isG2 = (seg.dir === 'G2');
                             ctx.arc(c.x, c.y, seg.r * view.scale, sa_scr, ea_scr, !isG2);
                        }
                    });
                    ctx.strokeStyle = colors.offset; ctx.lineWidth = 1; ctx.setLineDash([2,2]); ctx.stroke(); ctx.setLineDash([]);
                }
                
                // Finish Path
                if (params.doFinishing && calculatedData.finishOffsetPath.length > 0) {
                    ctx.beginPath();
                    calculatedData.finishOffsetPath.forEach((seg, i) => {
                        if (seg.type === 'line') {
                            const p1 = toScreen(seg.p1.x, seg.p1.z); const p2 = toScreen(seg.p2.x, seg.p2.z);
                            if (i === 0) ctx.moveTo(p1.x, p1.y); else ctx.lineTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                        } else if (seg.type === 'arc') {
                             const c = toScreen(seg.cx, seg.cz);
                             const startX_scr = c.x + Math.cos(Math.atan2(toScreen(seg.refP1.x, seg.refP1.z).y - c.y, toScreen(seg.refP1.x, seg.refP1.z).x - c.x)) * (seg.r * view.scale);
                             const startY_scr = c.y + Math.sin(Math.atan2(toScreen(seg.refP1.x, seg.refP1.z).y - c.y, toScreen(seg.refP1.x, seg.refP1.z).x - c.x)) * (seg.r * view.scale);
                             if (i === 0) ctx.moveTo(startX_scr, startY_scr); else ctx.lineTo(startX_scr, startY_scr); 
                             const sa_scr = Math.atan2(toScreen(seg.refP1.x, seg.refP1.z).y - c.y, toScreen(seg.refP1.x, seg.refP1.z).x - c.x);
                             const ea_scr = Math.atan2(toScreen(seg.refP2.x, seg.refP2.z).y - c.y, toScreen(seg.refP2.x, seg.refP2.z).x - c.x);
                             const isG2 = (seg.dir === 'G2');
                             ctx.arc(c.x, c.y, seg.r * view.scale, sa_scr, ea_scr, !isG2);
                        }
                    });
                    ctx.strokeStyle = colors.finish; ctx.lineWidth = 2; ctx.stroke();
                }

                // Passes (Roughing)
                ctx.beginPath();
                calculatedData.passes.forEach(pass => {
                    if (pass.type === 'long') {
                        const p1 = toScreen(pass.x, pass.zStart); const p2 = toScreen(pass.x, pass.zEnd);
                        ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                    } else {
                        // FACE
                        const p1 = toScreen(pass.xStart, pass.z); const p2 = toScreen(pass.xEnd, pass.z);
                        ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                    }
                });
                ctx.strokeStyle = colors.pass; ctx.lineWidth = 1.5; ctx.stroke();

                // Draw Rapid Moves (G0) Visualization
                if (calculatedData.simPath.length > 0) {
                    ctx.beginPath();
                    for (let i = 0; i < calculatedData.simPath.length - 1; i++) {
                        const p1 = calculatedData.simPath[i];
                        const p2 = calculatedData.simPath[i+1];
                        if (p2.type === 'G0') {
                            const s = toScreen(p1.x, p1.z);
                            const e = toScreen(p2.x, p2.z);
                            if (Math.abs(s.x - e.x) > 0.1 || Math.abs(s.y - e.y) > 0.1) {
                                ctx.moveTo(s.x, s.y);
                                ctx.lineTo(e.x, e.y);
                            }
                        }
                    }
                    ctx.strokeStyle = theme === 'dark' ? '#ef4444' : '#ef4444'; // Red for rapid
                    ctx.lineWidth = 1.5; 
                    ctx.setLineDash([6, 6]); // More visible Dash
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Tool (Simulation)
                if ((simRunning || simProgress > 0) && calculatedData.simPath.length > 0) {
                    const totalPoints = calculatedData.simPath.length;
                    const floatIndex = simProgress * (totalPoints - 1);
                    const idx = Math.floor(floatIndex);
                    const t = floatIndex - idx;
                    const pCurrent = calculatedData.simPath[idx];
                    const pNext = calculatedData.simPath[Math.min(idx + 1, totalPoints - 1)];
                    const curX = pCurrent.x + (pNext.x - pCurrent.x) * t;
                    const curZ = pCurrent.z + (pNext.z - pCurrent.z) * t;
                    const pt = toScreen(curX, curZ);
                    
                    ctx.fillStyle = colors.tool;
                    ctx.beginPath();
                    ctx.moveTo(pt.x, pt.y);
                    ctx.lineTo(pt.x + 8, pt.y + 12);
                    ctx.lineTo(pt.x - 8, pt.y + 12);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                if (!simRunning) {
                    const activePoints = editMode === 'contour' ? calculatedData.worldPoints : calculatedData.stockWorldPoints;
                    ctx.font = "bold 11px sans-serif";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    
                    activePoints.forEach((p, i) => {
                        const pt = toScreen(p.xReal, p.zReal);
                        ctx.fillStyle = editMode === 'contour' ? colors.contour : colors.pass;
                        ctx.beginPath();
                        ctx.arc(pt.x, pt.y, 3, 0, Math.PI*2);
                        ctx.fill();
                        
                        const label = `${i+1}`;
                        const tx = pt.x + 8;
                        const ty = pt.y - 8;
                        ctx.fillStyle = theme === 'dark' ? '#fbbf24' : '#d97706';
                        ctx.fillText(label, tx, ty);
                    });
                }

            }, [calculatedData, view, theme, params, editMode, mobileTab, simRunning, simProgress]);

            useEffect(() => {
                if (!containerRef.current || !canvasRef.current) return;
                const resizeObserver = new ResizeObserver(() => {
                    draw();
                });
                resizeObserver.observe(containerRef.current);
                return () => resizeObserver.disconnect();
            }, [draw]);

            // Handlers
            const handleWheel = (e) => {
                const s = Math.max(0.5, Math.min(view.scale * (1 - Math.sign(e.deltaY)*0.1), 50));
                setView(v => ({...v, scale: s}));
            };
            const handleMouseDown = (e) => { setIsDragging(true); lastMousePos.current = { x: e.clientX, y: e.clientY }; };
            const handleMouseMove = (e) => {
                if (!isDragging) return;
                const dx = e.clientX - lastMousePos.current.x;
                const dy = e.clientY - lastMousePos.current.y;
                setView(v => ({ ...v, panX: v.panX + dx, panY: v.panY + dy }));
                lastMousePos.current = { x: e.clientX, y: e.clientY };
            };
            const handleMouseUp = () => setIsDragging(false);
            const handleTouchStart = (e) => {
                if (e.touches.length === 1) {
                    setIsDragging(true);
                    lastMousePos.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
            };
            const handleTouchMove = (e) => {
                if (!isDragging || e.touches.length !== 1) return;
                const dx = e.touches[0].clientX - lastMousePos.current.x;
                const dy = e.touches[0].clientY - lastMousePos.current.y;
                setView(v => ({ ...v, panX: v.panX + dx, panY: v.panY + dy }));
                lastMousePos.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            };
            const handleTouchEnd = () => setIsDragging(false);

            const processGCodeString = (text) => {
                const lines = text.split('\n');
                const newPoints = [];
                let currentType = 'G1';
                let idCounter = Date.now();
                let lastX = 100;
                let lastZ = 0;
                lines.forEach(line => {
                    const clean = line.toUpperCase().trim();
                    if (!clean || clean.startsWith(';')) return;
                    const gMatch = clean.match(/G([0-3])/);
                    if (gMatch) currentType = 'G' + gMatch[1];
                    const xMatch = clean.match(/X([-]?\d+\.?\d*)/);
                    const zMatch = clean.match(/Z([-]?\d+\.?\d*)/);
                    const rMatch = clean.match(/(?:R|CR=)([-]?\d+\.?\d*)/);
                    if (xMatch || zMatch) {
                        const newX = xMatch ? parseFloat(xMatch[1]) : lastX;
                        const newZ = zMatch ? parseFloat(zMatch[1]) : lastZ;
                        newPoints.push({ id: idCounter++, type: currentType, x: newX, z: newZ, r: rMatch ? parseFloat(rMatch[1]) : 0, mode: 'ABS' });
                        lastX = newX; lastZ = newZ;
                    }
                });
                if (newPoints.length > 0) {
                    if (editMode === 'contour') setContourPoints(newPoints);
                    else setStockPoints(newPoints); 
                    setErrors([]);
                    fitView(); 
                } else alert("Nepodařilo se rozpoznat žádné body v G-kódu.");
            };
            const parseGCode = () => processGCodeString(gCodeInput);
            const handleCopyGCode = () => {
                const textArea = document.createElement("textarea");
                textArea.value = generatedCode;
                textArea.style.position = "fixed";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    if(document.execCommand('copy')) {
                        setCopyFeedback(true);
                        setTimeout(() => setCopyFeedback(false), 2000);
                    } else alert("Kopírování selhalo.");
                } catch (err) {}
                document.body.removeChild(textArea);
            };
            const handleDownload = () => {
                const element = document.createElement("a");
                const file = new Blob([generatedCode], {type: 'text/plain'});
                element.href = URL.createObjectURL(file);
                element.download = "program.mpf";
                document.body.appendChild(element); 
                element.click();
                document.body.removeChild(element);
            };
            const toggleMode = (id) => {
                const list = editMode === 'contour' ? contourPoints : stockPoints;
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                const absList = resolvePointsToAbsolute(list);
                const prevAbsPoint = absList.find((p, i) => list[i].id === id && i > 0) ? absList[absList.findIndex(p => p.id === id) - 1] : { xAbs: 0, zAbs: 0 };
                const currentAbsPoint = absList.find(p => p.id === id);
                if (!currentAbsPoint) return;
                setList(prev => prev.map(p => {
                    if (p.id !== id) return p;
                    const newMode = p.mode === 'ABS' ? 'INC' : 'ABS';
                    let newX = p.x; let newZ = p.z;
                    if (newMode === 'INC') { newX = currentAbsPoint.xAbs - prevAbsPoint.xAbs; newZ = currentAbsPoint.zAbs - prevAbsPoint.zAbs; } 
                    else { newX = currentAbsPoint.xAbs; newZ = currentAbsPoint.zAbs; }
                    return { ...p, mode: newMode, x: parseFloat(newX.toFixed(3)), z: parseFloat(newZ.toFixed(3)) };
                }));
            };
            const updatePoint = (id, f, v) => {
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                setList(prev => prev.map(p => p.id===id ? {...p, [f]: v} : p));
            };
            const addPoint = () => { 
                const list = editMode === 'contour' ? contourPoints : stockPoints;
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                const last = list.length > 0 ? list[list.length - 1] : { x: 100, z: 0 };
                setList([...list, {id: Date.now(), type:'G1', x:last.x, z: parseFloat(last.z)-10, r:0, mode: 'ABS'}]); 
            };
            const insertPoint = (index) => {
                const list = editMode === 'contour' ? contourPoints : stockPoints;
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                const prev = list[index];
                const newPoint = { ...prev, id: Date.now(), z: parseFloat(prev.z) - 5 };
                const newList = [...list];
                newList.splice(index + 1, 0, newPoint);
                setList(newList);
            };
            const removePoint = (id) => {
                const list = editMode === 'contour' ? contourPoints : stockPoints;
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                if (list.length > 1) setList(list.filter(p=>p.id!==id));
            };
            const currentPoints = editMode === 'contour' ? contourPoints : stockPoints;

            return (
                <div className="flex flex-col md:flex-row h-full">
                    <div className={`${mobileTab === 'editor' ? 'flex' : 'hidden'} md:flex w-full md:w-96 flex-col border-r shadow-xl z-10 ${theme === 'dark' ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'}`}>
                        <div className={`p-4 border-b flex justify-between items-center ${theme === 'dark' ? 'bg-gray-900 border-gray-700' : 'bg-gray-100 border-gray-200'}`}>
                            <h1 className="font-bold text-lg text-blue-500">Sinumerik CAM</h1>
                            <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')} className="p-2 rounded hover:bg-gray-700 hover:text-white transition-colors">
                                {theme === 'light' ? <IconMoon /> : <IconSun />}
                            </button>
                        </div>
                        {errors.length > 0 && (
                            <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-2 text-xs">
                                <p className="font-bold">Chyby:</p>
                                <ul className="list-disc pl-4">{errors.map((e, i) => <li key={i}>{e}</li>)}</ul>
                            </div>
                        )}
                        <div className="flex border-b border-gray-200 dark:border-gray-700">
                             {['editor', 'params', 'import'].map(tab => (
                                <button key={tab} onClick={() => setActiveTab(tab)} 
                                    className={`flex-1 p-3 text-sm font-medium capitalize ${activeTab===tab ? 'bg-blue-100 text-blue-700' : 'text-gray-500'}`}>
                                    {tab}
                                </button>
                            ))}
                        </div>
                         <div className="flex-1 overflow-y-auto p-4 custom-scrollbar pb-20 md:pb-4">
                            {activeTab === 'editor' && (
                                <div className="space-y-3">
                                    <div className="flex gap-2 mb-2 bg-gray-200 p-1 rounded dark:bg-gray-700">
                                        <button onClick={() => setEditMode('contour')} className={`flex-1 flex items-center justify-center gap-2 text-xs py-1.5 rounded font-bold transition-all ${editMode==='contour' ? 'bg-white shadow text-blue-600 dark:bg-gray-600 dark:text-blue-300' : 'text-gray-500 hover:text-gray-700'}`}><IconEdit /> Kontura</button>
                                        <button onClick={() => { setEditMode('stock'); if(stockPoints.length === 0) generateDefaultStock(); }} className={`flex-1 flex items-center justify-center gap-2 text-xs py-1.5 rounded font-bold transition-all ${editMode==='stock' ? 'bg-white shadow text-green-600 dark:bg-gray-600 dark:text-green-300' : 'text-gray-500 hover:text-gray-700'}`}><IconBox /> Polotovar</button>
                                    </div>
                                    <div className="flex gap-1 px-2 text-xs font-bold text-gray-500 mb-1">
                                        <div className="w-6 text-center">#</div>
                                        <div className="w-14">Typ</div>
                                        <div className="w-8 text-center">Mód</div>
                                        <div className="w-16 text-center">X/U</div>
                                        <div className="w-16 text-center">Z/W</div>
                                        <div className="w-10 text-center">R</div>
                                    </div>
                                    {currentPoints.map((p, index) => (
                                        <div key={p.id} className={`border rounded p-2 flex flex-wrap gap-1 items-center ${theme === 'dark' ? 'bg-gray-750 border-gray-600' : 'bg-gray-50 border-gray-300'} ${editMode==='stock' ? 'border-l-4 border-l-green-500' : 'border-l-4 border-l-blue-500'}`}>
                                            <div className="w-6 font-mono text-xs text-gray-500 font-bold">{index+1}</div>
                                            <select value={p.type} onChange={(e) => updatePoint(p.id, 'type', e.target.value)} className={`border rounded text-xs px-1 py-1 w-14 ${theme==='dark'?'bg-gray-900 border-gray-600':'bg-white border-gray-300'}`}><option>G0</option><option>G1</option><option>G2</option><option>G3</option></select>
                                            
                                            <button 
                                                onClick={() => toggleMode(p.id)}
                                                className={`w-8 h-6 flex items-center justify-center rounded text-xs font-bold ${p.mode==='INC' ? 'bg-purple-100 text-purple-700 border border-purple-300' : 'bg-gray-100 text-gray-600 border border-gray-300'}`}
                                                title={p.mode === 'INC' ? 'Přírůstkově' : 'Absolutně'}
                                            >
                                                {p.mode === 'INC' ? 'INC' : 'ABS'}
                                            </button>

                                            <input type="number" value={p.x} onChange={(e) => updatePoint(p.id, 'x', e.target.value)} className={`border rounded text-sm w-16 px-1 py-1 ${theme==='dark'?'bg-gray-900 border-gray-600':'bg-white border-gray-300'}`} placeholder={p.mode==='INC' ? 'U' : 'X'} />
                                            <input type="number" value={p.z} onChange={(e) => updatePoint(p.id, 'z', e.target.value)} className={`border rounded text-sm w-16 px-1 py-1 ${theme==='dark'?'bg-gray-900 border-gray-600':'bg-white border-gray-300'}`} placeholder={p.mode==='INC' ? 'W' : 'Z'} />
                                            {(p.type === 'G2' || p.type === 'G3') && <input type="number" value={p.r} onChange={(e) => updatePoint(p.id, 'r', e.target.value)} className={`border rounded text-sm w-10 px-1 py-1 ${theme==='dark'?'bg-gray-900 border-gray-600':'bg-white border-gray-300'}`} placeholder="R" />}
                                            
                                            <div className="flex ml-auto gap-1">
                                                <button onClick={() => insertPoint(index)} className="text-blue-500 hover:text-blue-700 p-1" title="Vložit řádek za"><IconInsert /></button>
                                                <button onClick={() => removePoint(p.id)} className="text-red-400 hover:text-red-600 p-1" title="Smazat řádek"><IconTrash /></button>
                                            </div>
                                        </div>
                                    ))}
                                    <div className="grid grid-cols-2 gap-2">
                                        <button onClick={addPoint} className={`col-span-2 py-2 text-white rounded text-sm font-bold flex justify-center items-center gap-2 ${editMode==='stock'?'bg-green-600 hover:bg-green-500':'bg-blue-600 hover:bg-blue-500'}`}><IconPlus /> Přidat bod</button>
                                        <button onClick={handleCopyGCode} className={`py-2 text-white rounded text-sm font-bold flex justify-center items-center gap-2 transition-all ${copyFeedback ? 'bg-green-600' : 'bg-gray-600 hover:bg-gray-500'}`}><IconClipboard /> {copyFeedback ? "Zkopírováno" : "Kopírovat"}</button>
                                        <button onClick={handleDownload} className="py-2 text-white rounded text-sm font-bold flex justify-center items-center gap-2 bg-purple-600 hover:bg-purple-500"><IconDownload /> Uložit MPF</button>
                                    </div>
                                </div>
                            )}
                             {activeTab === 'params' && (
                                <div className="space-y-4">
                                    <h3 className={`font-bold border-b pb-1 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Polotovar</h3>
                                    <div className="flex gap-2 mb-2">
                                        <button onClick={() => setParams({...params, stockMode: 'cylinder'})} className={`flex-1 py-1 text-xs border rounded ${params.stockMode==='cylinder' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Válec</button>
                                        <button onClick={() => setParams({...params, stockMode: 'casting'})} className={`flex-1 py-1 text-xs border rounded ${params.stockMode==='casting' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Odlitek (Fanuc)</button>
                                    </div>
                                    {params.stockMode === 'cylinder' ? (
                                        <div className="space-y-2">
                                            <div className="flex items-end gap-2">
                                                <div className="flex-1"><label className="text-xs text-gray-500">Průměr (D)</label><input type="number" value={params.stockDiameter} onChange={e=>setParams({...params, stockDiameter:e.target.value})} className="border rounded p-1 w-full"/></div>
                                                <div className="flex-1"><label className="text-xs text-gray-500">Délka (Z-)</label><input type="number" value={params.stockLength} onChange={e=>setParams({...params, stockLength:e.target.value})} className="border rounded p-1 w-full"/></div>
                                            </div>
                                            <div className="flex items-end gap-2">
                                                <div className="flex-1"><label className="text-xs text-gray-500">Přídavek čelo (Z+)</label><input type="number" value={params.stockFace} onChange={e=>setParams({...params, stockFace:e.target.value})} className="border rounded p-1 w-full"/></div>
                                                <div className="flex-1"><label className="text-xs text-gray-500">Přídavek (pro Auto)</label><input type="number" value={params.stockMargin} onChange={e=>setParams({...params, stockMargin:e.target.value})} className="border rounded p-1 w-full"/></div>
                                            </div>
                                            <button onClick={handleAutoStock} className="w-full py-1.5 bg-indigo-600 text-white rounded text-xs font-bold flex items-center justify-center gap-1 hover:bg-indigo-500"><IconMagic /> Auto-rozměr</button>
                                        </div>
                                    ) : (
                                        <div className="text-xs text-gray-500 italic p-2 bg-gray-100 rounded dark:bg-gray-800">
                                            Pro definici tvarového polotovaru (odlitku) použijte přepínač "Polotovar" v záložce <b>Editor</b> a nakreslete jeho tvar.
                                        </div>
                                    )}

                                    <h3 className={`font-bold border-b pb-1 mt-4 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Hrubování</h3>
                                    {/* NEW: STRATEGY SELECTOR */}
                                    <div className="flex gap-2 mb-2">
                                        <button onClick={() => setParams({...params, roughingStrategy: 'longitudinal'})} className={`flex-1 py-1 text-xs border rounded flex items-center justify-center gap-1 ${params.roughingStrategy==='longitudinal' ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-700'}`}>
                                            <IconArrowRight /> Podélně (Z)
                                        </button>
                                        <button onClick={() => setParams({...params, roughingStrategy: 'face'})} className={`flex-1 py-1 text-xs border rounded flex items-center justify-center gap-1 ${params.roughingStrategy==='face' ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-700'}`}>
                                            <IconArrowDown /> Čelně (X)
                                        </button>
                                    </div>

                                    <div className="grid grid-cols-2 gap-2">
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Hloubka (ap)</label><input type="number" step="0.5" value={params.depthOfCut} onChange={e=>setParams({...params, depthOfCut:e.target.value})} className="border rounded p-1"/></div>
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Posuv (F)</label><input type="number" step="0.05" value={params.feed} onChange={e=>setParams({...params, feed:e.target.value})} className="border rounded p-1"/></div>
                                    </div>
                                    
                                    <h3 className={`font-bold border-b pb-1 mt-4 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Nástroj</h3>
                                    <div className="grid grid-cols-2 gap-2">
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Rádius (R)</label><input type="number" step="0.1" value={params.toolRadius} onChange={e=>setParams({...params, toolRadius:e.target.value})} className="border rounded p-1"/></div>
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Přídavek X</label><input type="number" step="0.1" value={params.allowanceX} onChange={e=>setParams({...params, allowanceX:e.target.value})} className="border rounded p-1"/></div>
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Přídavek Z</label><input type="number" step="0.1" value={params.allowanceZ} onChange={e=>setParams({...params, allowanceZ:e.target.value})} className="border rounded p-1"/></div>
                                    </div>
                                    
                                    <div className="mt-4 pt-2 border-t dark:border-gray-700">
                                        <label className="flex items-center space-x-2 cursor-pointer">
                                            <input type="checkbox" checked={params.doFinishing} onChange={e => setParams({...params, doFinishing: e.target.checked})} className="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600" />
                                            <span className="text-sm font-bold text-gray-700 dark:text-gray-300">Dokončovací operace (Na čisto)</span>
                                        </label>
                                        <p className="text-xs text-gray-500 mt-1 pl-6">Vygeneruje dráhu nástroje přesně po kontuře (pouze s korekcí R, bez přídavku).</p>
                                    </div>
                                </div>
                            )}
                             {activeTab === 'import' && (
                                <div className="flex flex-col h-full">
                                    <textarea className="flex-1 border p-2 font-mono text-xs mb-2" value={gCodeInput} onChange={e=>setGCodeInput(e.target.value)} placeholder="G1 X... Z..."></textarea>
                                    <button onClick={parseGCode} className="bg-green-600 text-white py-2 rounded">Import</button>
                                </div>
                            )}
                        </div>
                    </div>

                     <div className={`${mobileTab === 'preview' ? 'flex' : 'hidden'} md:flex flex-1 flex-col relative pb-20 md:pb-0 ${theme === 'dark' ? 'bg-gray-900' : 'bg-gray-50'}`}>
                        <div className="absolute top-4 right-4 z-10 flex gap-2">
                            <div className="bg-white p-1 rounded shadow flex gap-1 items-center">
                                <button onClick={() => { setSimProgress(0); setSimRunning(true); }} className={`p-1 rounded hover:bg-green-100 ${simRunning ? 'text-green-600' : 'text-gray-600'}`} title="Spustit simulaci"><IconPlay /></button>
                                <button onClick={() => { setSimRunning(false); setSimProgress(0); }} className="p-1 rounded hover:bg-red-100 text-gray-600" title="Stop"><IconStop /></button>
                            </div>
                            <button onClick={fitView} className="bg-white p-2 rounded shadow text-gray-700 hover:text-blue-600" title="Centrovat pohled"><IconTarget /></button>
                        </div>
                        <div ref={containerRef} className={`flex-1 overflow-hidden relative canvas-container`}
                             onWheel={handleWheel} 
                             onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp}
                             onTouchStart={handleTouchStart} onTouchMove={handleTouchMove} onTouchEnd={handleTouchEnd}>
                            <canvas ref={canvasRef} className="block" />
                        </div>
                        <div className={`h-48 border-t flex flex-col ${theme === 'dark' ? 'bg-gray-950 border-gray-700' : 'bg-white border-gray-300'}`}>
                             <textarea readOnly className={`flex-1 bg-transparent p-4 text-xs font-mono focus:outline-none resize-none ${theme === 'dark' ? 'text-green-300' : 'text-gray-800'}`} value={generatedCode} />
                        </div>
                    </div>

                    <div className="md:hidden fixed bottom-0 left-0 right-0 h-16 bg-white border-t border-gray-200 flex z-50 safe-pb dark:bg-gray-900 dark:border-gray-700">
                        <button onClick={() => setMobileTab('editor')} className={`flex-1 flex flex-col items-center justify-center ${mobileTab==='editor' ? 'text-blue-600' : 'text-gray-500'}`}>
                            <IconEdit />
                            <span className="text-xs font-bold mt-1">Editor</span>
                        </button>
                        <button onClick={() => setMobileTab('preview')} className={`flex-1 flex flex-col items-center justify-center ${mobileTab==='preview' ? 'text-blue-600' : 'text-gray-500'}`}>
                            <IconEye />
                            <span className="text-xs font-bold mt-1">Náhled</span>
                        </button>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
