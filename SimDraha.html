<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Generátor CAM pro Sinumerik 840D (Auto-Fit)</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel Standalone -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { overscroll-behavior: none; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #9ca3af; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        .canvas-container { cursor: crosshair; touch-action: none; background-image: radial-gradient(#ccc 1px, transparent 1px); background-size: 20px 20px; }
        .dark .canvas-container { background-image: radial-gradient(#333 1px, transparent 1px); }
        /* Fix pro Safari iOS, aby spodní lišta nepřekážela */
        .safe-pb { padding-bottom: env(safe-area-inset-bottom); }
    </style>
</head>
<body class="h-screen w-screen overflow-hidden flex flex-col font-sans transition-colors duration-300">

    <div id="root" class="h-full w-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        // --- ICONS ---
        const IconTrash = () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;
        const IconPlus = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>;
        const IconSun = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>;
        const IconMoon = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>;
        const IconEdit = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path></svg>;
        const IconBox = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>;
        const IconMagic = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><path d="m12 2 2.5 5.5L20 9l-4 3.5L17.5 18 12 15l-5.5 3L8 12.5 4 9l5.5-1.5L12 2z"></path></svg>;
        const IconClipboard = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>;
        const IconInsert = () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>;
        const IconTarget = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line></svg>;
        const IconEye = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>;

        // --- MATH HELPERS ---
        const dist = (p1, p2) => Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.z - p1.z, 2));

        const getNormal = (p1, p2) => {
            const dx = p2.x - p1.x;
            const dz = p2.z - p1.z;
            const l = Math.sqrt(dx*dx + dz*dz);
            if (l===0) return {x:0, z:0};
            return { x: -dz/l, z: dx/l };
        };

        const getArcParams = (p1, p2, r, type) => {
            const d2 = Math.pow(p2.x - p1.x, 2) + Math.pow(p2.z - p1.z, 2);
            const d = Math.sqrt(d2);
            let safeR = r;
            let error = false;
            if (d2 === 0) return { error: true, cx: p1.x, cz: p1.z, r: 0 };
            if (Math.abs(r) < d/2) {
                error = true;
                safeR = d/2 + 0.001; 
            }
            const mx = (p1.x + p2.x) / 2;
            const mz = (p1.z + p2.z) / 2;
            const h = Math.sqrt(Math.max(0, safeR*safeR - d2/4));
            const dx = p2.x - p1.x;
            const dz = p2.z - p1.z;
            const ox = -dz / d;
            const oz = dx / d;
            const sign = (type === 'G3') ? -1 : 1; 
            const cx = mx + sign * h * ox;
            const cz = mz + sign * h * oz;
            return { cx, cz, r: safeR, error };
        };

        const isAngleBetween = (target, start, end, isG2) => {
            const t = (target % (2*Math.PI) + 2*Math.PI) % (2*Math.PI);
            const s = (start % (2*Math.PI) + 2*Math.PI) % (2*Math.PI);
            const e = (end % (2*Math.PI) + 2*Math.PI) % (2*Math.PI);
            if (isG2) { 
                if (s >= e) return t <= s && t >= e;
                return t <= s || t >= e; 
            } else { 
                if (e >= s) return t >= s && t <= e;
                return t >= s || t <= e; 
            }
        };

        const intersectHorizontalLineSegment = (xLine, p1, p2) => {
            const minX = Math.min(p1.x, p2.x);
            const maxX = Math.max(p1.x, p2.x);
            if (xLine < minX || xLine > maxX) return null;
            if (Math.abs(p2.x - p1.x) < 1e-6) return null;
            const t = (xLine - p1.x) / (p2.x - p1.x);
            return p1.z + t * (p2.z - p1.z);
        };

        const intersectHorizontalLineArc = (xLine, center, radius) => {
            const term = radius*radius - Math.pow(xLine - center.x, 2);
            if (term < 0) return [];
            const sqrtTerm = Math.sqrt(term);
            return [center.z - sqrtTerm, center.z + sqrtTerm];
        };

        // --- APP ---
        const App = () => {
            const [theme, setTheme] = useState('light');
            const [editMode, setEditMode] = useState('contour'); 
            const [mobileTab, setMobileTab] = useState('editor'); // 'editor' | 'preview'
            const [copyFeedback, setCopyFeedback] = useState(false);

            const [params, setParams] = useState({
                machineType: 'LIMS=2000',
                mode: 'DIAMON',
                toolName: 'ROUGHER_T1',
                speed: 200,
                feed: 0.25,
                depthOfCut: 2.0,
                allowanceX: 0.5,
                allowanceZ: 0.1,
                toolRadius: 0.8,
                stockMode: 'cylinder', 
                stockMargin: 5.0, 
                stockDiameter: 100, 
                stockLength: 100,
                stockFace: 2.0,
                safeX: 150,
                safeZ: 5
            });

            // Points
            const [contourPoints, setContourPoints] = useState([
                { id: 1, type: 'G0', x: 100, z: 0, r: 0, mode: 'ABS' },
                { id: 2, type: 'G1', x: 20, z: 0, r: 0, mode: 'ABS' },
                { id: 3, type: 'G1', x: 20, z: -20, r: 0, mode: 'ABS' },
                { id: 4, type: 'G2', x: 40, z: -30, r: 10, mode: 'ABS' },
                { id: 5, type: 'G1', x: 40, z: -50, r: 0, mode: 'ABS' },
                { id: 6, type: 'G1', x: 60, z: -60, r: 0, mode: 'ABS' }
            ]);

            const [stockPoints, setStockPoints] = useState([
                { id: 101, type: 'G0', x: 105, z: 2, r: 0, mode: 'ABS' },
                { id: 102, type: 'G1', x: 105, z: -100, r: 0, mode: 'ABS' },
                { id: 103, type: 'G1', x: 0, z: -100, r: 0, mode: 'ABS' }
            ]);
            
            const [errors, setErrors] = useState([]);
            const [gCodeInput, setGCodeInput] = useState('');
            const [generatedCode, setGeneratedCode] = useState('');
            const [activeTab, setActiveTab] = useState('editor');
            
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            // Default view shifted to show typical lathe quadrant (Z- left, X+ up)
            const [view, setView] = useState({ scale: 3, panX: 600, panY: 350 });
            const [isDragging, setIsDragging] = useState(false);
            const lastMousePos = useRef({ x: 0, y: 0 });

            useEffect(() => {
                document.body.className = `h-screen w-screen overflow-hidden flex flex-col font-sans transition-colors duration-300 ${theme === 'dark' ? 'bg-gray-900 text-gray-100' : 'bg-gray-50 text-gray-900'}`;
            }, [theme]);

            // Auto-Fit Function
            const fitView = useCallback(() => {
                if (!containerRef.current) return;
                const points = resolvePointsToAbsolute(contourPoints);
                if (points.length === 0) return;

                // Calc bounds
                let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
                points.forEach(p => {
                    const x = params.mode === 'DIAMON' ? p.xAbs / 2 : p.xAbs;
                    const z = p.zAbs;
                    if(x < minX) minX = x; if(x > maxX) maxX = x;
                    if(z < minZ) minZ = z; if(z > maxZ) maxZ = z;
                });

                // Add padding
                const pad = 20;
                const width = maxZ - minZ + pad*2;
                const height = maxX - minX + pad*2;
                if (width <= 0 || height <= 0) return;

                const contW = containerRef.current.clientWidth;
                const contH = containerRef.current.clientHeight;
                // Avoid divide by zero if container is hidden
                if (contW === 0 || contH === 0) return;

                // Scale to fit
                const scaleX = contW / width;
                const scaleY = contH / height;
                let newScale = Math.min(scaleX, scaleY) * 0.8; // 80% fill
                if (newScale > 10) newScale = 10;
                if (newScale < 0.1) newScale = 0.1;

                // Center
                const midZ = (minZ + maxZ) / 2;
                const midX = (minX + maxX) / 2;
                
                setView({
                    scale: newScale,
                    panX: contW/2 - midZ * newScale,
                    panY: contH/2 + midX * newScale
                });

            }, [contourPoints, params.mode]);

            // Run fit on mount and tab change
            useEffect(() => {
                setTimeout(fitView, 100);
            }, [mobileTab]); // Trigger when switching mobile tabs too

            const handleAutoStock = () => {
                const points = resolvePointsToAbsolute(contourPoints);
                let maxD = 0;
                let minZ = 0;
                let maxZ = -9999;
                
                points.forEach(p => {
                    const xVal = p.xAbs; 
                    const zVal = p.zAbs;
                    let d = xVal;
                    if (params.mode !== 'DIAMON') d = xVal * 2;
                    
                    if (d > maxD) maxD = d;
                    if (zVal < minZ) minZ = zVal;
                    if (zVal > maxZ) maxZ = zVal;
                });

                if (maxZ === -9999) maxZ = 0;
                const margin = parseFloat(params.stockMargin) || 0;
                
                setParams(prev => ({
                    ...prev,
                    stockDiameter: Math.ceil(maxD + margin * 2),
                    stockLength: Math.ceil(Math.abs(minZ) + margin),
                    stockFace: Math.ceil(maxZ + margin)
                }));
            };

            const generateDefaultStock = () => {
                const points = resolvePointsToAbsolute(contourPoints);
                let maxX = 0; let minZ = 0;
                points.forEach(p => {
                    if(p.xAbs > maxX) maxX = p.xAbs;
                    if(p.zAbs < minZ) minZ = p.zAbs;
                });
                const stockX = maxX + 5;
                const stockZ = minZ - 5;
                setStockPoints([
                    { id: Date.now(), type: 'G0', x: stockX, z: 2, r: 0, mode: 'ABS' },
                    { id: Date.now()+1, type: 'G1', x: stockX, z: stockZ, r: 0, mode: 'ABS' },
                    { id: Date.now()+2, type: 'G1', x: 0, z: stockZ, r: 0, mode: 'ABS' }
                ]);
            };

            const resolvePointsToAbsolute = (pts) => {
                let lastX = 0; 
                let lastZ = 0;
                return pts.map((p, index) => {
                    const valX = parseFloat(p.x) || 0;
                    const valZ = parseFloat(p.z) || 0;
                    let absX = valX;
                    let absZ = valZ;

                    if (p.mode === 'INC') {
                        absX = lastX + valX;
                        absZ = lastZ + valZ;
                    } else {
                        absX = valX;
                        absZ = valZ;
                    }
                    
                    lastX = absX;
                    lastZ = absZ;

                    return { ...p, xAbs: absX, zAbs: absZ, rVal: parseFloat(p.r) || 0 };
                });
            };

            const calculatedData = useMemo(() => {
                const absContour = resolvePointsToAbsolute(contourPoints);
                const absStock = resolvePointsToAbsolute(stockPoints);

                const worldPoints = absContour.map(p => ({
                    ...p,
                    xReal: params.mode === 'DIAMON' ? p.xAbs / 2 : p.xAbs, 
                    zReal: p.zAbs
                }));

                const stockWorldPoints = absStock.map(p => ({
                    ...p,
                    xReal: params.mode === 'DIAMON' ? p.xAbs / 2 : p.xAbs, 
                    zReal: p.zAbs
                }));

                const tipR = parseFloat(params.toolRadius) || 0;
                const allowanceX = parseFloat(params.allowanceX) || 0;
                const allowanceZ = parseFloat(params.allowanceZ) || 0;
                const totalOffset = tipR + Math.max(allowanceX, allowanceZ);
                const stockMargin = parseFloat(params.stockMargin) || 0;
                
                let contourSegments = [];
                let offsetPath = [];
                let stockPathSegments = []; 
                const foundErrors = [];

                // --- Process Contour Segments ---
                for (let i = 0; i < worldPoints.length - 1; i++) {
                    const p1 = worldPoints[i];
                    const p2 = worldPoints[i+1];
                    const type = p2.type;
                    if (type === 'G0' || type === 'G1') {
                        contourSegments.push({ type: 'line', p1: {x:p1.xReal, z:p1.zReal}, p2: {x:p2.xReal, z:p2.zReal}, orig: p2 });
                    } else if (type === 'G2' || type === 'G3') {
                        const arc = getArcParams({x:p1.xReal, z:p1.zReal}, {x:p2.xReal, z:p2.zReal}, p2.rVal, type);
                        if (arc.error) foundErrors.push(`Kontura #${p2.id}: Rádius R${p2.r} je příliš malý.`);
                        contourSegments.push({ type: 'arc', ...arc, p1: {x:p1.xReal, z:p1.zReal}, p2: {x:p2.xReal, z:p2.zReal}, dir: type });
                    }
                }

                // --- Process Stock Segments ---
                for (let i = 0; i < stockWorldPoints.length - 1; i++) {
                    const p1 = stockWorldPoints[i];
                    const p2 = stockWorldPoints[i+1];
                    const type = p2.type;
                    if (type === 'G0' || type === 'G1') {
                        stockPathSegments.push({ type: 'line', p1: {x:p1.xReal, z:p1.zReal}, p2: {x:p2.xReal, z:p2.zReal} });
                    } else if (type === 'G2' || type === 'G3') {
                        const arc = getArcParams({x:p1.xReal, z:p1.zReal}, {x:p2.xReal, z:p2.zReal}, p2.rVal, type);
                        const startAngle = Math.atan2(p1.xReal - arc.cx, p1.zReal - arc.cz);
                        const endAngle = Math.atan2(p2.xReal - arc.cx, p2.zReal - arc.cz);
                        stockPathSegments.push({ type: 'arc', ...arc, dir: type, startAngle, endAngle });
                    }
                }

                // --- Generate Tool Offset Path ---
                for (let i = 0; i < contourSegments.length; i++) {
                    const seg = contourSegments[i];
                    let offSeg = null;
                    if (seg.type === 'line') {
                        const n = getNormal(seg.p1, seg.p2);
                        offSeg = { type: 'line', p1: { x: seg.p1.x + n.x * totalOffset, z: seg.p1.z + n.z * totalOffset }, p2: { x: seg.p2.x + n.x * totalOffset, z: seg.p2.z + n.z * totalOffset } };
                    } else if (seg.type === 'arc') {
                        let rNew = (seg.dir === 'G3') ? seg.r + totalOffset : seg.r - totalOffset;
                        if (rNew < 0) { rNew = 0.001; foundErrors.push(`Kontura #${i+2}: Rádius nástroje je větší než rádius koutu (G2).`); }
                        const startAngle = Math.atan2(seg.p1.x - seg.cx, seg.p1.z - seg.cz);
                        const endAngle = Math.atan2(seg.p2.x - seg.cx, seg.p2.z - seg.cz);
                        offSeg = { type: 'arc', cx: seg.cx, cz: seg.cz, r: rNew, dir: seg.dir, refP1: seg.p1, refP2: seg.p2, startAngle, endAngle };
                    }
                    if (offSeg) offsetPath.push(offSeg);
                }
                
                setErrors(foundErrors);

                // 3. Roughing
                const passes = [];
                const limitZ = -1000; 
                let startX = 50; 
                if (params.stockMode === 'casting' && stockWorldPoints.length > 0) {
                    let maxStockX = -9999;
                    stockWorldPoints.forEach(p => { if (p.xReal > maxStockX) maxStockX = p.xReal; });
                    stockPathSegments.forEach(s => { if(s.type === 'arc') maxStockX = Math.max(maxStockX, s.cx + s.r); });
                    startX = maxStockX + 1;
                } else if (params.stockMode === 'cylinder') {
                    startX = (parseFloat(params.stockDiameter) || 100) / 2;
                }

                let currentX = startX;
                const step = parseFloat(params.depthOfCut) || 1;
                const cylStockZ = (parseFloat(params.stockLength) || 100) * -1;
                const stockFace = parseFloat(params.stockFace) || 0;
                let safe = 0;

                while (currentX > -50 && safe < 500) {
                    currentX -= step;
                    safe++;
                    
                    let zsEnd = [];
                    offsetPath.forEach(os => {
                        if (os.type === 'line') {
                            const z = intersectHorizontalLineSegment(currentX, os.p1, os.p2);
                            if (z !== null) zsEnd.push(z);
                        } else if (os.type === 'arc') {
                            const res = intersectHorizontalLineArc(currentX, {x: os.cx, z: os.cz}, os.r);
                            res.forEach(z => {
                                const angle = Math.atan2(currentX - os.cx, z - os.cz);
                                if (isAngleBetween(angle, os.startAngle, os.endAngle, os.dir === 'G2')) zsEnd.push(z);
                            });
                        }
                    });
                    zsEnd.sort((a, b) => b - a);
                    zsEnd = zsEnd.filter((z, i) => i === 0 || Math.abs(z - zsEnd[i-1]) > 0.01);

                    if (zsEnd.length > 0) {
                        let zTarget = zsEnd[0];
                        let zStartCut = allowanceZ; 

                        if (params.stockMode === 'casting') {
                            let zsStart = [];
                            stockPathSegments.forEach(ss => {
                                if (ss.type === 'line') {
                                    const z = intersectHorizontalLineSegment(currentX, ss.p1, ss.p2);
                                    if (z !== null) zsStart.push(z);
                                } else if (ss.type === 'arc') {
                                    const res = intersectHorizontalLineArc(currentX, {x: ss.cx, z: ss.cz}, ss.r);
                                    res.forEach(z => {
                                        const angle = Math.atan2(currentX - ss.cx, z - ss.cz);
                                        if (isAngleBetween(angle, ss.startAngle, ss.endAngle, ss.dir === 'G2')) zsStart.push(z);
                                    });
                                }
                            });
                            zsStart.sort((a, b) => b - a);
                            const validStarts = zsStart.filter(z => z > zTarget + 0.01);
                            if (validStarts.length > 0) zStartCut = validStarts[0];
                            else if (zsStart.length === 0) continue; 
                        } else {
                            const sRad = (parseFloat(params.stockDiameter) || 0)/2;
                            if (currentX > sRad) continue; 
                            if (zTarget < cylStockZ) zTarget = cylStockZ;
                            zStartCut = stockFace;
                        }

                        if (zStartCut > zTarget) {
                             passes.push({ x: currentX, zStart: zStartCut, zEnd: zTarget });
                        }
                    }
                    
                    let minPartX = 9999;
                    offsetPath.forEach(os => {
                       if (os.type === 'line') minPartX = Math.min(minPartX, os.p1.x, os.p2.x);
                       else minPartX = Math.min(minPartX, os.cx - os.r); 
                    });
                    if (currentX < minPartX - 1) break; 
                }

                return { worldPoints, stockWorldPoints, offsetPath, stockPathSegments, passes };
            }, [contourPoints, stockPoints, params]);

            // --- G-CODE EXPORT FIX ---
            useEffect(() => {
                const d = new Date();
                const head = `; SINUMERIK 840D Generated Code
; Date: ${d.toLocaleDateString()}
G18 G90 G54
G96 S${params.speed} ${params.machineType}
${params.mode}
T="${params.toolName}" D1 M6
M3 M8
G0 X${params.safeX} Z${params.safeZ}`;

                const roughing = calculatedData.passes.map((pass, i) => {
                    const xVal = params.mode === 'DIAMON' ? (pass.x * 2).toFixed(3) : pass.x.toFixed(3);
                    const xRetract = params.mode === 'DIAMON' ? (pass.x * 2 + 2).toFixed(3) : (pass.x + 1).toFixed(3);
                    return `; Pass ${i+1}
G0 X${xRetract} Z${(pass.zStart + 1).toFixed(3)}
G1 X${xVal} F${params.feed}
G1 Z${pass.zEnd.toFixed(3)}
G1 X${xRetract}
G0 Z${params.safeZ}`;
                }).join('\n');

                const contourSub = contourPoints.map(p => {
                    let line = `${p.type} X${p.x} Z${p.z}`;
                    if (p.type === 'G2' || p.type === 'G3') line += ` CR=${p.r}`; 
                    return line;
                }).join('\n');
                
                setGeneratedCode(`${head}\n\n; --- HRUBOVANI ---\n${roughing}\n\nG0 X${params.safeX} Z${params.safeZ}\nM30\n\n; --- KONTURA ---\n${contourSub}`);
            }, [calculatedData, params, contourPoints]);

            const draw = useCallback(() => {
                const canvas = canvasRef.current;
                const container = containerRef.current;
                if (!canvas || !container) return;
                
                const ctx = canvas.getContext('2d');
                const w = container.clientWidth;
                const h = container.clientHeight;
                
                // Ensure canvas size matches container
                if (canvas.width !== w || canvas.height !== h) {
                    canvas.width = w;
                    canvas.height = h;
                }

                const colors = theme === 'dark' ? {
                    bg: '#111827', grid: '#374151', axis: '#ef4444', stock: '#9ca3af',
                    contour: '#3b82f6', offset: '#a855f7', pass: '#22c55e', error: '#ef4444', text: '#9ca3af'
                } : {
                    bg: '#ffffff', grid: '#e5e7eb', axis: '#ef4444', stock: '#6b7280',
                    contour: '#2563eb', offset: '#9333ea', pass: '#16a34a', error: '#ef4444', text: '#6b7280'
                };

                ctx.fillStyle = colors.bg; ctx.fillRect(0, 0, w, h);

                const toScreen = (x, z) => ({
                    x: view.panX + z * view.scale,
                    y: view.panY - x * view.scale
                });

                // Grid
                ctx.strokeStyle = colors.grid; ctx.lineWidth = 1; ctx.beginPath();
                for (let i=-500; i<=500; i+=20) {
                     const p1 = toScreen(-500, i); const p2 = toScreen(500, i);
                     ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                     const p3 = toScreen(i, -500); const p4 = toScreen(i, 500);
                     ctx.moveTo(p3.x, p3.y); ctx.lineTo(p4.x, p4.y);
                }
                ctx.stroke();

                // Axis
                const zero = toScreen(0,0);
                ctx.strokeStyle = colors.axis; ctx.lineWidth = 2; ctx.beginPath();
                ctx.moveTo(0, zero.y); ctx.lineTo(w, zero.y);
                ctx.moveTo(zero.x, 0); ctx.lineTo(zero.x, h);
                ctx.stroke();
                ctx.fillStyle = colors.axis; ctx.font = "bold 12px monospace";
                ctx.fillText("Z+", w - 20, zero.y + 15); ctx.fillText("X+", zero.x + 10, 15);

                // Stock Visual
                if (params.stockMode === 'cylinder') {
                    const sRad = (parseFloat(params.stockDiameter) || 0)/2;
                    const sLen = parseFloat(params.stockLength) || 0;
                    const sFace = parseFloat(params.stockFace) || 0;
                    const s1 = toScreen(sRad, sFace); 
                    const s2 = toScreen(sRad, -sLen); 
                    const s3 = toScreen(0, -sLen);
                    const sStart = toScreen(0, sFace);
                    ctx.strokeStyle = colors.stock; ctx.setLineDash([5, 5]); ctx.beginPath();
                    ctx.moveTo(sStart.x, sStart.y); ctx.lineTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.lineTo(s3.x, s3.y);
                    ctx.stroke(); ctx.setLineDash([]);
                } else if (calculatedData.stockPathSegments.length > 0) {
                    ctx.beginPath();
                    calculatedData.stockPathSegments.forEach((seg, i) => {
                        if (seg.type === 'line') {
                            const p1 = toScreen(seg.p1.x, seg.p1.z); const p2 = toScreen(seg.p2.x, seg.p2.z);
                            if (i === 0) ctx.moveTo(p1.x, p1.y); else ctx.lineTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                        } else if (seg.type === 'arc') {
                             const c = toScreen(seg.cx, seg.cz);
                             const sa_scr = -seg.startAngle; 
                             const ea_scr = -seg.endAngle;
                             const startX_scr = c.x + Math.cos(sa_scr) * seg.r * view.scale;
                             const startY_scr = c.y + Math.sin(sa_scr) * seg.r * view.scale;
                             if (i === 0) ctx.moveTo(startX_scr, startY_scr); else ctx.lineTo(startX_scr, startY_scr);
                             const isG2 = (seg.dir === 'G2');
                             ctx.arc(c.x, c.y, seg.r * view.scale, sa_scr, ea_scr, !isG2);
                        }
                    });
                    ctx.strokeStyle = colors.stock; ctx.setLineDash([4, 4]); ctx.lineWidth = 1; ctx.stroke(); ctx.setLineDash([]);
                }

                // Contour
                if (calculatedData.worldPoints.length > 0) {
                    ctx.beginPath();
                    const start = toScreen(calculatedData.worldPoints[0].xReal, calculatedData.worldPoints[0].zReal);
                    ctx.moveTo(start.x, start.y);
                    for (let i = 0; i < calculatedData.worldPoints.length - 1; i++) {
                        const p1 = calculatedData.worldPoints[i];
                        const p2 = calculatedData.worldPoints[i+1];
                        const ptEnd = toScreen(p2.xReal, p2.zReal);
                        if (p2.type === 'G0' || p2.type === 'G1') {
                            ctx.lineTo(ptEnd.x, ptEnd.y);
                        } else if (p2.type === 'G2' || p2.type === 'G3') {
                            const arc = getArcParams({x:p1.xReal, z:p1.zReal}, {x:p2.xReal, z:p2.zReal}, p2.rVal, p2.type);
                            if (!arc.error) {
                                const sc = toScreen(arc.cx, arc.cz);
                                const r = arc.r * view.scale;
                                const ptStart = toScreen(p1.xReal, p1.zReal);
                                const sa = Math.atan2(ptStart.y - sc.y, ptStart.x - sc.x);
                                const ea = Math.atan2(ptEnd.y - sc.y, ptEnd.x - sc.x);
                                const isG2 = (p2.type === 'G2');
                                ctx.arc(sc.x, sc.y, r, sa, ea, !isG2); 
                            } else {
                                ctx.lineTo(ptEnd.x, ptEnd.y);
                            }
                        }
                    }
                    ctx.strokeStyle = colors.contour; ctx.lineWidth = 3; ctx.stroke();
                }

                // Offset
                if (calculatedData.offsetPath.length > 0) {
                    ctx.beginPath();
                    calculatedData.offsetPath.forEach((seg, i) => {
                        if (seg.type === 'line') {
                            const p1 = toScreen(seg.p1.x, seg.p1.z); const p2 = toScreen(seg.p2.x, seg.p2.z);
                            if (i === 0) ctx.moveTo(p1.x, p1.y); else ctx.lineTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                        } else if (seg.type === 'arc') {
                             const c = toScreen(seg.cx, seg.cz);
                             const startX_scr = c.x + Math.cos(Math.atan2(toScreen(seg.refP1.x, seg.refP1.z).y - c.y, toScreen(seg.refP1.x, seg.refP1.z).x - c.x)) * (seg.r * view.scale);
                             const startY_scr = c.y + Math.sin(Math.atan2(toScreen(seg.refP1.x, seg.refP1.z).y - c.y, toScreen(seg.refP1.x, seg.refP1.z).x - c.x)) * (seg.r * view.scale);
                             if (i === 0) ctx.moveTo(startX_scr, startY_scr); else ctx.lineTo(startX_scr, startY_scr); 
                             const sa_scr = Math.atan2(toScreen(seg.refP1.x, seg.refP1.z).y - c.y, toScreen(seg.refP1.x, seg.refP1.z).x - c.x);
                             const ea_scr = Math.atan2(toScreen(seg.refP2.x, seg.refP2.z).y - c.y, toScreen(seg.refP2.x, seg.refP2.z).x - c.x);
                             const isG2 = (seg.dir === 'G2');
                             ctx.arc(c.x, c.y, seg.r * view.scale, sa_scr, ea_scr, !isG2);
                        }
                    });
                    ctx.strokeStyle = colors.offset; ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.stroke();
                }

                // Roughing
                ctx.beginPath();
                calculatedData.passes.forEach(pass => {
                    const p1 = toScreen(pass.x, pass.zStart); const p2 = toScreen(pass.x, pass.zEnd);
                    ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                });
                ctx.strokeStyle = colors.pass; ctx.lineWidth = 1.5; ctx.stroke();

                // Point Labels
                const activePoints = editMode === 'contour' ? calculatedData.worldPoints : calculatedData.stockWorldPoints;
                ctx.font = "bold 11px sans-serif";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                
                activePoints.forEach((p, i) => {
                    const pt = toScreen(p.xReal, p.zReal);
                    ctx.fillStyle = editMode === 'contour' ? colors.contour : colors.pass;
                    ctx.beginPath();
                    ctx.arc(pt.x, pt.y, 3, 0, Math.PI*2);
                    ctx.fill();
                    
                    const label = `${i+1}`;
                    const tx = pt.x + 8;
                    const ty = pt.y - 8;
                    ctx.fillStyle = theme === 'dark' ? '#fbbf24' : '#d97706';
                    ctx.fillText(label, tx, ty);
                });

            }, [calculatedData, view, theme, params, editMode, mobileTab]);

            useEffect(() => {
                if (!containerRef.current || !canvasRef.current) return;
                const resizeObserver = new ResizeObserver(() => {
                    // Force redraw on resize
                    draw();
                });
                resizeObserver.observe(containerRef.current);
                return () => resizeObserver.disconnect();
            }, [draw]);

            // MOUSE HANDLERS
            const handleWheel = (e) => {
                const s = Math.max(0.5, Math.min(view.scale * (1 - Math.sign(e.deltaY)*0.1), 50));
                setView(v => ({...v, scale: s}));
            };
            const handleMouseDown = (e) => { setIsDragging(true); lastMousePos.current = { x: e.clientX, y: e.clientY }; };
            const handleMouseMove = (e) => {
                if (!isDragging) return;
                const dx = e.clientX - lastMousePos.current.x;
                const dy = e.clientY - lastMousePos.current.y;
                setView(v => ({ ...v, panX: v.panX + dx, panY: v.panY + dy }));
                lastMousePos.current = { x: e.clientX, y: e.clientY };
            };
            const handleMouseUp = () => setIsDragging(false);

            // TOUCH HANDLERS (New for Mobile)
            const handleTouchStart = (e) => {
                if (e.touches.length === 1) {
                    setIsDragging(true);
                    lastMousePos.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
            };
            const handleTouchMove = (e) => {
                if (!isDragging || e.touches.length !== 1) return;
                const dx = e.touches[0].clientX - lastMousePos.current.x;
                const dy = e.touches[0].clientY - lastMousePos.current.y;
                setView(v => ({ ...v, panX: v.panX + dx, panY: v.panY + dy }));
                lastMousePos.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            };
            const handleTouchEnd = () => setIsDragging(false);

            const processGCodeString = (text) => {
                const lines = text.split('\n');
                const newPoints = [];
                let currentType = 'G1';
                let idCounter = Date.now();
                let lastX = 100;
                let lastZ = 0;

                lines.forEach(line => {
                    const clean = line.toUpperCase().trim();
                    if (!clean || clean.startsWith(';')) return;
                    const gMatch = clean.match(/G([0-3])/);
                    if (gMatch) currentType = 'G' + gMatch[1];
                    const xMatch = clean.match(/X([-]?\d+\.?\d*)/);
                    const zMatch = clean.match(/Z([-]?\d+\.?\d*)/);
                    const rMatch = clean.match(/(?:R|CR=)([-]?\d+\.?\d*)/);

                    if (xMatch || zMatch) {
                        const newX = xMatch ? parseFloat(xMatch[1]) : lastX;
                        const newZ = zMatch ? parseFloat(zMatch[1]) : lastZ;
                        
                        newPoints.push({ 
                            id: idCounter++, 
                            type: currentType, 
                            x: newX, 
                            z: newZ, 
                            r: rMatch ? parseFloat(rMatch[1]) : 0, 
                            mode: 'ABS' 
                        });
                        lastX = newX; 
                        lastZ = newZ;
                    }
                });
                
                if (newPoints.length > 0) {
                    if (editMode === 'contour') setContourPoints(newPoints);
                    else setStockPoints(newPoints); 
                    setErrors([]);
                    fitView(); 
                } else {
                    alert("Nepodařilo se rozpoznat žádné body v G-kódu.");
                }
            };

            const parseGCode = () => processGCodeString(gCodeInput);

            // Replaces handlePasteGCode
            const handleCopyGCode = () => {
                // Use execCommand for broader compatibility in some webviews/iframes
                const textArea = document.createElement("textarea");
                textArea.value = generatedCode;
                
                // Avoid scrolling to bottom
                textArea.style.top = "0";
                textArea.style.left = "0";
                textArea.style.position = "fixed";
                
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                try {
                    const successful = document.execCommand('copy');
                    if(successful) {
                        setCopyFeedback(true);
                        setTimeout(() => setCopyFeedback(false), 2000);
                    } else {
                        alert("Kopírování selhalo.");
                    }
                } catch (err) {
                    console.error('Fallback: Oops, unable to copy', err);
                }
                
                document.body.removeChild(textArea);
            };

            const toggleMode = (id) => {
                const list = editMode === 'contour' ? contourPoints : stockPoints;
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                
                const absList = resolvePointsToAbsolute(list);
                const prevAbsPoint = absList.find((p, i) => list[i].id === id && i > 0) ? absList[absList.findIndex(p => p.id === id) - 1] : { xAbs: 0, zAbs: 0 };
                const currentAbsPoint = absList.find(p => p.id === id);
                if (!currentAbsPoint) return;

                setList(prev => prev.map(p => {
                    if (p.id !== id) return p;
                    const newMode = p.mode === 'ABS' ? 'INC' : 'ABS';
                    let newX = p.x;
                    let newZ = p.z;
                    if (newMode === 'INC') {
                        newX = currentAbsPoint.xAbs - prevAbsPoint.xAbs;
                        newZ = currentAbsPoint.zAbs - prevAbsPoint.zAbs;
                    } else {
                        newX = currentAbsPoint.xAbs;
                        newZ = currentAbsPoint.zAbs;
                    }
                    newX = parseFloat(newX.toFixed(3));
                    newZ = parseFloat(newZ.toFixed(3));
                    return { ...p, mode: newMode, x: newX, z: newZ };
                }));
            };

            const updatePoint = (id, f, v) => {
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                setList(prev => prev.map(p => p.id===id ? {...p, [f]: v} : p));
            };
            
            const addPoint = () => { 
                const list = editMode === 'contour' ? contourPoints : stockPoints;
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                const last = list.length > 0 ? list[list.length - 1] : { x: 100, z: 0 };
                setList([...list, {id: Date.now(), type:'G1', x:last.x, z: parseFloat(last.z)-10, r:0, mode: 'ABS'}]); 
            };

            const insertPoint = (index) => {
                const list = editMode === 'contour' ? contourPoints : stockPoints;
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                const prev = list[index];
                const newPoint = { ...prev, id: Date.now(), z: parseFloat(prev.z) - 5 };
                const newList = [...list];
                newList.splice(index + 1, 0, newPoint);
                setList(newList);
            };
            
            const removePoint = (id) => {
                const list = editMode === 'contour' ? contourPoints : stockPoints;
                const setList = editMode === 'contour' ? setContourPoints : setStockPoints;
                if (list.length > 1) setList(list.filter(p=>p.id!==id));
            };

            const currentPoints = editMode === 'contour' ? contourPoints : stockPoints;

            return (
                <div className="flex flex-col md:flex-row h-full">
                    
                    {/* --- LEFT SIDEBAR (Editor) --- 
                        Mobile Logic: Hidden if mobileTab is 'preview', but always shown on Desktop (md:flex) 
                    */}
                    <div className={`${mobileTab === 'editor' ? 'flex' : 'hidden'} md:flex w-full md:w-96 flex-col border-r shadow-xl z-10 ${theme === 'dark' ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'}`}>
                        <div className={`p-4 border-b flex justify-between items-center ${theme === 'dark' ? 'bg-gray-900 border-gray-700' : 'bg-gray-100 border-gray-200'}`}>
                            <h1 className="font-bold text-lg text-blue-500">Sinumerik CAM</h1>
                            <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')} className="p-2 rounded hover:bg-gray-700 hover:text-white transition-colors">
                                {theme === 'light' ? <IconMoon /> : <IconSun />}
                            </button>
                        </div>
                        {errors.length > 0 && (
                            <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-2 text-xs">
                                <p className="font-bold">Chyby:</p>
                                <ul className="list-disc pl-4">{errors.map((e, i) => <li key={i}>{e}</li>)}</ul>
                            </div>
                        )}
                        <div className="flex border-b border-gray-200 dark:border-gray-700">
                             {['editor', 'params', 'import'].map(tab => (
                                <button key={tab} onClick={() => setActiveTab(tab)} 
                                    className={`flex-1 p-3 text-sm font-medium capitalize ${activeTab===tab ? 'bg-blue-100 text-blue-700' : 'text-gray-500'}`}>
                                    {tab}
                                </button>
                            ))}
                        </div>
                         <div className="flex-1 overflow-y-auto p-4 custom-scrollbar pb-20 md:pb-4">
                            {activeTab === 'editor' && (
                                <div className="space-y-3">
                                    <div className="flex gap-2 mb-2 bg-gray-200 p-1 rounded dark:bg-gray-700">
                                        <button onClick={() => setEditMode('contour')} className={`flex-1 flex items-center justify-center gap-2 text-xs py-1.5 rounded font-bold transition-all ${editMode==='contour' ? 'bg-white shadow text-blue-600 dark:bg-gray-600 dark:text-blue-300' : 'text-gray-500 hover:text-gray-700'}`}><IconEdit /> Kontura</button>
                                        <button onClick={() => { setEditMode('stock'); if(stockPoints.length === 0) generateDefaultStock(); }} className={`flex-1 flex items-center justify-center gap-2 text-xs py-1.5 rounded font-bold transition-all ${editMode==='stock' ? 'bg-white shadow text-green-600 dark:bg-gray-600 dark:text-green-300' : 'text-gray-500 hover:text-gray-700'}`}><IconBox /> Polotovar</button>
                                    </div>
                                    <div className="flex gap-1 px-2 text-xs font-bold text-gray-500 mb-1">
                                        <div className="w-6 text-center">#</div>
                                        <div className="w-14">Typ</div>
                                        <div className="w-8 text-center">Mód</div>
                                        <div className="w-16 text-center">X/U</div>
                                        <div className="w-16 text-center">Z/W</div>
                                        <div className="w-10 text-center">R</div>
                                    </div>
                                    {currentPoints.map((p, index) => (
                                        <div key={p.id} className={`border rounded p-2 flex flex-wrap gap-1 items-center ${theme === 'dark' ? 'bg-gray-750 border-gray-600' : 'bg-gray-50 border-gray-300'} ${editMode==='stock' ? 'border-l-4 border-l-green-500' : 'border-l-4 border-l-blue-500'}`}>
                                            <div className="w-6 font-mono text-xs text-gray-500 font-bold">{index+1}</div>
                                            <select value={p.type} onChange={(e) => updatePoint(p.id, 'type', e.target.value)} className={`border rounded text-xs px-1 py-1 w-14 ${theme==='dark'?'bg-gray-900 border-gray-600':'bg-white border-gray-300'}`}><option>G0</option><option>G1</option><option>G2</option><option>G3</option></select>
                                            
                                            <button 
                                                onClick={() => toggleMode(p.id)}
                                                className={`w-8 h-6 flex items-center justify-center rounded text-xs font-bold ${p.mode==='INC' ? 'bg-purple-100 text-purple-700 border border-purple-300' : 'bg-gray-100 text-gray-600 border border-gray-300'}`}
                                                title={p.mode === 'INC' ? 'Přírůstkově' : 'Absolutně'}
                                            >
                                                {p.mode === 'INC' ? 'INC' : 'ABS'}
                                            </button>

                                            <input type="number" value={p.x} onChange={(e) => updatePoint(p.id, 'x', e.target.value)} className={`border rounded text-sm w-16 px-1 py-1 ${theme==='dark'?'bg-gray-900 border-gray-600':'bg-white border-gray-300'}`} placeholder={p.mode==='INC' ? 'U' : 'X'} />
                                            <input type="number" value={p.z} onChange={(e) => updatePoint(p.id, 'z', e.target.value)} className={`border rounded text-sm w-16 px-1 py-1 ${theme==='dark'?'bg-gray-900 border-gray-600':'bg-white border-gray-300'}`} placeholder={p.mode==='INC' ? 'W' : 'Z'} />
                                            {(p.type === 'G2' || p.type === 'G3') && <input type="number" value={p.r} onChange={(e) => updatePoint(p.id, 'r', e.target.value)} className={`border rounded text-sm w-10 px-1 py-1 ${theme==='dark'?'bg-gray-900 border-gray-600':'bg-white border-gray-300'}`} placeholder="R" />}
                                            
                                            <div className="flex ml-auto gap-1">
                                                <button onClick={() => insertPoint(index)} className="text-blue-500 hover:text-blue-700 p-1" title="Vložit řádek za"><IconInsert /></button>
                                                <button onClick={() => removePoint(p.id)} className="text-red-400 hover:text-red-600 p-1" title="Smazat řádek"><IconTrash /></button>
                                            </div>
                                        </div>
                                    ))}
                                    <div className="flex gap-2">
                                        <button onClick={addPoint} className={`flex-1 py-2 text-white rounded text-sm font-bold flex justify-center items-center gap-2 ${editMode==='stock'?'bg-green-600 hover:bg-green-500':'bg-blue-600 hover:bg-blue-500'}`}><IconPlus /> Bod</button>
                                        <button 
                                            onClick={handleCopyGCode} 
                                            className={`flex-1 py-2 text-white rounded text-sm font-bold flex justify-center items-center gap-2 transition-all ${copyFeedback ? 'bg-green-600' : 'bg-purple-600 hover:bg-purple-500'}`}
                                        >
                                            <IconClipboard /> {copyFeedback ? "Zkopírováno!" : "Export G-kódu"}
                                        </button>
                                    </div>
                                </div>
                            )}
                             {activeTab === 'params' && (
                                <div className="space-y-4">
                                    <h3 className={`font-bold border-b pb-1 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Polotovar</h3>
                                    <div className="flex gap-2 mb-2">
                                        <button onClick={() => setParams({...params, stockMode: 'cylinder'})} className={`flex-1 py-1 text-xs border rounded ${params.stockMode==='cylinder' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Válec</button>
                                        <button onClick={() => setParams({...params, stockMode: 'casting'})} className={`flex-1 py-1 text-xs border rounded ${params.stockMode==='casting' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700'}`}>Odlitek (Fanuc)</button>
                                    </div>
                                    {params.stockMode === 'cylinder' ? (
                                        <div className="space-y-2">
                                            <div className="flex items-end gap-2">
                                                <div className="flex-1"><label className="text-xs text-gray-500">Průměr (D)</label><input type="number" value={params.stockDiameter} onChange={e=>setParams({...params, stockDiameter:e.target.value})} className="border rounded p-1 w-full"/></div>
                                                <div className="flex-1"><label className="text-xs text-gray-500">Délka (Z-)</label><input type="number" value={params.stockLength} onChange={e=>setParams({...params, stockLength:e.target.value})} className="border rounded p-1 w-full"/></div>
                                            </div>
                                            <div className="flex items-end gap-2">
                                                <div className="flex-1"><label className="text-xs text-gray-500">Přídavek čelo (Z+)</label><input type="number" value={params.stockFace} onChange={e=>setParams({...params, stockFace:e.target.value})} className="border rounded p-1 w-full"/></div>
                                                <div className="flex-1"><label className="text-xs text-gray-500">Přídavek (pro Auto)</label><input type="number" value={params.stockMargin} onChange={e=>setParams({...params, stockMargin:e.target.value})} className="border rounded p-1 w-full"/></div>
                                            </div>
                                            <button onClick={handleAutoStock} className="w-full py-1.5 bg-indigo-600 text-white rounded text-xs font-bold flex items-center justify-center gap-1 hover:bg-indigo-500"><IconMagic /> Auto-rozměr</button>
                                        </div>
                                    ) : (
                                        <div className="text-xs text-gray-500 italic p-2 bg-gray-100 rounded dark:bg-gray-800">
                                            Pro definici tvarového polotovaru (odlitku) použijte přepínač "Polotovar" v záložce <b>Editor</b> a nakreslete jeho tvar.
                                        </div>
                                    )}

                                    <h3 className={`font-bold border-b pb-1 mt-4 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Hrubování</h3>
                                    <div className="grid grid-cols-2 gap-2">
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Hloubka (ap)</label><input type="number" step="0.5" value={params.depthOfCut} onChange={e=>setParams({...params, depthOfCut:e.target.value})} className="border rounded p-1"/></div>
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Posuv (F)</label><input type="number" step="0.05" value={params.feed} onChange={e=>setParams({...params, feed:e.target.value})} className="border rounded p-1"/></div>
                                    </div>
                                    
                                    <h3 className={`font-bold border-b pb-1 mt-4 ${theme==='dark'?'text-gray-300 border-gray-700':'text-gray-800 border-gray-300'}`}>Nástroj</h3>
                                    <div className="grid grid-cols-2 gap-2">
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Rádius (R)</label><input type="number" step="0.1" value={params.toolRadius} onChange={e=>setParams({...params, toolRadius:e.target.value})} className="border rounded p-1"/></div>
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Přídavek X</label><input type="number" step="0.1" value={params.allowanceX} onChange={e=>setParams({...params, allowanceX:e.target.value})} className="border rounded p-1"/></div>
                                        <div className="flex flex-col"><label className="text-xs text-gray-500">Přídavek Z</label><input type="number" step="0.1" value={params.allowanceZ} onChange={e=>setParams({...params, allowanceZ:e.target.value})} className="border rounded p-1"/></div>
                                    </div>
                                </div>
                            )}
                             {activeTab === 'import' && (
                                <div className="flex flex-col h-full">
                                    <textarea className="flex-1 border p-2 font-mono text-xs mb-2" value={gCodeInput} onChange={e=>setGCodeInput(e.target.value)} placeholder="G1 X... Z..."></textarea>
                                    <button onClick={parseGCode} className="bg-green-600 text-white py-2 rounded">Import</button>
                                </div>
                            )}
                        </div>
                    </div>

                    {/* --- RIGHT SIDEBAR (Canvas/Preview) --- 
                        Mobile Logic: Shown only if mobileTab is 'preview', or always on Desktop (md:flex)
                    */}
                     <div className={`${mobileTab === 'preview' ? 'flex' : 'hidden'} md:flex flex-1 flex-col relative pb-20 md:pb-0 ${theme === 'dark' ? 'bg-gray-900' : 'bg-gray-50'}`}>
                        <div className="absolute top-4 right-4 z-10">
                            <button onClick={fitView} className="bg-white p-2 rounded shadow text-gray-700 hover:text-blue-600" title="Centrovat pohled"><IconTarget /></button>
                        </div>
                        <div ref={containerRef} className={`flex-1 overflow-hidden relative canvas-container`}
                             onWheel={handleWheel} 
                             onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp}
                             onTouchStart={handleTouchStart} onTouchMove={handleTouchMove} onTouchEnd={handleTouchEnd}>
                            <canvas ref={canvasRef} className="block" />
                        </div>
                        <div className={`h-48 border-t flex flex-col ${theme === 'dark' ? 'bg-gray-950 border-gray-700' : 'bg-white border-gray-300'}`}>
                             <textarea readOnly className={`flex-1 bg-transparent p-4 text-xs font-mono focus:outline-none resize-none ${theme === 'dark' ? 'text-green-300' : 'text-gray-800'}`} value={generatedCode} />
                        </div>
                    </div>

                    {/* --- MOBILE BOTTOM NAVIGATION --- */}
                    <div className="md:hidden fixed bottom-0 left-0 right-0 h-16 bg-white border-t border-gray-200 flex z-50 safe-pb dark:bg-gray-900 dark:border-gray-700">
                        <button 
                            onClick={() => setMobileTab('editor')} 
                            className={`flex-1 flex flex-col items-center justify-center ${mobileTab==='editor' ? 'text-blue-600' : 'text-gray-500'}`}
                        >
                            <IconEdit />
                            <span className="text-xs font-bold mt-1">Editor</span>
                        </button>
                        <button 
                            onClick={() => setMobileTab('preview')} 
                            className={`flex-1 flex flex-col items-center justify-center ${mobileTab==='preview' ? 'text-blue-600' : 'text-gray-500'}`}
                        >
                            <IconEye />
                            <span className="text-xs font-bold mt-1">Náhled</span>
                        </button>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
