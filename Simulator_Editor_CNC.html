<!DOCTYPE html>
<html lang="cs">
<head>
    <!-- ... st√°vaj√≠c√≠ k√≥d ... -->
    <meta charset="UTF-8">
    <!-- OPRAVENO: Povoleno zoomov√°n√≠ pro lep≈°√≠ p≈ô√≠stupnost na mobilu -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>CNC Editor - Sinumerik 840D</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <style>
        /* ... st√°vaj√≠c√≠ k√≥d ... */
        
        /* OPRAVA: Zabr√°nƒõn√≠ "sk√°k√°n√≠" layoutu p≈ôi zobrazen√≠ kl√°vesnice */
        html {
            height: 100%;
            overflow: hidden; /* Zabr√°n√≠ scrollov√°n√≠ cel√© str√°nky */
        }

        body {
            margin: 0;
            padding: 0;
            height: 100%; /* ZMƒöNA: z 100vh na 100% */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Zabr√°n√≠ scrollov√°n√≠ tƒõla str√°nky */
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%; /* P≈ôid√°no pro jistotu */
        }

        .simulator {
            /* ZMƒöNA: Odebr√°na v√Ω≈°ka 50vh, nahrazeno flexboxem */
            flex: 1; /* Zabere 1 d√≠l dostupn√©ho m√≠sta */
            min-height: 200px; /* Minim√°ln√≠ v√Ω≈°ka, aby se nescvrknul moc */
            width: 100%;
            border-bottom: 1px solid #ccc;
            position: relative; /* D≈Øle≈æit√© pro .canvas-container */
        }

        .editor-container {
            /* ZMƒöNA: flex: 1 nahrazeno flex: 1.5, aby byl editor vƒõt≈°√≠ */
            flex: 1.5; /* Zabere 1.5 d√≠lu m√≠sta (vƒõt≈°√≠ ne≈æ simul√°tor) */
            display: flex;
            flex-direction: column;
            background: #fff;
            position: relative;
            overflow: hidden;
            min-height: 0; /* D≈Øle≈æit√© pro spr√°vn√© scrollov√°n√≠ */
        }

        .canvas-container {
            /* ZMƒöNA: P≈ôid√°n position: absolute, aby vyplnil rodiƒçe (.simulator) */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f8f9fa;
        }

        .axis-label {
            position: absolute;
            color: #000;
            font-weight: bold;
        }

        .axis-label.x {
            bottom: 10px;
            right: 10px;
        }

        .axis-label.z {
            top: 10px;
            left: 10px;
        }

        .position-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 24px; /* Zvƒõt≈°eno z 14px */
            font-family: monospace;
            z-index: 1000;
            pointer-events: none;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
            min-width: 220px; /* P≈ôid√°no pro lep≈°√≠ ƒçitelnost */
        }

        /* Mobiln√≠ optimalizace */
        @media (max-width: 768px) {
            /* * OPRAVA: Odstranƒõna problematick√° pravidla pro .simulator a .editor-container.
             * Nov√Ω flexbox layout v .container se postar√° o responzivitu s√°m
             * a nebude se hroutit p≈ôi zobrazen√≠ kl√°vesnice.
             */
            /*
            .simulator {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                height: 45vh; 
                z-index: 100;
                background: #fff;
            }

            .editor-container {
                margin-top: 45vh;
                height: 55vh;
                position: relative;
            }
            */

            .toolbar {
                padding: 5px;
                gap: 5px;
                flex-wrap: wrap; /* Povolit zalamov√°n√≠ tlaƒç√≠tek na mobilu */
            }

            .toolbar button {
                height: 40px;
                min-width: 100px;
                font-size: 16px;
                margin: 2px;
                border-radius: 4px;
                border: 1px solid #ccc;
                background: white;
                touch-action: manipulation;
            }

            .toolbar button:active {
                background: #e6e6e6;
            }

            .position-info {
                font-size: 20px; /* Zvƒõt≈°eno pro mobily */
                padding: 12px 16px;
                right: 5px;
                top: 5px;
                background: rgba(0, 0, 0, 0.9);
            }

            #editor {
                font-size: 18px; /* Vƒõt≈°√≠ p√≠smo pro mobiln√≠ za≈ô√≠zen√≠ */
                line-height: 2em; /* Vƒõt≈°√≠ ≈ô√°dkov√°n√≠ pro lep≈°√≠ ƒçitelnost a klik√°n√≠ */
                padding: 20px;
                height: 100%; /* ZMƒöNA: V√Ω≈°ka 100% rodiƒçe (.editor-wrapper) */
                position: relative;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                overscroll-behavior: contain;
                inputmode: numeric;
                pattern: "[0-9]*";
                -webkit-appearance: none;
                /* Odebr√°no height: calc(100% - 40px); */
            }

            /* P≈ôidat styl pro fixn√≠ pozici oznaƒçen√©ho ≈ô√°dku */
            .editor-line-highlight {
                position: sticky;
                top: 40px; /* Druh√° pozice od vrchu */
                background-color: #e6f3ff;
                z-index: 1;
                padding: 8px 0;
                margin: 4px 0;
            }

            /* Zvƒõt≈°it mezeru mezi ≈ô√°dky pro lep≈°√≠ dotykov√© ovl√°d√°n√≠ */
            .editor-line {
                min-height: 2em;
                padding: 8px 0;
            }

            /* Vylep≈°en√≠ scrollov√°n√≠ pro touch za≈ô√≠zen√≠ */
            .editor-container::-webkit-scrollbar {
                width: 8px;
            }

            .editor-container::-webkit-scrollbar-thumb {
                background: rgba(0,0,0,0.2);
                border-radius: 4px;
            }
        }

        /* Vylep≈°en√≠ pro dotykov√© ovl√°d√°n√≠ */
        @media (hover: none) {
            .toolbar button {
                padding: 12px; /* Vƒõt≈°√≠ tlaƒç√≠tka pro dotyk */
                margin: 2px;
            }

            #editor {
                -webkit-overflow-scrolling: touch;
            }

            .tooltip {
                padding: 10px 20px;
                font-size: 18px;
            }

            .crosshair {
                width: 30px;
                height: 30px;
            }

            .crosshair::before {
                left: 14px;
                width: 2px;
                height: 30px;
            }

            .crosshair::after {
                top: 14px;
                height: 2px;
                width: 30px;
            }

            /* Zvƒõt≈°en√≠ dotykov√© plochy pro body */
            .canvas-container canvas {
                touch-action: none; /* Zabr√°nit v√Ωchoz√≠m gest≈Øm */
            }
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px; /* Zvƒõt≈°it vnit≈ôn√≠ odsazen√≠ */
            border-radius: 6px;
            font-size: 16px; /* Zvƒõt≈°it p√≠smo */
            pointer-events: none;
            z-index: 1000;
            min-width: 120px; /* P≈ôidat minim√°ln√≠ ≈°√≠≈ôku */
            text-align: center; /* Vycentrovat text */
        }

        .crosshair {
            position: absolute;
            width: 20px;
            height: 20px;
            pointer-events: none;
            display: none;
            z-index: 1001;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: #000;
        }

        .crosshair::before {
            left: 9px;
            width: 2px;
            height: 20px;
        }

        .crosshair::after {
            top: 9px;
            height: 2px;
            width: 20px;
        }

        #editor {
            width: 100%;
            height: 100%; /* Zmƒõnƒõno - editor vypln√≠ cel√Ω prostor */
            resize: none; /* Zak√°z√°n√≠ manu√°ln√≠ho resizu */
            padding: 10px;
            box-sizing: border-box;
            font-family: monospace;
            border: none;
            outline: none;
            background: #fff;
            line-height: 1.5;
            cursor: pointer;
            background: linear-gradient(
                transparent calc(1.5em * var(--selected-line)),
                #e6f3ff calc(1.5em * var(--selected-line)),
                #e6f3ff calc(1.5em * (var(--selected-line) + 1)),
                transparent calc(1.5em * (var(--selected-line) + 1))
            );
            background-size: 100% 100%;
            line-height: 1.5em;
            -webkit-overflow-scrolling: touch; /* P≈ôid√°no pro iOS smooth scroll */
            overflow-y: auto; /* P≈ôid√°no - povolit vertik√°ln√≠ scroll */
            position: absolute; /* P≈ôid√°no */
            top: 0; /* P≈ôid√°no */
            left: 0; /* P≈ôid√°no */
            right: 0; /* P≈ôid√°no */
            bottom: 0; /* P≈ôid√°no */
            -webkit-overflow-scrolling: touch;
            overflow-y: auto;
            overscroll-behavior: contain;
            touch-action: pan-y;
            user-select: text;
            -webkit-user-select: text;
            padding: 16px; /* Vƒõt≈°√≠ padding pro lep≈°√≠ dotykov√© ovl√°d√°n√≠ */
            font-size: 16px; /* Vƒõt≈°√≠ p√≠smo pro mobily */
        }

        /* P≈ôid√°no - styl pro zv√Ωraznƒõn√Ω ≈ô√°dek */
        #editor.has-selection {
            background: linear-gradient(
                transparent 0%,
                transparent calc(1.5em * var(--selected-line)),
                #e6f3ff calc(1.5em * var(--selected-line)),
                #e6f3ff calc(1.5em * (var(--selected-line) + 1)),
                transparent calc(1.5em * (var(--selected-line) + 1))
            );
        }

        .editor-line-highlight {
            background-color: #e6f3ff;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(2); opacity: 0.5; }
            100% { transform: scale(1); opacity: 1; }
        }

        .point-pulse {
            animation: pulse 1s infinite;
        }

        /* P≈ôid√°na nov√° animace pro pulzuj√≠c√≠ bod */
        @keyframes pointPulse {
            0% {
                stroke-opacity: 1;
                r: 5;
            }
            50% {
                stroke-opacity: 0.8;
                r: 10;
            }
            100% {
                stroke-opacity: 1;
                r: 5;
            }
        }

        /* P≈ôidat styly pro ovl√°dac√≠ prvky p≈ôehr√°vaƒçe */
        .player-controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 5px;
            border-radius: 4px;
            display: flex;
            gap: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .player-controls button {
            padding: 5px 10px;
            border: 1px solid #ccc;
            background: white;
            border-radius: 3px;
            cursor: pointer;
        }

        .player-controls button:hover {
            background: #f0f0f0;
        }

        .player-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .playback-progress {
            position: absolute;
            bottom: 50px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px;
            border-radius: 4px;
            font-size: 12px;
        }

        /* Upravit styly p≈ôehr√°vaƒçe */
        .player-controls {
            /* ...existing styles... */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .player-controls button {
            width: 40px;
            height: 40px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            /* ...rest of existing button styles... */
        }

        #speedSlider {
            width: 100px;
        }

        /* P≈ôidat nov√© styly pro p≈ôehr√°vaƒç nad editorem */
        .controls-container {
            padding: 10px;
            background: #f5f5f5;
            border-top: 1px solid #ddd;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .player-container {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
        }

        .player-controls {
            position: static;
            transform: none;
            background: none;
            box-shadow: none;
            padding: 0;
            display: flex;
            align-items: center;
            gap: 5px;
            margin: 0;
        }

        .player-controls button {
            width: 40px;
            height: 40px;
            padding: 0;
            border-radius: 20px;
            border: 1px solid #ccc;
            background: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }

        #speedSlider {
            width: 100px;
            margin: 0;
        }

        /* Mobiln√≠ optimalizace */
        @media (max-width: 768px) {
            .controls-container {
                flex-direction: column;
                padding: 5px;
            }

            .player-container {
                width: 100%;
                justify-content: center;
            }

            .player-controls button {
                width: 50px;
                height: 50px;
                font-size: 24px;
            }

            #speedSlider {
                width: 80px;
            }

            .toolbar {
                flex-wrap: wrap;
                justify-content: center;
            }
        }

        .file-input-container {
            position: relative;
            overflow: hidden;
            display: inline-block;
            display: flex;
            width: 100%;
            margin-bottom: 8px;
        }

        .file-input-container input[type="file"] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
        }

        .file-input-button {
            padding: 8px 15px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: inline-block;
            display: block;
            width: 100%;
            padding: 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            text-align: center;
            margin: 4px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .file-name {
            margin-left: 10px;
            color: #666;
            margin-left: 10px;
            color: #666;
            background: white;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
            margin: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: block;
            width: 100%;
        }

        .editor-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
            min-height: 0; /* D≈Øle≈æit√© pro spr√°vn√© scrollov√°n√≠ */
        }

        .program-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            padding: 5px;
            flex-shrink: 0; /* OPRAVA: Zabr√°n√≠ smr≈°tƒõn√≠ */
        }

        .program-list-item {
            flex: 0 0 auto;
            padding: 5px 10px;
            background: #f0f0f0;
            border-radius: 4px;
            cursor: pointer;
            white-space: nowrap;
            border: 1px solid #ddd;
        }

        .program-list-item:hover {
            background: #e0e0e0;
        }

        .program-list-item.active {
            background: #007bff;
            color: white;
            border-color: #0056b3;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 600px;
            border-radius: 8px;
            max-height: 70vh;
            overflow-y: auto;
        }

        .parameters-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .parameters-table th,
        .parameters-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .parameters-table th {
            background-color: #f5f5f5;
        }

        .close {
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: #f00;
        }

        .action-button {
            padding: 8px 16px;
            margin: 4px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .action-button:hover {
            background: #0056b3;
        }

        /* Upraven√© styly pro toolbar */
        .toolbar {
            display: flex;
            flex-direction: row;
            gap: 8px;
            padding: 8px;
            align-items: center;
            flex-shrink: 0; /* OPRAVA: Zabr√°n√≠ smr≈°tƒõn√≠ */
        }

        .file-input-button {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 80px;
            font-size: 24px;
            flex: 1;
            background: #007bff;
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            padding: 0;
        }

        .action-button {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 80px;
            font-size: 24px;
            flex: 1;
            background: #007bff;
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            padding: 0;
        }

        .action-button:hover, .file-input-button:hover {
            background: #0056b3;
        }

        /* P≈ôidat styly pro touch za≈ô√≠zen√≠ */
        @media (hover: none) {
            .toolbar button, .file-input-button {
                min-height: 80px;
                font-size: 24px;
                touch-action: manipulation;
            }

            .toolbar {
                touch-action: none;
                user-select: none;
            }
        }

        /* P≈ôidat styly pro ikony */
        .button-icon {
            font-size: 32px;
            margin-bottom: 4px;
        }

        /* Upraven√© styly pro player controls */
        .controls-container {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            gap: 8px;
            background: none;
            border: none;
        }

        .player-container {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 2; /* Zvƒõt≈°it na dvojn√°sobek oproti ostatn√≠m tlaƒç√≠tk≈Øm */
        }

        .player-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .player-controls button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 120px; /* Zvƒõt≈°it ≈°√≠≈ôku tlaƒç√≠tek */
            min-height: 80px;
            font-size: 32px;
            flex: 1;
            background: #007bff;
            border: none;
            border-radius: 8px;
            color: white;
            padding: 0;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px; /* Zvƒõt≈°it p√≠smo */
            min-width: 150px; /* Minim√°ln√≠ ≈°√≠≈ôka pro poƒç√≠tadlo */
        }

        #speedSlider {
            width: 200px; /* Zvƒõt≈°it ≈°√≠≈ôku slideru */
            height: 40px;
        }

        .program-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            padding: 5px;
            width: 100%;
            background: #f5f5f5;
            border-bottom: 1px solid #ddd;
            min-height: 50px;
            box-sizing: border-box; /* P≈ôid√°no */
        }

        .player-container {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 3; /* Zvƒõt≈°it na trojn√°sobek */
            flex-wrap: wrap; /* Povolit zalamov√°n√≠ */
            padding: 8px;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px;
            min-width: 200px; /* Vƒõt≈°√≠ minim√°ln√≠ ≈°√≠≈ôka */
            margin-top: 8px; /* Odsazen√≠ shora */
            flex-direction: column; /* Informace pod sebe */
            align-items: flex-start;
        }

        #speedSlider {
            width: 250px; /* Vƒõt≈°√≠ ≈°√≠≈ôka slideru */
            height: 40px;
        }

        .program-list {
            padding: 10px;
            min-height: 60px; /* Vƒõt≈°√≠ minim√°ln√≠ v√Ω≈°ka */
        }

        .program-list-item {
            padding: 12px 16px; /* Vƒõt≈°√≠ padding */
            font-size: 18px; /* Vƒõt≈°√≠ p√≠smo */
            margin: 4px;
            min-width: 120px; /* Minim√°ln√≠ ≈°√≠≈ôka polo≈æky */
        }

        @media (max-width: 768px) {
            .player-container {
                padding: 12px;
            }

            .player-controls button {
                width: 80px; /* Vƒõt≈°√≠ ≈°√≠≈ôka tlaƒç√≠tek na mobilu */
                min-height: 80px;
            }

            .player-info {
                width: 100%; /* Na celou ≈°√≠≈ôku na mobilu */
                text-align: center;
                padding: 8px;
            }

            #speedSlider {
                width: 100%; /* Slider na celou ≈°√≠≈ôku */
                margin: 8px 0;
            }

            .program-list-item {
                flex: 1 1 auto; /* Lep≈°√≠ p≈ôizp≈Øsoben√≠ na mobilu */
                text-align: center;
                min-width: 150px; /* Vƒõt≈°√≠ minim√°ln√≠ ≈°√≠≈ôka na mobilu */
            }
        }

        .home-link {
            position: absolute;
            top: 70px; /* Posunout dol≈Ø pod position-info */
            right: 10px;
            color: #333;
            text-decoration: none;
            font-size: 24px;
            z-index: 2000;
            background: white; /* P≈ôidat b√≠l√© pozad√≠ */
            padding: 8px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .home-link:hover {
            color: #666;
            background: #f5f5f5;
        }
    </style>
</head>
<body>
    <a href="index.html" class="home-link">
        <i class="fas fa-home"></i>
    </a>
    <div class="container">
        <div class="simulator">
            <div class="canvas-container">
                <canvas id="simulatorCanvas"></canvas>
                <div class="position-info">
                    Aktu√°ln√≠: X: <span id="posX">0.000</span> Z: <span id="posZ">0.000</span><br>
                    Vybran√Ω: X: <span id="selectedPosX">-</span> Z: <span id="selectedPosZ">-</span>
                </div>
            </div>
        </div>
        <div class="toolbar">
            <label class="file-input-button">
                <span class="button-icon">üìÇ</span>
                <input type="file" id="actualFileInput" accept=".mpf,.spf" multiple style="display: none;">
            </label>
            <button onclick="window.simulator.resetView()" class="action-button">
                <span class="button-icon">üîÑ</span>
            </button>
            <button onclick="showParameters()" class="action-button">
                <span class="button-icon">R</span>
            </button>
            <div class="player-container">
                <button id="prevBtn" class="action-button" title="Krok zpƒõt">
                    <span class="button-icon">‚è™</span>
                </button>
                <button id="playBtn" class="action-button" title="P≈ôehr√°t/Pozastavit">
                    <span class="button-icon">‚ñ∂Ô∏è</span>
                </button>
                <button id="nextBtn" class="action-button" title="Krok vp≈ôed">
                    <span class="button-icon">‚è©</span>
                </button>
                <div class="player-info">
                    <input type="range" id="speedSlider" min="1" max="100" value="50" title="Rychlost p≈ôehr√°v√°n√≠">
                    <span>≈ò√°dek: <span id="currentLine">0</span>/<span id="totalLines">0</span></span>
                </div>
            </div>
        </div>
        <div class="program-list" id="programList"></div>
        <div class="editor-container">
            <div class="editor-wrapper">
                <textarea id="editor" spellcheck="false" placeholder="Vlo≈æte v√°≈° CNC program zde..."></textarea>
            </div>
        </div>
    </div>
    <div id="parametersModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeParametersModal()">&times;</span>
            <h2>Aktu√°ln√≠ hodnoty parametr≈Ø</h2>
            <table class="parameters-table">
                <thead>
                    <tr>
                        <th>Parametr</th>
                        <th>Hodnota</th>
                    </tr>
                </thead>
                <tbody id="parametersTableBody">
                </tbody>
            </table>
        </div>
    </div>
    <script>
        // Pomocn√© funkce pro optimalizaci
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function throttle(func, limit) {
            let inThrottle;
            return function(...args) {
                if (!inThrottle) {
                    func.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            }
        }

        // Optimalizovan√° debug funkce
        let debugCounter = 0;
        function debug(message) {
            console.log(`[${new Date().toLocaleTimeString()}] ${message}`);
        }

        // Inicializace z√°kladn√≠ch promƒõnn√Ωch
        const editor = document.getElementById('editor');
        const fileInput = document.getElementById('actualFileInput');
        const fileNameDisplay = document.getElementById('fileName');
        const posXElement = document.getElementById('posX');
        const posZElement = document.getElementById('posZ');
        const selectedPosXElement = document.getElementById('selectedPosX');
        const selectedPosZElement = document.getElementById('selectedPosZ');

        class CNCParser {
            constructor() {
                // Nejprve inicializovat mapy p≈ôed vol√°n√≠m reset()
                this.parameters = new Map();
                this.loadedSubprograms = new Map();
                this.baseDirectory = '';
                this.subprogramFiles = new Map(); // P≈ôidat cache pro soubory podprogram≈Ø
                this.loadedPrograms = new Map(); // Pro ukl√°d√°n√≠ v≈°ech naƒçten√Ωch program≈Ø

                // P≈ôednastaven√© parametry
                for (let i = 0; i <= 99; i++) {
                    this.parameters.set(`R${i}`, 0);
                }

                // A≈æ potom volat reset
                this.reset();
            }

            reset() {
                this.currentX = 0;
                this.currentZ = 0;
                this.absoluteMode = true;
                // this.rapidMode = true; // ZRU≈†ENO - ≈ô√≠zeno p≈ôes modalMotionCommand
                this.isFirstMove = true;
                this.modalMotionCommand = 'G0'; // G0 je v√Ωchoz√≠ mod√°ln√≠ p≈ô√≠kaz (rychloposuv)

                // Reset parametr≈Ø - teƒè u≈æ v√≠me, ≈æe Map existuje
                if (this.parameters) {
                    this.parameters.clear();
                    for (let i = 0; i <= 99; i++) {
                        this.parameters.set(`R${i}`, 0);
                    }
                }

                debug('Parser resetov√°n');
            }

            // P≈ôidat metodu pro zpracov√°n√≠ R-parametr≈Ø
            evaluateParameters(expression) {
                try {
                    // console.group('Parsov√°n√≠ parametr≈Ø z ≈ô√°dku:', expression); // P≈ô√≠li≈° upov√≠dan√©
                    
                    // Odstranit koment√°≈ôe za st≈ôedn√≠kem (ale ne za lom√≠tkem)
                    const fullLine = expression.split(';')[0].trim();

                    // Odstranit ƒç√≠slo ≈ô√°dku a p≈ô√≠padn√© mezery na zaƒç√°tku
                    const cleanLine = fullLine.replace(/^N\d+\s*/, '');

                    // console.log('Vyƒçi≈°tƒõn√Ω ≈ô√°dek:', cleanLine);

                    // Upraven√Ω regex pro zachycen√≠ v≈°ech R-p≈ôi≈ôazen√≠ vƒçetnƒõ matematick√Ωch operac√≠
                    const rAssignment = cleanLine.match(/R(\d+)\s*=\s*(.+)/);

                    if (rAssignment) {
                        const [, paramNum, expression] = rAssignment;

                        try {
                            // Expandovat v≈°echny R-parametry ve v√Ωrazu
                            const expandedExpr = expression.replace(/R(\d+)/g, (match, num) => {
                                const value = this.parameters.get(`R${num}`);
                                return value !== undefined ? value : '0';
                            });

                            // Vyƒçistit v√Ωraz a odstranit p≈ô√≠padn√© z√°vorky
                            let cleanExpr = expandedExpr.replace(/^\(|\)$/g, '');

                            // Bezpeƒçnƒõ vyhodnotit v√Ωraz
                            const result = Function(`return ${cleanExpr}`)();
                            const numResult = Number(result);

                            if (!isNaN(numResult)) {
                                this.parameters.set(`R${paramNum}`, numResult);
                                // console.log(`‚úì R${paramNum} = ${numResult} (v√Ωraz: ${expression})`);
                                return numResult;
                            } else {
                                console.warn(`‚úó Neplatn√Ω v√Ωsledek pro R${paramNum}: ${result}`);
                            }
                        } catch (e) {
                            console.warn(`‚úó Chyba p≈ôi vyhodnocen√≠ R${paramNum} = ${expression}:`, e);
                        }
                    }

                    // console.groupEnd();
                    return 0;
                } catch (e) {
                    console.warn('Chyba p≈ôi zpracov√°n√≠ parametr≈Ø:', expression, e);
                    // console.groupEnd();
                    return 0;
                }
            }

            // P≈ôepracovan√° funkce parseCoordinate
            parseCoordinate(value, current) {
                try {
                    let numericalValue;

                    // O≈°et≈ôen√≠ parametrick√Ωch v√Ωraz≈Ø (nap≈ô. X=R28+2.414)
                    if (value.includes('=')) {
                        const expression = value.split('=')[1].trim();

                        // Nahradit R-parametry jejich hodnotami
                        const evaluatedExp = expression.replace(/R(\d+)/g, (match, number) => {
                            const paramValue = this.parameters.get(`R${number}`);
                            // Pokud parametr neexistuje, vr√°tit 0
                            return paramValue !== undefined ? paramValue : '0';
                        });

                        // Bezpeƒçnƒõ vyhodnotit v√Ωraz (nap≈ô. -6.794 + 2.414)
                        const result = Function(`return ${evaluatedExp}`)();
                        numericalValue = Number(result);
                    } else {
                        // Standardn√≠ zpracov√°n√≠ pro p≈ô√≠m√© hodnoty (nap≈ô. X343.15)
                        numericalValue = parseFloat(value);
                    }

                    // Pokud v√Ωsledek nen√≠ ƒç√≠slo, vr√°tit aktu√°ln√≠ pozici beze zmƒõny
                    if (isNaN(numericalValue)) return current;

                    // Zaokrouhlit hodnotu
                    const rounded = Number(numericalValue.toFixed(3));
                    
                    // Aplikovat G90 (absolutn√≠) / G91 (inkrement√°ln√≠) logiku
                    if (this.absoluteMode) {
                        // G90: hodnota je nov√° absolutn√≠ pozice
                        return rounded;
                    } else {
                        // G91: p≈ôiƒç√≠st hodnotu k aktu√°ln√≠ pozici
                        return Number((current + rounded).toFixed(3));
                    }

                } catch (e) {
                    console.warn('Chyba p≈ôi parsov√°n√≠ sou≈ôadnice:', value, e);
                    return current;
                }
            }

            calculateArcPoints(start, end, center, isClockwise, resolution = 50) {
                const startAngle = Math.atan2(start.x - center.x, start.z - center.z);
                const endAngle = Math.atan2(end.x - center.x, end.z - center.z);

                let radius = Math.hypot(start.x - center.x, start.z - center.z);
                let angleStep;
                let points = [];

                // V√Ωpoƒçet √∫hlu v z√°vislosti na smƒõru
                let totalAngle = endAngle - startAngle;
                if (isClockwise) {
                    if (totalAngle >= 0) totalAngle -= 2 * Math.PI;
                } else {
                    if (totalAngle <= 0) totalAngle += 2 * Math.PI;
                }

                angleStep = totalAngle / resolution;

                // Generov√°n√≠ bod≈Ø na oblouku
                for (let i = 0; i <= resolution; i++) {
                    const angle = startAngle + angleStep * i;
                    const x = center.x + radius * Math.sin(angle);
                    const z = center.z + radius * Math.cos(angle);
                    points.push({ x: Number(x.toFixed(3)), z: Number(z.toFixed(3)) });
                }

                return points;
            }

            parseArcMovement(words, movement) {
                let hasCR = false;
                let hasAR = false;
                let arcRadius = 0;

                // Parametry pro Sinumerik 840D
                const params = {
                    CR: null,
                    AR: null,
                    I: null,
                    K: null,
                    I1: null,
                    K1: null,
                    CT: null,
                    TURN: 0
                };

                // Naƒçten√≠ v≈°ech parametr≈Ø
                for (let word of words) {
                    
                    // --- Z√ÅSADN√ç OPRAVA ZDE ---
                    // Zpracov√°n√≠ parametr≈Ø jako CR=R21-8.5
                    if (word.includes('=')) {
                        const [param, expression] = word.split('=');
                        let evaluatedValue;
                        try {
                            // Expandovat R-parametry ve v√Ωrazu (nap≈ô. R21-8.5)
                            const expandedExpr = expression.replace(/R(\d+)/g, (match, num) => {
                                const rVal = this.parameters.get(`R${num}`);
                                return rVal !== undefined ? rVal : '0';
                            });
                            // Bezpeƒçnƒõ vyhodnotit
                            evaluatedValue = Function(`return ${expandedExpr}`)();
                        } catch (e) {
                            console.warn(`Chyba p≈ôi vyhodnocen√≠ parametru ${param}=${expression}`, e);
                            evaluatedValue = NaN;
                        }

                        const numValue = parseFloat(evaluatedValue); // Nyn√≠ parsujeme v√Ωsledek (nap≈ô. 215.5)

                        switch (param.toUpperCase()) {
                            case 'CR':
                                params.CR = Math.abs(numValue);
                                hasCR = true;
                                break;
                            case 'AR': 
                                params.AR = numValue; 
                                break;
                            case 'TURN': 
                                params.TURN = parseInt(numValue); 
                                break;
                        }
                        continue; // Pokraƒçovat na dal≈°√≠ slovo
                    }
                    // --- KONEC OPRAVY ---


                    const command = word[0];
                    const value = parseFloat(word.slice(1));
                    if (isNaN(value)) continue;

                    // D≈Øle≈æit√° zmƒõna: I,K jsou v≈ædy inkrement√°ln√≠ (relativn√≠ k poƒç√°teƒçn√≠mu bodu)
                    switch (command) {
                        case 'I':
                            // I je v≈ædy relativn√≠ k poƒç√°teƒçn√≠mu bodu
                            params.I = movement.fromX + value;
                            break;
                        case 'K':
                            // K je v≈ædy relativn√≠ k poƒç√°teƒçn√≠mu bodu
                            params.K = movement.fromZ + value;
                            break;
                        case 'I1':
                            // I1 je tak√© relativn√≠
                            params.I1 = movement.fromX + value;
                            break;
                        case 'K1':
                            // K1 je tak√© relativn√≠
                            params.K1 = movement.fromZ + value;
                            break;
                    }
                }

                const startPoint = { x: movement.fromX, z: movement.fromZ };
                const endPoint = { x: movement.toX, z: movement.toZ };
                let centerPoint = { x: 0, z: 0 };

                // Urƒçen√≠ st≈ôedu oblouku podle priority parametr≈Ø
                if (params.I !== null && params.K !== null) {
                    // St≈ôed je nyn√≠ v≈ædy relativn√≠ k poƒç√°teƒçn√≠mu bodu
                    centerPoint = { x: params.I, z: params.K };
                } else if (params.I1 !== null && params.K1 !== null) {
                    centerPoint = { x: params.I1, z: params.K1 };
                } else if (hasCR) {
                    // Kontrola, zda m√°me platn√© ƒç√≠slo
                    if (isNaN(params.CR)) {
                         console.error('Chybn√° hodnota CR, oblouk nelze vypoƒç√≠tat.', words);
                         return { points: [], center: null };
                    }
                    
                    // V√Ωpoƒçet st≈ôedu pomoc√≠ polomƒõru CR
                    const chord = Math.hypot(endPoint.x - startPoint.x, endPoint.z - startPoint.z);
                    if (params.CR < chord / 2) {
                        console.warn('CR je p≈ô√≠li≈° mal√Ω, pou≈æije se minim√°ln√≠ mo≈æn√Ω polomƒõr');
                        params.CR = chord / 2;
                    }

                    // V√Ωpoƒçet st≈ôed≈Ø - existuj√≠ dva mo≈æn√© st≈ôedy
                    const h = Math.sqrt(params.CR * params.CR - (chord * chord / 4));
                    const midX = (startPoint.x + endPoint.x) / 2;
                    const midZ = (startPoint.z + endPoint.z) / 2;

                    // Smƒõrov√Ω vektor kolm√Ω na tƒõtivu
                    const dirX = (startPoint.z - endPoint.z) / chord;
                    const dirZ = (endPoint.x - startPoint.x) / chord;

                    // Vypoƒç√≠tat oba mo≈æn√© st≈ôedy
                    const center1 = {
                        x: midX + h * dirX,
                        z: midZ + h * dirZ
                    };

                    const center2 = {
                        x: midX - h * dirX,
                        z: midZ - h * dirZ
                    };

                    // Vypoƒç√≠tat √∫hly pro oba st≈ôedy
                    const angle1 = this.calculateTotalAngle(startPoint, endPoint, center1, movement.type === 'G2');
                    const angle2 = this.calculateTotalAngle(startPoint, endPoint, center2, movement.type === 'G2');

                    // Vybrat st≈ôed, kter√Ω d√°v√° men≈°√≠ √∫hel (men≈°√≠ oblouk)
                    centerPoint = Math.abs(angle1) <= Math.abs(angle2) ? center1 : center2;

                    // console.log('V√Ωpoƒçet oblouku:', {
                    //     type: movement.type,
                    //     radius: params.CR,
                    //     chord: chord,
                    //     height: h,
                    //     angles: {
                    //         center1: angle1 * 180 / Math.PI,
                    //         center2: angle2 * 180 / Math.PI
                    //     },
                    //     selectedCenter: Math.abs(angle1) <= Math.abs(angle2) ? 'center1' : 'center2'
                    // });
                }

                // V√Ωpoƒçet bod≈Ø na oblouku
                const radius = Math.hypot(startPoint.x - centerPoint.x, startPoint.z - centerPoint.z);
                const startAngle = Math.atan2(startPoint.x - centerPoint.x, startPoint.z - centerPoint.z);
                let endAngle = Math.atan2(endPoint.x - centerPoint.x, endPoint.z - centerPoint.z);

                // Upravit √∫hel podle smƒõru a poƒçtu ot√°ƒçek
                if (movement.type === 'G2') { // CW
                    if (endAngle >= startAngle) endAngle -= 2 * Math.PI;
                    endAngle -= 2 * Math.PI * (params.TURN || 0);
                } else { // CCW (G3)
                    if (endAngle <= startAngle) endAngle += 2 * Math.PI;
                    endAngle += 2 * Math.PI * (params.TURN || 0);
                }

                // Vygenerovat body oblouku
                const points = [];
                const steps = Math.max(50, Math.abs(endAngle - startAngle) * 20);
                const angleStep = (endAngle - startAngle) / steps;

                for (let i = 0; i <= steps; i++) {
                    const angle = startAngle + angleStep * i;
                    const x = centerPoint.x + radius * Math.sin(angle);
                    const z = centerPoint.z + radius * Math.cos(angle);
                    points.push({
                        x: Number(x.toFixed(3)),
                        z: Number(z.toFixed(3))
                    });
                }

                return {
                    points: points,
                    center: centerPoint // Vr√°tit i st≈ôed oblouku
                };
            }

            calculateTotalAngle(start, end, center, isClockwise) {
                const startAngle = Math.atan2(start.x - center.x, start.z - center.z);
                let endAngle = Math.atan2(end.x - center.x, end.z - center.z);
                let totalAngle = endAngle - startAngle;

                // Upravit √∫hel podle smƒõru
                if (isClockwise) {
                    if (totalAngle > 0) totalAngle -= 2 * Math.PI;
                } else {
                    if (totalAngle < 0) totalAngle += 2 * Math.PI;
                }

                return totalAngle;
            }

            async parseLine(line) {
                // Kontrola vol√°n√≠ podprogramu
                const lMatch = line.trim().match(/L(\d+)/i);
                if (lMatch) {
                    const subprogramNumber = parseInt(lMatch[1]);
                    await this.processSubprogramParameters(subprogramNumber);
                    return null; // P≈ôeskoƒçit tento ≈ô√°dek v hlavn√≠m zpracov√°n√≠
                }

                // Nejprve vyƒçistit ≈ô√°dek a p≈ôidat mezery mezi G-k√≥dy a sou≈ôadnice
                const cleanedLine = line.trim()
                    .toUpperCase()
                    .replace(/G0(?=[XZ])/g, 'G0 ')  // P≈ôidat mezeru po G0 p≈ôed X nebo Z
                    .replace(/G1(?=[XZ])/g, 'G1 ')  // P≈ôidat mezeru po G1 p≈ôed X nebo Z
                    .replace(/G91(?=[XZ])/g, 'G91 ') // P≈ôidat mezeru po G91 p≈ôed X nebo Z
                    .replace(/G90(?=[XZ])/g, 'G90 '); // P≈ôidat mezeru po G90 p≈ôed X nebo Z

                // P≈ôidat zpracov√°n√≠ p≈ôi≈ôazen√≠ R-parametr≈Ø
                if (cleanedLine.includes('=')) {
                    // Zpracovat V≈†ECHNY parametry na ≈ô√°dku, nejen prvn√≠
                    const parts = cleanedLine.split(/\s+/);
                    let hasParameterAssignment = false;
                    for (const part of parts) {
                         if (part.match(/R(\d+)\s*=\s*(.+)/) && !part.startsWith('CR=')) { // Zajistit, ≈æe nebereme CR=
                             this.evaluateParameters(part);
                             hasParameterAssignment = true;
                         }
                    }
                    // Pokud ≈ô√°dek obsahoval POUZE p≈ôi≈ôazen√≠, vr√°tit null
                    // Pokud obsahoval i pohyb, pokraƒçovat
                    if (hasParameterAssignment && !parts.some(p => p.startsWith('X') || p.startsWith('Z') || p.startsWith('G'))) {
                         return null;
                    }
                }

                const words = cleanedLine.split(/\s+/);
                if (words.length === 0) return null;

                // console.group(`Parsov√°n√≠ ≈ô√°dku: ${line}`);

                // --- OPRAVA MOD√ÅLN√çHO STAVU ---
                const movement = {
                    fromX: this.currentX,
                    fromZ: this.currentZ,
                    toX: this.currentX, // V√Ωchoz√≠ hodnota je aktu√°ln√≠ pozice
                    toZ: this.currentZ, // V√Ωchoz√≠ hodnota je aktu√°ln√≠ pozice
                    rapid: this.modalMotionCommand === 'G0', // rapid se ≈ô√≠d√≠ POUZE mod√°ln√≠m p≈ô√≠kazem
                    center: null,
                    arcPoints: null,
                    // Nastavit v√Ωchoz√≠ typ a isArc podle MOD√ÅLN√çHO stavu
                    isArc: (this.modalMotionCommand === 'G2' || this.modalMotionCommand === 'G3'),
                    type: this.modalMotionCommand 
                };
                // --- KONEC OPRAVY ---

                let hasMove = false;
                let hasGCommand = false; // Sledovat, zda byl na ≈ô√°ku G p≈ô√≠kaz
                let nextX = this.currentX; // Doƒçasn√° promƒõnn√° pro X
                let nextZ = this.currentZ; // Doƒçasn√° promƒõnn√° pro Z

                for (let word of words) {
                    if (!word) continue;

                    // Ignorovat parametry oblouku, ty se zpracuj√≠ v parseArcMovement
                    if (word.startsWith('CR=') || word.startsWith('AR=') || word.startsWith('TURN=')) {
                        continue;
                    }
                    if (word.startsWith('I') || word.startsWith('K')) {
                         if (!word.startsWith('I1') && !word.startsWith('K1')) { // Ponechat I1/K1 pokud by byly
                            continue;
                         }
                    }


                    const command = word[0];
                    let value = word.slice(1);

                    // Upravit zpracov√°n√≠ pro sou≈ôadnice obsahuj√≠c√≠ =
                    if (command === 'X' || command === 'Z') {
                        if (value.includes('=')) {
                            value = '=' + value.split('=')[1];  // Zachovat = pro matematick√Ω v√Ωraz
                        }
                    }

                    switch (command) {
                        case 'G':
                            hasGCommand = true;
                            const gValue = parseInt(value);
                            // --- OPRAVA MOD√ÅLN√çHO STAVU ---
                            switch (gValue) {
                                case 0:
                                    // this.rapidMode = true; // ZRU≈†ENO
                                    movement.rapid = true;
                                    this.modalMotionCommand = 'G0'; // Ulo≈æit mod√°ln√≠ stav
                                    movement.type = 'G0';
                                    movement.isArc = false; // G0 nen√≠ oblouk
                                    // console.log('‚úì Nastaven rychloposuv (G0)');
                                    break;
                                case 1:
                                    // this.rapidMode = false; // ZRU≈†ENO
                                    movement.rapid = false;
                                    this.modalMotionCommand = 'G1'; // Ulo≈æit mod√°ln√≠ stav
                                    movement.type = 'G1';
                                    movement.isArc = false; // G1 nen√≠ oblouk
                                    // console.log('‚úì Nastaven pracovn√≠ posuv (G1)');
                                    break;
                                case 90:
                                    this.absoluteMode = true;
                                    // console.log('‚úì Nastaveno absolutn√≠ programov√°n√≠ (G90)');
                                    break;
                                case 91:
                                    this.absoluteMode = false;
                                    // console.log('‚úì Nastaveno p≈ô√≠r≈Østkov√© programov√°n√≠ (G91)');
                                    break;
                                case 2:
                                    // this.rapidMode = false; // ZRU≈†ENO
                                    movement.rapid = false;
                                    this.modalMotionCommand = 'G2'; // Ulo≈æit mod√°ln√≠ stav
                                    movement.type = 'G2'; // CW
                                    movement.isArc = true;
                                    // console.log('‚úì Nastaven oblouk ve smƒõru hodin (G2)');
                                    break;
                                case 3:
                                    // this.rapidMode = false; // ZRU≈†ENO
                                    movement.rapid = false;
                                    this.modalMotionCommand = 'G3'; // Ulo≈æit mod√°ln√≠ stav
                                    movement.type = 'G3'; // CCW
                                    movement.isArc = true;
                                    // console.log('‚úì Nastaven oblouk proti smƒõru hodin (G3)');
                                    break;
                            }
                            // --- KONEC OPRAVY ---
                            break;
                        case 'X':
                            // Vypoƒç√≠tat novou pozici, ale zat√≠m neukl√°dat do this.currentX
                            nextX = this.parseCoordinate(value, this.currentX);
                            hasMove = true;
                            // console.log(`‚ûú X pozice: ${nextX}`);
                            break;
                        case 'Z':
                            // Vypoƒç√≠tat novou pozici, ale zat√≠m neukl√°dat do this.currentZ
                            nextZ = this.parseCoordinate(value, this.currentZ);
                            hasMove = true;
                            // console.log(`‚ûú Z pozice: ${nextZ}`);
                            break;
                    }
                }

                // A≈æ po zpracov√°n√≠ cel√©ho ≈ô√°dku ulo≈æit nov√© pozice
                if(hasMove) {
                    movement.toX = nextX;
                    movement.toZ = nextZ;
                    this.currentX = nextX;
                    this.currentZ = nextZ;
                }


                // --- OPRAVA CHYBƒöJ√çC√çCH OBLOUK≈Æ ---
                // Pokud je CR parametr a nen√≠ G p≈ô√≠kaz
                if (!hasGCommand && words.some(w => w.startsWith('CR='))) {
                    movement.isArc = true; // Vynutit oblouk
                    movement.type = this.modalMotionCommand; // Pou≈æ√≠t posledn√≠ mod√°ln√≠ G (m≈Ø≈æe b√Ωt G0/G1/G2/G3)
                    movement.rapid = false; // Oblouk NIKDY nen√≠ rapid
                    // console.log(`‚úì Implicitn√≠ oblouk (CR=), pou≈æit mod√°ln√≠ p≈ô√≠kaz (${this.modalMotionCommand})`);
                }

                // Po zpracov√°n√≠ v≈°ech sou≈ôadnic zpracovat oblouk
                if (hasMove && movement.isArc) { 
                    if (movement.type === 'G0' || movement.type === 'G1') {
                        console.warn('CR=... byl vol√°n s aktivn√≠m G0/G1. Chyb√≠ G2/G3. Pou≈æije se G3 (default).');
                        movement.type = 'G3'; // Defaultnƒõ CCW
                        this.modalMotionCommand = 'G3'; // A opravit i mod√°ln√≠ stav!
                    }
                    const arcResult = this.parseArcMovement(words, movement);
                    movement.arcPoints = arcResult.points;
                    movement.center = arcResult.center; // Ulo≈æit st≈ôed do pohybu
                }
                // --- KONEC OPRAVY ---


                // P≈ôidat koncov√© body do pamƒõti
                if (hasMove) {
                    // Pro oblouk p≈ôidat v≈°echny body vƒçetnƒõ koncov√©ho
                    if (movement.arcPoints && movement.arcPoints.length > 0) {
                        movement.points = [...movement.arcPoints];
                    } else {
                        // Pro p≈ô√≠m√Ω pohyb p≈ôidat koncov√Ω bod
                        movement.points = [{
                            x: movement.toX,
                            z: movement.toZ
                        }];
                    }
                }

                // if (hasMove) {
                //     console.log(`‚Æï Pohyb: X${movement.toX} Z${movement.toZ} ${movement.rapid ? '(rapid)' : '(work)'}`);
                // }

                // console.groupEnd();
                return hasMove ? movement : null;
            }

            async parseProgram(program) {
                this.reset();
                const lines = program.split('\n');
                const movements = [];

                // Nejprve proj√≠t program a naƒç√≠st v≈°echny podprogramy
                for (const line of lines) {
                    const lMatch = line.trim().match(/L(\d+)/i);
                    if (lMatch) {
                        const subprogramNumber = parseInt(lMatch[1]);
                        await this.processSubprogramParameters(subprogramNumber);
                    }
                }

                // Resetovat pozici a m√≥dy p≈ôed parsov√°n√≠m pohyb≈Ø
                this.currentX = 0;
                this.currentZ = 0;
                this.absoluteMode = true; // Sinumerik default je G90
                // this.rapidMode = true; // ZRU≈†ENO
                this.modalMotionCommand = 'G0'; // V√Ωchoz√≠ je G0 (rapid)

                // Pak zpracovat pohyby
                for (const line of lines) {
                    if (line.trim() === '' || line.trim().startsWith(';')) continue;
                    
                    // Zpracovat ≈ô√°dek (m≈Ø≈æe aktualizovat parametry nebo vr√°tit pohyb)
                    const movement = await this.parseLine(line);
                    
                    if (movement) {
                        movements.push(movement);
                    }
                }

                debug(`Celkem pohyb≈Ø: ${movements.length}`);
                return movements;
            }

            // P≈ôidat metodu pro nastaven√≠ z√°kladn√≠ho adres√°≈ôe
            setBaseDirectory(path) {
                // Odstranit p≈ô√≠padn√© uvozovky a upravit cestu
                this.baseDirectory = path.replace(/["']/g, '').trim();
                console.log(`Nastavena cesta k podprogram≈Øm: ${this.baseDirectory}`);
            }

            // P≈ôidat metodu pro naƒçten√≠ podprogramu
            async loadSubprogram(number) {
                const baseName = `L${number}`;
                const filename = `${baseName}.SPF`;

                // 1. Nejprve zkusit naj√≠t v ji≈æ naƒçten√Ωch programech
                const foundProgram = Array.from(this.loadedPrograms.values())
                    .find(prog => prog.file.name.toUpperCase().startsWith(baseName));
                if (foundProgram) {
                    return foundProgram.content;
                }

                // 2. Pokud nen√≠ v naƒçten√Ωch programech, zkusit cache
                if (this.loadedSubprograms.has(baseName)) {
                    return this.loadedSubprograms.get(baseName);
                }

                // 3. Pokud nen√≠ ani v cache, zkusit naj√≠t v seznamu soubor≈Ø
                const file = this.subprogramFiles.get(baseName);
                if (!file) {
                    console.warn(`Podprogram ${baseName} nenalezen v naƒçten√Ωch souborech`);
                    return null;
                }

                try {
                    const content = await this.readFile(file);
                    this.loadedSubprograms.set(baseName, content);
                    return content;
                } catch (error) {
                    console.warn(`Nelze naƒç√≠st podprogram ${filename}:`, error);
                    return null;
                }
            }

            // Pomocn√° metoda pro ƒçten√≠ souboru
            readFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = (e) => reject(e);
                    reader.readAsText(file);
                });
            }

            // P≈ôidat metodu pro naƒçten√≠ podprogram≈Ø ze slo≈æky
            async loadSubprogramDirectory(fileList) {
                this.subprogramFiles.clear();
                for (let file of fileList) {
                    if (file.name.toUpperCase().endsWith('.SPF')) {
                        // Ukl√°dat bez p≈ô√≠pony .SPF
                        const baseName = file.name.toUpperCase().replace(/\.SPF$/, '');
                        this.subprogramFiles.set(baseName, file);
                    }
                }
                console.log('Naƒçten√© podprogramy:', Array.from(this.subprogramFiles.keys()));
            }

            // Upraven√° metoda pro zpracov√°n√≠ parametr≈Ø z podprogramu
            async processSubprogramParameters(subprogramNumber) {
                const content = await this.loadSubprogram(subprogramNumber);
                if (!content) return;

                // Zpracovat ≈ô√°dky podprogramu a naj√≠t definice parametr≈Ø
                const lines = content.split('\n');
                for (const line of lines) {
                    const trimmedLine = line.trim().toUpperCase();

                    // Kontrola zda ≈ô√°dek obsahuje R-parametry
                    if (trimmedLine.includes('R') && trimmedLine.includes('=')) {
                        // Nejprve odstranit koment√°≈ôe (pouze st≈ôedn√≠k)
                        const lineWithoutComments = trimmedLine.split(';')[0].trim();

                        // Odstranit ƒç√≠slo bloku na zaƒç√°tku (nap≈ô. N85)
                        const cleanLine = lineWithoutComments.replace(/^N\d+\s*/, '');

                        // Rozdƒõlit ≈ô√°dek podle mezer, abychom dostali jednotliv√° p≈ôi≈ôazen√≠
                        const parts = cleanLine.split(/\s+/);
                        
                        // Zpracovat v≈°echna nalezen√° p≈ôi≈ôazen√≠
                        for (const part of parts) {
                            // Hledat p≈ôi≈ôazen√≠ R_cislo = vyraz
                            const match = part.match(/R(\d+)\s*=\s*(.+)/);
                            if (match) {
                                const [, paramNum, expression] = match;
                                try {
                                    // Vyƒçistit v√Ωraz (nap≈ô. odstranit z√°vorky kolem)
                                    let cleanExpr = expression.replace(/^\(|\)$/g, '');

                                    // Expandovat p≈ô√≠padn√© R-parametry ve v√Ωrazu (R04=R03+1)
                                    const expandedExpr = cleanExpr.replace(/R(\d+)/g, (match, num) => {
                                        const value = this.parameters.get(`R${num}`);
                                        return value !== undefined ? value : '0';
                                    });

                                    // Vyhodnotit v√Ωraz (nap≈ô. '165/2' nebo '378.2+0.8')
                                    const result = Function(`return ${expandedExpr}`)();
                                    const numResult = Number(result);

                                    if (!isNaN(numResult)) {
                                        this.parameters.set(`R${paramNum}`, numResult);
                                        // console.log(`‚úì Podprogram L${subprogramNumber}: R${paramNum} = ${numResult} (z ${part})`);
                                    }
                                } catch (e) {
                                    console.warn(`‚úó Chyba p≈ôi zpracov√°n√≠ parametru '${part}' v L${subprogramNumber}:`, e);
                                }
                            }
                        }
                    }
                }
            }


            // P≈ôidat metodu pro naƒçten√≠ programu
            async loadProgram(file) {
                try {
                    const content = await this.readFile(file);
                    // Ulo≈æit do obou map pro snadn√© hled√°n√≠
                    const upperName = file.name.toUpperCase();
                    this.loadedPrograms.set(file.name, {
                        content: content,
                        file: file
                    });
                    // Pokud jde o .SPF soubor, ulo≈æit i do mapy podprogram≈Ø
                    if (upperName.endsWith('.SPF')) {
                        const baseName = upperName.replace(/\.SPF$/, '');
                        this.subprogramFiles.set(baseName, file);
                    }
                    return content;
                } catch (error) {
                    console.warn(`Nelze naƒç√≠st program ${file.name}:`, error);
                    return null;
                }
            }

            // P≈ôidat metodu pro z√≠sk√°n√≠ naƒçten√©ho programu
            getProgram(name) {
                return this.loadedPrograms.get(name)?.content || null;
            }

            // P≈ôidat metodu pro z√≠sk√°n√≠ seznamu program≈Ø
            getProgramList() {
                return Array.from(this.loadedPrograms.keys());
            }

            // Upravit metodu findLineByPoint pro lep≈°√≠ detekci
            async findLineByPoint(targetX, targetZ) {
                const lines = editor.value.split('\n');
                // Vytvo≈ôit doƒçasn√Ω parser pro sledov√°n√≠ stavu
                const tempParser = new CNCParser();
                // P≈ôen√©st aktu√°ln√≠ parametry
                tempParser.parameters = new Map(this.parameters);
                
                const tolerance = 0.001;

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    
                    // Pou≈æ√≠t parseLine k simulaci stavu (G90/G91, R-parametry, pozice)
                    // parseLine aktualizuje vnit≈ôn√≠ stav tempParseru (currentX, currentZ, absoluteMode)
                    await tempParser.parseLine(line);

                    // Kontrola shody s c√≠lov√Ωm bodem
                    if (Math.abs(tempParser.currentX - targetX) < tolerance &&
                        Math.abs(tempParser.currentZ - targetZ) < tolerance) {
                        return i;
                    }
                }
                return -1;
            }

            // parseCoordinates je nyn√≠ zastaral√° a nahrazena logikou v parseLine
            async parseCoordinates(line) {
                 const result = {
                    hasCoordinates: false,
                    x: 0,
                    z: 0,
                    isAbsolute: this.absoluteMode
                };
            
                if (!line || line.trim().startsWith(';')) {
                    return result;
                }
            
                try {
                    const cleanLine = line.trim().toUpperCase();
            
                    // Aktualizovat G90/G91 m√≥d
                    if (cleanLine.includes('G90')) {
                        this.absoluteMode = true;
                        result.isAbsolute = true;
                    }
                    if (cleanLine.includes('G91')) {
                        this.absoluteMode = false;
                        result.isAbsolute = false;
                    }

                    // Vytvo≈ôit doƒçasn√© promƒõnn√©
                    let nextX = this.currentX;
                    let nextZ = this.currentZ;
                    let hasMove = false;
            
                    // Zpracovat sou≈ôadnice
                    const xMatch = cleanLine.match(/X([=\-]?\d*\.?\d+(?:[\+\-\*\/]R\d+)?(?:[\+\-\*\/]\d+\.?\d+)*)/);
                    const zMatch = cleanLine.match(/Z([=\-]?\d*\.?\d+(?:[\+\-\*\/]R\d+)?(?:[\+\-\*\/]\d+\.?\d+)*)/);

                    if (xMatch) {
                        let xVal = xMatch[1];
                        if (!xVal.includes('=')) xVal = xVal.replace(/^[=]/, '');
                        nextX = this.parseCoordinate(xVal, this.currentX);
                        hasMove = true;
                    }
                    
                    if (zMatch) {
                        let zVal = zMatch[1];
                         if (!zVal.includes('=')) zVal = zVal.replace(/^[=]/, '');
                        nextZ = this.parseCoordinate(zVal, this.currentZ);
                        hasMove = true;
                    }

                    if (hasMove) {
                         result.hasCoordinates = true;
                         result.x = nextX;
                         result.z = nextZ;
                         // Aktualizovat aktu√°ln√≠ pozici
                         this.currentX = nextX;
                         this.currentZ = nextZ;
                    }
                } catch (e) {
                    console.warn('Chyba p≈ôi parsov√°n√≠ sou≈ôadnic:', e);
                }
            
                return result;
            }
        }

        class Simulator {
            constructor() {
                // Nejd≈ô√≠v zkontrolovat existenci canvas elementu
                this.canvas = document.getElementById('simulatorCanvas');
                if (!this.canvas) {
                    throw new Error('Canvas element nenalezen');
                }

                this.ctx = this.canvas.getContext('2d');
                this.parser = new CNCParser();

                // Inicializace z√°kladn√≠ch vlastnost√≠
                this.setupBasicProperties();

                // Vytvo≈ôit event handler metody
                this.setupEventHandlers();

                // Vytvo≈ôit bound metody
                this.createBoundMethods();

                // Nastavit event listenery
                this.setupEventListeners();
                this.setupTooltip();

                // Inicializovat zobrazen√≠
                this.setupCanvas();
                window.addEventListener('resize', () => this.setupCanvas());

                debug('Simul√°tor inicializov√°n');
            }

            setupEventHandlers() {
                // Definovat v≈°echny event handler metody
                this.handleMouseMove = (event) => {
                    if (!this.isDragging) {
                        this.checkPointUnderCrosshair(event.clientX, event.clientY);
                    }
                };

                this.handleZoom = (event) => {
                    event.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = event.clientX - rect.left;
                    const mouseY = event.clientY - rect.top;
                    const worldX = (mouseX - this.centerX) / (this.baseScale * this.zoomFactor);
                    const worldY = (this.centerY - mouseY) / (this.baseScale * this.zoomFactor);

                    if (event.deltaY < 0) {
                        this.zoomFactor = Math.min(this.zoomFactor * 1.1, 1000);
                    } else {
                        this.zoomFactor = Math.max(this.zoomFactor * 0.9, 0.1);
                    }

                    this.scale = this.baseScale * this.zoomFactor;
                    this.centerX = mouseX - worldX * this.scale;
                    this.centerY = mouseY + worldY * this.scale;
                    this.gridCache = this.createGridCache();
                    this.simulate(false);
                };

                // Ostatn√≠ event handlery
                this.startDrag = this.startDrag.bind(this);
                this.drag = this.drag.bind(this);
                this.stopDrag = this.stopDrag.bind(this);
                this.handleTouchStart = this.handleTouchStart.bind(this);
                this.handleTouchMove = this.handleTouchMove.bind(this);
                this.handleTouchEnd = this.handleTouchEnd.bind(this);
                this.handleCanvasClick = this.handleCanvasClick.bind(this);
            }

            createBoundMethods() {
                // Vytvo≈ôit v√°zan√© metody z event handler≈Ø
                this.boundHandleZoom = this.handleZoom.bind(this);
                this.boundHandleMouseMove = this.handleMouseMove.bind(this);
                this.boundStartDrag = this.startDrag;
                this.boundDrag = this.drag;
                this.boundStopDrag = this.stopDrag;
                this.boundHandleTouchStart = this.handleTouchStart;
                this.boundHandleTouchMove = this.handleTouchMove;
                this.boundHandleTouchEnd = this.handleTouchEnd;
                this.boundHandleCanvasClick = this.handleCanvasClick;
            }

            setupBasicProperties() {
                this.gridCache = null;
                this.lastUpdate = 0;
                this.updateThreshold = 50;
                this.minScale = 0.1;
                this.padding = 50;
                this.maxScale = 10;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                this.isDragging = false;
                this.baseScale = 1;
                this.zoomFactor = 1;
                this.viewPosition = { x: 0, y: 0 };
                this.programBounds = null;
                this.originX = 0;
                this.originY = 0;
                this.points = [];
                this.lastSelectedPoint = null;
                this.highlightedPoint = null;
                this.pulseAnimation = null;
            }

            setupEventListeners() {
                // Pou≈æ√≠t p≈ôedem vytvo≈ôen√© bound metody
                this.canvas.addEventListener('wheel', this.boundHandleZoom);
                this.canvas.addEventListener('mousedown', this.boundStartDrag);
                this.canvas.addEventListener('mousemove', this.boundDrag);
                this.canvas.addEventListener('mouseup', this.boundStopDrag);
                this.canvas.addEventListener('mouseleave', this.boundStopDrag);
                this.canvas.addEventListener('click', this.boundHandleCanvasClick);

                // Touch events
                this.canvas.addEventListener('touchstart', this.boundHandleTouchStart, { passive: false });
                this.canvas.addEventListener('touchmove', this.boundHandleTouchMove, { passive: false });
                this.canvas.addEventListener('touchend', this.boundHandleTouchEnd);
            }

            setupTooltip() {
                this.tooltip = document.createElement('div');
                this.tooltip.className = 'tooltip';
                const container = document.querySelector('.canvas-container');
                if (container) {
                    container.appendChild(this.tooltip);
                    this.tooltip.style.display = 'none';

                    // Pou≈æ√≠t p≈ôedem vytvo≈ôenou bound metodu
                    this.canvas.addEventListener('mousemove', this.boundHandleMouseMove);
                    this.canvas.addEventListener('mouseout', () => this.tooltip.style.display = 'none');

                    // P≈ôidat crosshair
                    this.crosshair = document.createElement('div');
                    this.crosshair.className = 'crosshair';
                    container.appendChild(this.crosshair);
                }
            }

            startDrag(event) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                // Kontrola, zda neklik√°me na bod
                const hitPoint = this.points.find(point => {
                    const dx = mouseX - point.screenX;
                    const dy = mouseY - point.screenY;
                    return Math.sqrt(dx * dx + dy * dy) < 5;
                });

                if (!hitPoint) {
                    this.isDragging = true;
                    this.lastMouseX = event.clientX;
                    this.lastMouseY = event.clientY;
                    this.canvas.style.cursor = 'grabbing';
                }
            }

            drag(event) {
                if (!this.isDragging) return;
                const deltaX = event.clientX - this.lastMouseX;
                const deltaY = event.clientY - this.lastMouseY;

                this.centerX += deltaX;
                this.centerY += deltaY;

                this.lastMouseX = event.clientX;
                this.lastMouseY = event.clientY;

                // P≈ôekreslit m≈ô√≠≈æku p≈ôi ka≈æd√©m posunu
                this.gridCache = this.createGridCache();
                this.simulate();
            }

            stopDrag() {
                // P≈ôidat mal√© zpo≈ædƒõn√≠ pro kontrolu, zda ≈°lo o klik nebo tah
                setTimeout(() => {
                    this.isDragging = false;
                    this.canvas.style.cursor = 'default';
                    // Zajistit p≈ôekreslen√≠ drah
                    if (this.lastMovements) {
                        this.drawPath(this.lastMovements);
                    }
                }, 50);
            }

            handleTouchStart(event) {
                event.preventDefault();

                if (event.touches.length === 2) {
                    // Zoom pomoc√≠ dvou prst≈Ø
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];
                    this.lastTouchDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    this.touchZoomStartScale = this.zoomFactor;
                } else if (event.touches.length === 1) {
                    // Posouv√°n√≠ jedn√≠m prstem
                    const touch = event.touches[0];
                    this.touchStartX = touch.clientX;
                    this.touchStartY = touch.clientY;
                    this.isDragging = true;
                }
            }

            handleTouchMove(event) {
                event.preventDefault();

                if (event.touches.length === 2) {
                    // Zoom
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];
                    const distance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );

                    const scale = distance / this.lastTouchDistance;
                    this.zoomFactor = Math.min(Math.max(this.touchZoomStartScale * scale, 0.1), 1000);
                    this.scale = this.baseScale * this.zoomFactor;

                    // Aktualizovat zobrazen√≠
                    this.gridCache = this.createGridCache();
                    this.simulate(false);
                } else if (event.touches.length === 1 && this.isDragging) { // Opraveno 'and' na '&&'
                    // Posouv√°n√≠
                    const touch = event.touches[0];
                    const deltaX = touch.clientX - this.touchStartX;
                    const deltaY = touch.clientY - this.touchStartY;

                    this.centerX += deltaX;
                    this.centerY += deltaY;

                    this.touchStartX = touch.clientX;
                    this.touchStartY = touch.clientY;

                    // Aktualizovat zobrazen√≠
                    this.gridCache = this.createGridCache();
                    this.simulate();
                }

                // P≈ôidat pr≈Øbƒõ≈æn√© p≈ôekreslov√°n√≠ bƒõhem pohybu
                if (this.lastMovements) {
                    requestAnimationFrame(() => {
                        this.drawPath(this.lastMovements);
                    });
                }
            }

            handleTouchEnd(event) {
                this.isDragging = false;
                this.lastTouchDistance = 0;

                // P≈ôidat vynucen√© p≈ôekreslen√≠ po pu≈°tƒõn√≠
                setTimeout(() => {
                    if (this.lastMovements) {
                        this.drawPath(this.lastMovements);
                    }
                }, 50);
            }

            setupCanvas() {
                // ZMƒöNA: Ujistƒõte se, ≈æe rodiƒçovsk√Ω element m√° rozmƒõry
                const parent = this.canvas.parentElement;
                if (parent.clientWidth === 0 || parent.clientHeight === 0) {
                     // Pokud rodiƒç je≈°tƒõ nem√° rozmƒõry (nap≈ô. p≈ôi startu), zkuste to za chv√≠li znovu
                     setTimeout(() => this.setupCanvas(), 50);
                     return;
                }
                
                this.canvas.width = parent.clientWidth;
                this.canvas.height = parent.clientHeight;
                
                this.centerX = this.canvas.width / 2;
                this.centerY = this.canvas.height / 2;
                
                // P≈ôizp≈Øsoben√≠ poƒç√°teƒçn√≠ho mƒõ≈ô√≠tka
                if (this.baseScale === 1) { // Pouze pokud je≈°tƒõ nebylo nastaveno
                   this.scale = Math.min(this.canvas.width, this.canvas.height) / 200;
                   this.baseScale = this.scale;
                } else {
                   this.scale = this.baseScale * this.zoomFactor;
                }

                this.gridCache = this.createGridCache();
                this.simulate();
            }

            getGridStep() {
                // C√≠lov√° minim√°ln√≠ vzd√°lenost mezi ƒçarami m≈ô√≠≈æky v pixelech
                const minPixelsBetweenLines = 90; // Vynut√≠ mezeru 90px mezi popisky

                // 1. Vypoƒç√≠tat, jak√© "svƒõtov√©" vzd√°lenosti odpov√≠d√° tato pixelov√° vzd√°lenost
                const idealStep = minPixelsBetweenLines / this.scale;

                const steps = [0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000];
                
                // Naj√≠t nejbli≈æ≈°√≠ "pƒõkn√Ω" krok, kter√Ω je VƒöT≈†√ç nebo roven ide√°ln√≠mu kroku
                for (let i = 0; i < steps.length; i++) {
                    if (steps[i] >= idealStep) {
                        return steps[i]; // Vr√°tit prvn√≠ krok, kter√Ω je dostateƒçnƒõ velk√Ω
                    }
                }
                
                return steps[steps.length - 1]; // Fallback na nejvƒõt≈°√≠ krok
            }

            createGridCache() {
                const cacheCanvas = document.createElement('canvas');
                cacheCanvas.width = this.canvas.width;
                cacheCanvas.height = this.canvas.height;
                const ctx = cacheCanvas.getContext('2d');

                // Vykreslen√≠ m≈ô√≠≈æky
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 0.5;
                ctx.fillStyle = '#666';
                ctx.font = '22px Arial'; /* Zvƒõt≈°eno z 11px */
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';

                const gridStep = this.getGridStep(); // Toto je krok pro HLAVN√ç ƒç√°ry (s popiskem)
                const subGridStep = gridStep / 5; // Krok pro VEDLEJ≈†√ç ƒç√°ry
                
                let decimals = 0;
                if (gridStep <= 1) { // Pokud je hlavn√≠ krok 1 a m√©nƒõ, zobrazit desetiny
                    decimals = 1;
                }

                const origin = this.worldToScreen(0, 0);

                // V√Ωpoƒçet rozsahu m≈ô√≠≈æky s rezervou
                const viewportLeft = -this.centerX / this.scale - gridStep;
                const viewportRight = (this.canvas.width - this.centerX) / this.scale + gridStep;
                const viewportTop = (this.centerY) / this.scale + gridStep;
                const viewportBottom = -(this.canvas.height - this.centerY) / this.scale - gridStep;

                // Zaokrouhlen√≠ na nejbli≈æ≈°√≠ n√°sobek subGridStep
                const iStartX = Math.floor(viewportLeft / subGridStep);
                const iEndX = Math.ceil(viewportRight / subGridStep);
                const iStartY = Math.floor(viewportBottom / subGridStep);
                const iEndY = Math.ceil(viewportTop / subGridStep);

                // Vytvo≈ôen√≠ seznamu hlavn√≠ch a vedlej≈°√≠ch ƒçar
                const mainLines = [];
                const subLines = [];

                // Vykreslen√≠ vertik√°ln√≠ch ƒçar (nyn√≠ osa X)
                for (let i = iStartX; i <= iEndX; i++) {
                    const x = i * subGridStep; // Vypoƒç√≠tat ƒçerstvou hodnotu
                    const screenX = this.worldToScreen(x, 0).x;
                    
                    // --- NOV√Å LOGIKA M≈ò√ç≈ΩKY ---
                    const isMainLine = (i % 5) === 0; // Ka≈æd√° p√°t√° ƒç√°ra je hlavn√≠
                    // --- KONEC LOGIKY ---

                    if (isMainLine) {
                        mainLines.push(() => {
                            ctx.strokeStyle = '#aaa';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(screenX, 0);
                            ctx.lineTo(screenX, this.canvas.height);
                            ctx.stroke();
                            // Zmƒõnit popisek z Z na X
                            if (Math.abs(x) > 0.001 || i === 0) { // Zobrazit i X0
                                ctx.fillText(`X${x.toFixed(decimals)}`, screenX + 8, this.canvas.height - 20);
                            }
                        });
                    } else {
                        subLines.push(() => {
                            ctx.strokeStyle = '#ddd';
                            ctx.lineWidth = 0.5;
                            ctx.beginPath();
                            ctx.moveTo(screenX, 0);
                            ctx.lineTo(screenX, this.canvas.height);
                            ctx.stroke();
                        });
                    }
                }

                // Vykreslen√≠ horizont√°ln√≠ch ƒçar (nyn√≠ osa Z)
                for (let i = iStartY; i <= iEndY; i++) {
                    const y = i * subGridStep; // Vypoƒç√≠tat ƒçerstvou hodnotu
                    const screenY = this.worldToScreen(0, y).y;

                    // --- NOV√Å LOGIKA M≈ò√ç≈ΩKY ---
                    const isMainLine = (i % 5) === 0; // Ka≈æd√° p√°t√° ƒç√°ra je hlavn√≠
                    // --- KONEC LOGIKY ---
                    
                    if (isMainLine) {
                        mainLines.push(() => {
                            ctx.strokeStyle = '#aaa';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(0, screenY);
                            ctx.lineTo(this.canvas.width, screenY);
                            ctx.stroke();
                            // Zmƒõnit popisek z X na Z
                            if (Math.abs(y) > 0.001 || i === 0) { // Zobrazit i Z0
                                ctx.fillText(`Z${y.toFixed(decimals)}`, 8, screenY + 8);
                            }
                        });
                    } else {
                        subLines.push(() => {
                            ctx.strokeStyle = '#ddd';
                            ctx.lineWidth = 0.5;
                            ctx.beginPath();
                            ctx.moveTo(0, screenY);
                            ctx.lineTo(this.canvas.width, screenY);
                            ctx.stroke();
                        });
                    }
                }

                // Nejprve vykreslit vedlej≈°√≠ ƒç√°ry
                subLines.forEach(drawFn => drawFn());
                // Pak vykreslit hlavn√≠ ƒç√°ry a popisky
                mainLines.forEach(drawFn => drawFn());

                return cacheCanvas;
            }

            drawAxes() {
                if (this.gridCache) {
                    this.ctx.drawImage(this.gridCache, 0, 0);
                }

                const origin = this.worldToScreen(0, 0);

                // Vykreslen√≠ os
                this.ctx.strokeStyle = '#000';
                this.ctx.lineWidth = 2;

                // X osa (horizont√°ln√≠)
                this.ctx.beginPath();
                this.ctx.moveTo(0, origin.y);
                this.ctx.lineTo(this.canvas.width, origin.y);
                this.ctx.stroke();

                // Z osa (vertik√°ln√≠)
                this.ctx.beginPath();
                this.ctx.moveTo(origin.x, 0);
                this.ctx.lineTo(origin.x, this.canvas.height);
                this.ctx.stroke();

                // Popisky os
                this.ctx.fillStyle = '#000';
                this.ctx.font = 'bold 22px Arial';

                // X na konci horizont√°ln√≠ osy vpravo
                this.ctx.textAlign = 'right';
                this.ctx.textBaseline = 'top';
                this.ctx.fillText('X', this.canvas.width - 10, origin.y + 5);

                // Z na vertik√°ln√≠ ose naho≈ôe
                this.ctx.textAlign = 'left';
                this.ctx.textBaseline = 'top';
                this.ctx.fillText('Z', origin.x + 5, 5);
            }

            drawPath(movements) {
                if (!movements || !Array.isArray(movements) || movements.length === 0) {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.drawAxes();
                    return;
                }

                // Vyƒçistit canvas p≈ôed kreslen√≠m
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawAxes();

                // P≈ôipravit batche pro vykreslen√≠
                let batchRapid = [];
                let batchNormal = [];
                this.points = [];

                // Nejprve sesb√≠rat v≈°echny body a dr√°hy
                for (let move of movements) {
                    const from = this.worldToScreen(move.fromX, move.fromZ);
                    const to = this.worldToScreen(move.toX, move.toZ);

                    if (!move.rapid) {
                        this.points.push({
                            screenX: from.x,
                            screenY: from.y,
                            x: move.fromX,
                            z: move.fromZ,
                            isStart: true
                        });
                    }

                    // --- OPRAVA VYKRESLOV√ÅN√ç OBLOUK≈Æ ---
                    if (move.isArc && move.arcPoints) {
                        // Vykreslit oblouk jedn√≠m tahem (modr√° barva)
                        this.ctx.strokeStyle = '#007bff';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.moveTo(from.x, from.y);

                        for (let point of move.arcPoints) {
                            const screenPoint = this.worldToScreen(point.x, point.z);
                            this.ctx.lineTo(screenPoint.x, screenPoint.y);
                        }
                        this.ctx.stroke(); // Vykreslit oblouk okam≈æitƒõ

                        if (move.center) {
                            const center = this.worldToScreen(move.center.x, move.center.z);
                            this.points.push({
                                screenX: center.x,
                                screenY: center.y,
                                x: move.center.x,
                                z: move.center.z,
                                isCenter: true
                            });
                        }
                    } else {
                        // P≈ôidat rovn√© pohyby do d√°vky
                        if (move.rapid) {
                            batchRapid.push({from, to});
                        } else {
                            batchNormal.push({from, to});
                        }
                    }
                    // --- KONEC OPRAVY ---

                    // P≈ôidat koncov√Ω bod
                    this.points.push({
                        screenX: to.x,
                        screenY: to.y,
                        x: move.toX,
                        z: move.toZ
                    });
                }

                // Vykreslit v≈°echny rychloposuvy najednou
                if (batchRapid.length > 0) {
                    this.ctx.strokeStyle = '#ff0000';
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    for (let move of batchRapid) {
                        this.ctx.moveTo(move.from.x, move.from.y);
                        this.ctx.lineTo(move.to.x, move.to.y);
                    }
                    this.ctx.stroke();
                }

                // Vykreslit v≈°echny pracovn√≠ posuvy (rovn√©) najednou
                if (batchNormal.length > 0) {
                    this.ctx.strokeStyle = '#007bff';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    for (let move of batchNormal) {
                        this.ctx.moveTo(move.from.x, move.from.y);
                        this.ctx.lineTo(move.to.x, move.to.y);
                    }
                    this.ctx.stroke();
                }

                // Vykreslit body
                for (let point of this.points) {
                    this.ctx.fillStyle = point.isCenter ? '#00ff00' : (point.isStart ? '#007bff' : '#007bff');
                    this.ctx.beginPath();
                    this.ctx.arc(point.screenX, point.screenY, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                this.lastMovements = movements;

                // Vykreslen√≠ zv√Ωraznƒõn√©ho bodu na konci
                if (this.highlightedPoint) {
                    this.drawHighlightedPoint();
                }
            }

            drawHighlightedPoint() {
                if (!this.highlightedPoint) return;

                const point = this.worldToScreen(this.highlightedPoint.x, this.highlightedPoint.z);

                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                this.ctx.fillStyle = '#ff0000';
                this.ctx.fill();

                const now = Date.now();
                const phase = (now % 1000) / 1000;
                const radius = 8 + Math.sin(phase * Math.PI * 2) * 4;

                this.ctx.beginPath();
                this.ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
                this.ctx.strokeStyle = '#ff0000';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                this.ctx.restore();

                // Upraveno: requestAnimationFrame by mƒõl volat tuto samou funkci
                if (this.highlightedPoint) { // Kontrola, zda st√°le zv√Ωraz≈àujeme
                    this.animationFrame = requestAnimationFrame(() => this.drawHighlightedPoint());
                }
            }

            calculateBounds(movements) {
                if (!movements || movements.length === 0) return null;
                let minX = Infinity;
                let maxX = -Infinity;
                let minZ = Infinity;
                let maxZ = -Infinity;

                movements.forEach(move => {
                    minX = Math.min(minX, move.fromX, move.toX);
                    maxX = Math.max(maxX, move.fromX, move.toX);
                    minZ = Math.min(minZ, move.fromZ, move.toZ);
                    maxZ = Math.max(maxZ, move.fromZ, move.toZ);
                });

                // P≈ôidat mal√Ω okraj pro pr√°zdn√© programy nebo jednotliv√© body
                if (minX === maxX) {
                    minX -= 5;
                    maxX += 5;
                }
                if (minZ === maxZ) {
                    minZ -= 5;
                    maxZ += 5;
                }

                return { minX, maxX, minZ, maxZ };
            }

            adjustScale(bounds) {
                if (!bounds) return;
                this.programBounds = bounds; // Ulo≈æit hranice programu

                const width = bounds.maxX - bounds.minX;
                const height = bounds.maxZ - bounds.minZ;

                // Vypoƒçet z√°kladn√≠ho mƒõ≈ô√≠tka pouze pokud nem√°me ulo≈æen√© hranice
                if (!this.baseScale || this.baseScale === 1) {
                    const scaleX = (this.canvas.width - this.padding * 2) / (width || 1);
                    const scaleY = (this.canvas.height - this.padding * 2) / (height || 1);
                    this.baseScale = Math.min(scaleX, scaleY);
                }
                this.scale = this.baseScale * this.zoomFactor;

                // Centrovat dr√°hy vzhledem k os√°m p≈ôi resetu
                if (!this.isDragging && !this.programBounds) {
                    const origin = this.worldToScreen(0, 0);
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    this.centerX += centerX - origin.x;
                    this.centerY += centerY - origin.y;
                }
            }

            resetView() {
                const program = editor.value;
                if (!program.trim()) return;

                this.parser.parseProgram(program).then(movements => {
                    if (movements && Array.isArray(movements)) {
                        // Filtrovat pouze pracovn√≠ pohyby (G1, G2, G3)
                        const workMoves = movements.filter(move => !move.rapid);

                        if (workMoves.length > 0) {
                            // Vypoƒç√≠tat hranice pouze pro pracovn√≠ pohyby
                            let bounds = { minX: Infinity, maxX: -Infinity, minZ: Infinity, maxZ: -Infinity };
                            
                            workMoves.forEach(move => {
                                bounds.minX = Math.min(bounds.minX, move.fromX, move.toX);
                                bounds.maxX = Math.max(bounds.maxX, move.fromX, move.toX);
                                bounds.minZ = Math.min(bounds.minZ, move.fromZ, move.toZ);
                                bounds.maxZ = Math.max(bounds.maxZ, move.fromZ, move.toZ);
                                // Zahrnout body oblouku do v√Ωpoƒçtu hranic
                                if (move.isArc && move.arcPoints) {
                                    for (const p of move.arcPoints) {
                                        bounds.minX = Math.min(bounds.minX, p.x);
                                        bounds.maxX = Math.max(bounds.maxX, p.x);
                                        bounds.minZ = Math.min(bounds.minZ, p.z);
                                        bounds.maxZ = Math.max(bounds.maxZ, p.z);
                                    }
                                }
                            });


                            // P≈ôidat okraj 10% pro lep≈°√≠ zobrazen√≠
                            const margin = {
                                x: (bounds.maxX - bounds.minX) * 0.1 || 5, // || 5 pro p≈ô√≠pad jednoho bodu
                                z: (bounds.maxZ - bounds.minZ) * 0.1 || 5
                            };

                            bounds.minX -= margin.x;
                            bounds.maxX += margin.x;
                            bounds.minZ -= margin.z;
                            bounds.maxZ += margin.z;

                            // Vypoƒç√≠tat mƒõ≈ô√≠tko pro p≈ôizp≈Øsoben√≠ pohledu
                            // X je horizont√°ln√≠, Z je vertik√°ln√≠
                            const width = bounds.maxX - bounds.minX;
                            const height = bounds.maxZ - bounds.minZ;

                            const scaleX = (this.canvas.width - this.padding * 2) / (width || 1);
                            const scaleY = (this.canvas.height - this.padding * 2) / (height || 1);
                            
                            // Pou≈æ√≠t men≈°√≠ mƒõ≈ô√≠tko pro zachov√°n√≠ pomƒõru stran
                            this.baseScale = Math.min(scaleX, scaleY);
                            this.zoomFactor = 1;
                            this.scale = this.baseScale;

                            // Vypoƒç√≠tat st≈ôed pro centrov√°n√≠
                            const centerX = (bounds.minX + bounds.maxX) / 2;
                            const centerZ = (bounds.minZ + bounds.maxZ) / 2;

                            // Nastavit pozici pohledu
                            // worldToScreen: x = this.centerX + worldX * this.scale
                            // worldToScreen: y = this.centerY - worldZ * this.scale
                            // Chceme, aby st≈ôed (centerX, centerZ) byl uprost≈ôed (canvas.width/2, canvas.height/2)
                            
                            this.centerX = (this.canvas.width / 2) - (centerX * this.scale);
                            this.centerY = (this.canvas.height / 2) + (centerZ * this.scale);


                            // P≈ôekreslit
                            this.gridCache = this.createGridCache();
                            // this.simulate(true); // TOTO BYLA CHYBA
                            
                            // --- OPRAVA ---
                            // P≈ô√≠mo p≈ôekresl√≠me s nov√Ωm nastaven√≠m a ji≈æ naparsovan√Ωmi pohyby
                            this.drawPath(movements);
                            // --- KONEC OPRAVY ---
                        } else {
                            // Pokud nejsou pracovn√≠ pohyby, zobrazit cel√Ω program
                            const bounds = this.calculateBounds(movements);
                            if (bounds) {
                                // ... (tato logika je teƒè pokryta v√Ω≈°e)
                            }
                        }
                    }
                }).catch(error => {
                    console.error('Chyba p≈ôi parsov√°n√≠ programu:', error);
                });
            }

            worldToScreen(x, z) {
                return {
                    x: this.centerX + x * this.scale,     // X na horizont√°ln√≠ osu
                    y: this.centerY - z * this.scale      // Z na vertik√°ln√≠ osu - opraveno znam√©nko
                };
            }

            async simulate(resetView = false) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                const program = editor.value;

                if (program.trim()) {
                    debug('Spu≈°tƒõn√≠ simulace programu');
                    const movements = await this.parser.parseProgram(program);
                    
                    if (resetView) { // Resetovat pohled P≈òED adjustScale
                        this.lastSelectedPoint = null;
                        selectedPosXElement.textContent = '-';
                        selectedPosZElement.textContent = '-';
                        // Zresetovat i baseScale, aby se p≈ôepoƒç√≠tal
                        this.baseScale = 1; 
                        this.zoomFactor = 1;
                    }

                    const bounds = this.calculateBounds(movements);
                    this.adjustScale(bounds); // P≈ôizp≈Øsobit mƒõ≈ô√≠tko

                    this.drawAxes();
                    this.drawPath(movements);
                    debug('Simulace dokonƒçena');
                } else {
                    this.drawAxes();
                }
            }

            formatNumber(num) {
                // Zaokrouhlit na 3 desetinn√° m√≠sta a p≈ôev√©st na string
                const rounded = Number(num).toFixed(3);
                // Odstranit koncov√© nuly za desetinnou ƒç√°rkou a p≈ô√≠padnƒõ i desetinnou ƒç√°rku
                return rounded.replace(/\.?0+$/, '');
            }

            checkPointUnderCrosshair(x, y) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = x - rect.left;
                const mouseY = y - rect.top;

                const hitPoint = this.points.find(point => {
                    const dx = mouseX - point.screenX;
                    const dy = mouseY - point.screenY;
                    return Math.sqrt(dx * dx + dy * dy) < 15; // Vƒõt≈°√≠ tolerance pro dotyk
                });

                if (hitPoint) {
                    this.tooltip.style.display = 'block';
                    this.tooltip.style.left = (x + 20) + 'px';
                    this.tooltip.style.top = (y - 30) + 'px';
                    this.tooltip.textContent = `X${this.formatNumber(hitPoint.x)} Z${this.formatNumber(hitPoint.z)}`;

                    // Aktualizujeme posledn√≠ vybran√Ω bod a jeho sou≈ôadnice
                    this.lastSelectedPoint = hitPoint;
                    this.updateSelectedPosition(hitPoint.x, hitPoint.z);
                } else {
                    this.tooltip.style.display = 'none';
                }
            }

            updateSelectedPosition(x, z) {
                if (x !== null && z !== null) {
                    // P≈ôev√©st relativn√≠ sou≈ôadnice na absolutn√≠, pokud je pot≈ôeba
                    // Tato logika je zde zjednodu≈°en√°, proto≈æe nezn√°me kontext G90/G91 dan√©ho bodu
                    // Pro p≈ôesnost je lep≈°√≠ spol√©hat na parser
                    selectedPosXElement.textContent = this.formatNumber(x);
                    selectedPosZElement.textContent = this.formatNumber(z);
                }
            }

            highlightPoint(x, z) {
                // Nejprve vyƒçistit p≈ôedchoz√≠ zv√Ωraznƒõn√≠
                this.clearHighlight(true); // true = ƒç√°steƒçn√© p≈ôekreslen√≠

                this.highlightedPoint = { x, z };

                const animate = () => {
                    if (!this.highlightedPoint) return; // Animace byla zru≈°ena
                    
                    // P≈ôekreslit z√°klad
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.drawAxes();
                    if (this.lastMovements) {
                        this.drawPath(this.lastMovements);
                    }
                    
                    if (!this.highlightedPoint) return; // Znovu zkontrolovat pro p≈ô√≠pad, ≈æe se zru≈°ilo bƒõhem kreslen√≠

                    const point = this.worldToScreen(this.highlightedPoint.x, this.highlightedPoint.z);

                    this.ctx.save();

                    // Vykreslen√≠ pevn√©ho bodu
                    this.ctx.beginPath();
                    this.ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                    this.ctx.fillStyle = '#ff0000';
                    this.ctx.fill();

                    // Pulzuj√≠c√≠ kru≈ænice
                    const now = Date.now();
                    const phase = (now % 1000) / 1000;
                    const radius = 8 + Math.sin(phase * Math.PI * 2) * 4;

                    this.ctx.beginPath();
                    this.ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
                    this.ctx.strokeStyle = '#ff0000';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();

                    this.ctx.restore();

                    // Ulo≈æit referenci na animaci
                    this.animationFrame = requestAnimationFrame(animate);
                };

                // Spustit animaci
                animate();
            }

            clearHighlight(partial = false) {
                // Zastavit v≈°echny bƒõ≈æ√≠c√≠ animace
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                }

                this.highlightedPoint = null;

                if (!partial) {
                    // Kompletn√≠ p≈ôekreslen√≠
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.drawAxes();
                    if (this.lastMovements) {
                        this.drawPath(this.lastMovements);
                    }
                }
            }

            async handleCanvasClick(event) {
                if (this.isDragging) return;

                const rect = this.canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                // Vymazat p≈ôedchoz√≠ zv√Ωraznƒõn√≠
                this.clearHighlight();

                const hitPoint = this.points.find(point => {
                    const dx = mouseX - point.screenX;
                    const dy = mouseY - point.screenY;
                    return Math.sqrt(dx * dx + dy * dy) < 8;
                });

                if (hitPoint) {
                    const lineIndex = await this.findLineByCoordinates(hitPoint.x, hitPoint.z);
                    if (lineIndex >= 0) {
                        this.highlightLineAndPoint(lineIndex, hitPoint);
                    }
                }
            }

            highlightLineAndPoint(lineIndex, point) {
                // Nejprve vyƒçistit p≈ôedchoz√≠ zv√Ωraznƒõn√≠

                // Odstranit p≈ôedchoz√≠ ≈°ipky a t≈ô√≠dy
                const lines = editor.value.split('\n');
                const cleanLines = lines.map(line => line.replace(/^‚Üí\s*/, ''));

                // P≈ôidat ≈°ipku k vybran√©mu ≈ô√°dku
                cleanLines[lineIndex] = '‚Üí ' + cleanLines[lineIndex];
                editor.value = cleanLines.join('\n');

                // Aktualizovat zobrazen√© sou≈ôadnice
                selectedPosXElement.textContent = this.formatNumber(point.x);
                selectedPosZElement.textContent = this.formatNumber(point.z);

                // Zv√Ωraznit bod
                this.highlightPoint(point.x, point.z);

                // Scrollovat k vybran√©mu ≈ô√°dku a udr≈æet ho na druh√© pozici
                const lineHeight = parseFloat(getComputedStyle(editor).lineHeight) || 24; // 24 je fallback
                const viewportHeight = editor.clientHeight;
                const targetPosition = lineHeight * (lineIndex - 1);

                // Zajistit, aby oznaƒçen√Ω ≈ô√°dek byl v≈ædy viditeln√Ω a na druh√© pozici
                if (targetPosition < editor.scrollTop ||
                    targetPosition > editor.scrollTop + viewportHeight - lineHeight * 3) {
                    editor.scrollTop = Math.max(0, targetPosition);
                }
            }

            clearAllHighlights() {
                this.highlightedPoint = null;
                // this.highlightedPoints = []; // Nen√≠ definov√°no, ale clearHighlight() dƒõl√°, co je t≈ôeba
                this.clearHighlight();
            }

            async findLineByCoordinates(targetX, targetZ) {
                 // Vytvo≈ôit doƒçasn√Ω parser pro sledov√°n√≠ stavu
                const tempParser = new CNCParser();
                // P≈ôen√©st aktu√°ln√≠ parametry
                tempParser.parameters = new Map(this.parser.parameters);
                
                const program = editor.value;
                const lines = program.split('\n');
                const tolerance = 0.001;

                // Proj√≠t v≈°echny p≈ôedchoz√≠ ≈ô√°dky a spoƒç√≠tat aktu√°ln√≠ pozici
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    if (!line || line.trim().startsWith(';')) continue;

                    // Zpracov√°n√≠ sou≈ôadnic
                    // parseLine vrac√≠ pohyb NEBO null a aktualizuje vnit≈ôn√≠ stav parseru
                    const movement = await tempParser.parseLine(line);

                    if (movement) {
                        // Kontrola shody s hledanou pozic√≠ (s toleranc√≠)
                        if (Math.abs(movement.toX - targetX) < tolerance &&
                            Math.abs(movement.toZ - targetZ) < tolerance) {
                            return i;
                        }
                    }
                }
                return -1;
            }

            async simulateToLine(lineIndex) {
                const program = editor.value;
                const lines = program.split('\n').slice(0, lineIndex + 1).join('\n');
                
                // Pou≈æ√≠t hlavn√≠ parser pro doƒçasnou simulaci
                // Ulo≈æit aktu√°ln√≠ stav
                const savedState = {
                    currentX: this.parser.currentX,
                    currentZ: this.parser.currentZ,
                    absoluteMode: this.parser.absoluteMode,
                    // rapidMode: this.parser.rapidMode, // ZRU≈†ENO
                    modalMotionCommand: this.parser.modalMotionCommand, // P≈ôejmenov√°no
                    parameters: new Map(this.parser.parameters) // D≈Øle≈æit√©: vytvo≈ôit kopii
                };

                // ParseProgram resetuje parser, co≈æ je to, co chceme
                const movements = await this.parser.parseProgram(lines);
                this.drawPath(movements);

                // Obnovit p≈Øvodn√≠ stav parseru, aby dal≈°√≠ vol√°n√≠ navazovala
                this.parser.currentX = savedState.currentX;
                this.parser.currentZ = savedState.currentZ;
                this.parser.absoluteMode = savedState.absoluteMode;
                // this.parser.rapidMode = savedState.rapidMode; // ZRU≈†ENO
                this.parser.modalMotionCommand = savedState.modalMotionCommand; // P≈ôejmenov√°no
                this.parser.parameters = savedState.parameters;
            }
        }

        class CNCPlayer {
            constructor(simulator) {
                // P≈ôidat inicializaci DOM element≈Ø na zaƒç√°tek konstruktoru
                const elements = {
                    posX: document.getElementById('posX'),
                    posZ: document.getElementById('posZ'),
                    playBtn: document.getElementById('playBtn'),
                    prevBtn: document.getElementById('prevBtn'),
                    nextBtn: document.getElementById('nextBtn'),
                    speedSlider: document.getElementById('speedSlider'),
                    currentLine: document.getElementById('currentLine'),
                    totalLines: document.getElementById('totalLines')
                };

                // Kontrola existence element≈Ø
                if (Object.values(elements).some(el => !el)) {
                    console.error('Nƒõkter√© po≈æadovan√© DOM elementy nebyly nalezeny');
                    return;
                }

                // Ulo≈æit reference
                this.elements = elements;

                this.simulator = simulator;
                this.movements = []; // Toto bude pole pohyb≈Ø
                this.lineMovements = []; // Mapov√°n√≠ [index_radku] => [index_pohybu]
                this.currentIndex = -1; // Index aktu√°ln√≠ho *pohybu*
                this.currentLineIndex = -1; // Index aktu√°ln√≠ho *≈ô√°dku* v editoru
                this.isPlaying = false;
                this.playTimer = null;
                this.speed = 50; // V√Ωchoz√≠ rychlost (1-100)

                // Event listeners
                this.elements.playBtn.addEventListener('click', () => this.togglePlay());
                this.elements.prevBtn.addEventListener('click', () => this.prev());
                this.elements.nextBtn.addEventListener('click', () => this.next());
                this.elements.speedSlider.addEventListener('input', (e) => this.setSpeed(e.target.value));

                this.updateControls();
            }

            togglePlay() {
                if (this.isPlaying) {
                    this.pause();
                } else {
                    this.play();
                }
            }

            play() {
                if (this.currentIndex >= this.movements.length - 1) {
                    this.stop(); // Reset na zaƒç√°tek
                }
                this.isPlaying = true;
                this.elements.playBtn.innerHTML = '<span class="button-icon">‚è∏Ô∏è</span>';
                this.elements.playBtn.title = 'Pozastavit';
                this.updateControls();
                this.playNext();
            }

            pause() {
                this.isPlaying = false;
                this.elements.playBtn.innerHTML = '<span class="button-icon">‚ñ∂Ô∏è</span>';
                this.elements.playBtn.title = 'P≈ôehr√°t';
                clearTimeout(this.playTimer);
                this.updateControls();
            }

            prev() {
                if (this.currentIndex > 0) {
                    this.currentIndex--;
                } else {
                    this.currentIndex = -1; // J√≠t na startovn√≠ pozici (p≈ôed prvn√≠ pohyb)
                }
                this.drawToCurrentIndex();
                this.updateControls();
            }

            next() {
                if (this.currentIndex < this.movements.length - 1) {
                    this.currentIndex++;
                    this.drawToCurrentIndex();
                    this.updateControls();
                }
            }
            
            async drawToCurrentIndex() {
                if (this.currentIndex < 0) {
                    // Reset na poƒç√°teƒçn√≠ stav
                    this.simulator.clearAllHighlights();
                    this.simulator.drawPath([]); // Vykreslit pr√°zdnou dr√°hu (jen osy)
                    this.elements.posX.textContent = this.simulator.formatNumber(0);
                    this.elements.posZ.textContent = this.simulator.formatNumber(0);
                    this.highlightEditorLine(-1);
                    this.updateLineSpans(-1);
                    return;
                }
                
                const currentMovements = this.movements.slice(0, this.currentIndex + 1);
                
                if (currentMovements.length > 0) {
                    this.simulator.drawPath(currentMovements);
                    
                    const lastMove = currentMovements[currentMovements.length - 1];
                    this.elements.posX.textContent = this.simulator.formatNumber(lastMove.toX);
                    this.elements.posZ.textContent = this.simulator.formatNumber(lastMove.toZ);
                    
                    // Zv√Ωraznit bod
                    this.simulator.highlightPoint(lastMove.toX, lastMove.toZ);
                    
                    // Naj√≠t a zv√Ωraznit odpov√≠daj√≠c√≠ ≈ô√°dek v editoru
                    const lineIndex = this.lineMovements[this.currentIndex];
                    this.highlightEditorLine(lineIndex);
                    this.updateLineSpans(lineIndex);
                }
            }


            updateControls() {
                // Aktualizace stavu tlaƒç√≠tek
                this.elements.prevBtn.disabled = this.currentIndex < 0 || this.isPlaying;
                this.elements.nextBtn.disabled = this.currentIndex >= this.movements.length - 1 || this.isPlaying;
                this.elements.speedSlider.disabled = this.isPlaying;
            }

            async setProgram(program) {
                this.stop(); // Zastavit p≈ôehr√°v√°n√≠
                
                // Vytvo≈ôit novou instanci parseru POUZE pro p≈ôehr√°vaƒç
                const playerParser = new CNCParser();
                // P≈ôen√©st parametry z hlavn√≠ho parseru (naƒçten√© z L... soubor≈Ø)
                playerParser.parameters = new Map(this.simulator.parser.parameters);

                const lines = program.split('\n');
                this.movements = [];
                this.lineMovements = [];
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    if (line.trim() === '' || line.trim().startsWith(';')) {
                        continue;
                    }

                    // parseLine vr√°t√≠ pohyb A Z√ÅROVE≈á aktualizuje vnit≈ôn√≠ stav parseru
                    const movement = await playerParser.parseLine(line);
                    
                    if (movement) {
                        this.movements.push(movement);
                        // Ulo≈æit mapov√°n√≠: tento pohyb (index) pat≈ô√≠ k tomuto ≈ô√°dku (i)
                        this.lineMovements.push(i);
                    }
                }

                this.elements.totalLines.textContent = lines.length;
                this.updateLineSpans(-1); // Zobrazit 0 na zaƒç√°tku
                
                // Resetovat simul√°tor do v√Ωchoz√≠ho stavu
                this.simulator.clearAllHighlights();
                // Vykreslit celou dr√°hu (ale bez zv√Ωraznƒõn√≠)
                this.simulator.drawPath(this.movements); 
                this.elements.posX.textContent = this.simulator.formatNumber(0);
                this.elements.posZ.textContent = this.simulator.formatNumber(0);
            }

            highlightEditorLine(lineIndex) {
                 const lines = editor.value.split('\n');
                 const cleanLines = lines.map(line => line.replace(/^‚Üí\s*/, ''));
                 
                 // --- OPRAVA CHYBY ---
                 let targetScroll; // Deklarovat promƒõnnou zde
                 const lineHeight = parseFloat(getComputedStyle(editor).lineHeight) || 24; // Deklarovat promƒõnnou zde
                 // --- KONEC OPRAVY ---

                 if (lineIndex >= 0 && lineIndex < cleanLines.length) {
                     cleanLines[lineIndex] = '‚Üí ' + cleanLines[lineIndex];
                     
                     // Scrollovat k oznaƒçen√©mu ≈ô√°dku
                     // const lineHeight = parseFloat(getComputedStyle(editor).lineHeight) || 24; // P≈ôesunuto v√Ω≈°e
                     targetScroll = Math.max(0, (lineIndex - 2) * lineHeight); // P≈ôi≈ôadit hodnotu
                     
                     // Scrollovat pouze pokud je ≈ô√°dek mimo viditelnou oblast
                     if (editor.scrollTop > targetScroll || (editor.scrollTop + editor.clientHeight) < targetScroll + lineHeight * 3) {
                        editor.scrollTop = targetScroll;
                     }
                 }
                 
                 // Optimalizace: Mƒõnit scrollTop a value oddƒõlenƒõ
                 const currentScroll = editor.scrollTop;
                 editor.value = cleanLines.join('\n');
                 editor.scrollTop = currentScroll; // Obnovit pozici scrollu

                 // Znovu nastavit scroll, pokud byl zmƒõnƒõn
                 if (lineIndex >= 0 && (editor.scrollTop > targetScroll || (editor.scrollTop + editor.clientHeight) < targetScroll + lineHeight * 3)) { // Nyn√≠ je 'targetScroll' definov√°no
                     editor.scrollTop = targetScroll;
                 }
                 
                 this.currentLineIndex = lineIndex;
            }
            
            updateLineSpans(lineIndex) {
                 // Zobrazuje index ≈ô√°dku + 1 (aby se ƒç√≠slovalo od 1)
                 this.elements.currentLine.textContent = lineIndex + 1;
            }

            playNext() {
                if (!this.isPlaying || this.currentIndex >= this.movements.length - 1) {
                    this.pause(); // Zastavit na konci
                    return;
                }

                // Posunout na dal≈°√≠ pohyb
                this.currentIndex++;
                
                // Pou≈æ√≠t requestAnimationFrame pro plynulej≈°√≠ animaci
                requestAnimationFrame(async () => {
                    if (!this.isPlaying) return; // Zkontrolovat, zda se mezit√≠m nezm√°ƒçklo pause
                    await this.drawToCurrentIndex(); // Vykreslit stav do aktu√°ln√≠ho indexu
                    this.updateControls();

                    // Napl√°novat dal≈°√≠ frame
                    const delay = this.calculateDelay();
                    this.playTimer = setTimeout(() => this.playNext(), delay);
                });
            }

            calculateDelay() {
                // P≈ôevod rychlosti (1-100) na ƒças (1000ms - 50ms)
                const speedValue = parseInt(this.elements.speedSlider.value);
                return 1000 - (speedValue * 9.5);
            }

            stop() {
                this.pause();
                this.currentIndex = -1;
                this.drawToCurrentIndex(); // Vykresl√≠ pr√°zdn√Ω stav
                this.updateControls();
            }

            setSpeed(value) {
                this.speed = parseInt(value);
            }
        }

        // Event handlers
        window.addEventListener('DOMContentLoaded', () => {
            try {
                // Vytvo≈ôit glob√°ln√≠ simul√°tor a≈æ po naƒçten√≠ DOM
                window.simulator = new Simulator();

                // Inicializovat CNC p≈ôehr√°vaƒç
                window.simulator.player = new CNCPlayer(window.simulator);

                // Nastavit cestu k adres√°≈ôi
                const currentPath = window.location.pathname;
                const baseDirectory = currentPath.substring(0, currentPath.lastIndexOf('/'));
                window.simulator.parser.setBaseDirectory(baseDirectory);

                // Event listener pro v√Ωbƒõr soubor≈Ø
                const fileInput = document.getElementById('actualFileInput');
                const programList = document.getElementById('programList');

                if (fileInput && programList) {
                    fileInput.addEventListener('change', async function(event) {
                        if (!window.simulator || !window.simulator.parser) return;

                        const files = Array.from(this.files);
                        programList.innerHTML = '';
                        window.simulator.parser.loadedPrograms.clear(); // Vyƒçistit star√© programy
                        window.simulator.parser.subprogramFiles.clear(); // Vyƒçistit i cache podprogram≈Ø

                        // Naƒç√≠st v≈°echny soubory
                        for (const file of files) {
                            await window.simulator.parser.loadProgram(file); // T√≠m se napln√≠ i subprogramFiles

                            const item = document.createElement('div');
                            item.className = 'program-list-item';
                            const displayName = file.name.replace(/\.(SPF|MPF)$/i, '');
                            item.textContent = displayName;
                            item.onclick = async () => {
                                programList.querySelectorAll('.program-list-item')
                                    .forEach(i => i.classList.remove('active'));
                                item.classList.add('active');

                                const content = window.simulator.parser.getProgram(file.name);
                                if (content) {
                                    editor.value = content;
                                    await simulateProgram(); // Zavol√° simulate() a player.setProgram()
                                    window.simulator.resetView(); // P≈ôidat automatick√Ω reset pohledu
                                }
                            };
                            programList.appendChild(item);
                        }

                        // Automaticky naƒç√≠st prvn√≠ program (obvykle .MPF)
                        let firstProgramFile = files.find(f => f.name.toUpperCase().endsWith('.MPF')) || files[0];
                        
                        if (firstProgramFile) {
                            const content = window.simulator.parser.getProgram(firstProgramFile.name);
                            if (content) {
                                editor.value = content;
                                // Naj√≠t odpov√≠daj√≠c√≠ tlaƒç√≠tko v seznamu a oznaƒçit ho
                                const firstItem = Array.from(programList.children).find(child => child.textContent === firstProgramFile.name.replace(/\.(SPF|MPF)$/i, ''));
                                firstItem?.classList.add('active');
                                
                                await simulateProgram(); // Zavol√° simulate() a player.setProgram()
                                window.simulator.resetView(); // P≈ôidat automatick√Ω reset pohledu
                            }
                        }

                        debug(`Naƒçteno ${files.length} program≈Ø`);
                    });
                }

                // Event listener pro editor
                const editor = document.getElementById('editor');
                if (editor) {
                    // Spustit simulaci a≈æ po chv√≠li neƒçinnosti
                    const debouncedSimulate = debounce(async () => {
                        if (window.simulator) {
                            await simulateProgram();
                        }
                    }, 500); // Zv√Ω≈°en√Ω debounce pro slo≈æitƒõj≈°√≠ parsov√°n√≠
                    editor.addEventListener('input', debouncedSimulate);
                }

                debug('Inicializace dokonƒçena');
            } catch (error) {
                console.error('Chyba p≈ôi inicializaci:', error);
            }
        }, { once: true });

        window.saveFile = function() {
            const content = editor.value;
            if (!content.trim()) {
                // M√≠sto alert() pou≈æijeme doƒçasnou zpr√°vu
                const saveBtn = event.target;
                const originalText = saveBtn.innerHTML;
                saveBtn.innerHTML = 'Program je pr√°zdn√Ω!';
                saveBtn.style.background = '#dc3545';
                setTimeout(() => {
                    saveBtn.innerHTML = originalText;
                    saveBtn.style.background = '';
                }, 2000);
                return;
            }

            const blob = new Blob([content], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');

            a.href = url;
            a.download = 'program.mpf';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            window.URL.revokeObjectURL(url);
            debug('Program ulo≈æen');
        }

        window.resetView = function() {
            if (window.simulator) {
                window.simulator.simulate(true); // Poslat 'true' pro vynucen√≠ resetu
            }
        }

        // Upravit event listener pro kliknut√≠ na ≈ô√°dek v editoru
        editor.addEventListener('click', async function(e) {
            if (!window.simulator || !window.simulator.player) return;
            if (window.simulator.player.isPlaying) return; // Neblokovat p≈ôi p≈ôehr√°v√°n√≠

            const cursorPosition = editor.selectionStart;
            const lines = editor.value.split('\n');
            if (!lines.length) return;

            const clickedLineIndex = editor.value.substr(0, cursorPosition).split('\n').length - 1;
            if (clickedLineIndex < 0) return;
            
            // Naj√≠t odpov√≠daj√≠c√≠ *pohyb* pro dan√Ω ≈ô√°dek
            // lineMovements mapuje [index_pohybu] => index_radku
            let targetMovementIndex = -1;
            // Hled√°me posledn√≠ pohyb, kter√Ω byl na tomto ≈ô√°dku NEBO P≈òED N√çM
            for(let i = window.simulator.player.lineMovements.length - 1; i >= 0; i--) {
                if (window.simulator.player.lineMovements[i] <= clickedLineIndex) {
                    targetMovementIndex = i;
                    break;
                }
            }
            
            window.simulator.player.currentIndex = targetMovementIndex;
            await window.simulator.player.drawToCurrentIndex();
            window.simulator.player.updateControls();
        });

        // P≈ôidat event listener pro opakovan√© p≈ôekreslen√≠ p≈ôi zmƒõnƒõ velikosti okna
        window.addEventListener('resize', debounce(() => {
            if (window.simulator) {
                window.simulator.setupCanvas();
                // Nen√≠ t≈ôeba volat simulate(), proto≈æe setupCanvas() ho vol√° internƒõ
            }
        }, 250));

        // P≈ôidat mo≈ænost v√Ωbƒõru slo≈æky s podprogramy
        window.selectProgramDirectory = function() {
            if (!window.simulator || !window.simulator.parser) {
                console.error('Simul√°tor nen√≠ inicializov√°n');
                return;
            }

            const input = document.createElement('input');
            input.type = 'file';
            input.webkitdirectory = true;
            input.multiple = true;

            input.addEventListener('change', async function(e) {
                if (this.files.length > 0) {
                    await window.simulator.parser.loadSubprogramDirectory(this.files);
                    debug(`Naƒçteno ${this.files.length} podprogram≈Ø`);
                }
            });

            input.click();
        }

        // P≈ôidat glob√°ln√≠ funkci simulateProgram
        window.simulateProgram = async function() {
            if (window.simulator) {
                // Krok 1: Spustit simulaci (parsov√°n√≠)
                // T√≠m se naƒçtou R-parametry z L... soubor≈Ø do simulator.parser
                await window.simulator.simulate();
                
                // Krok 2: Nastavit program pro p≈ôehr√°vaƒç
                // P≈ôehr√°vaƒç si zkop√≠ruje parametry z simulator.parser
                // a vytvo≈ô√≠ si vlastn√≠ mapu pohyb≈Ø (movements)
                if (window.simulator.player) {
                    await window.simulator.player.setProgram(editor.value);
                }
            }
        }

        // P≈ôidat funkce pro pr√°ci s mod√°ln√≠m oknem
        function showParameters() {
            if (!window.simulator || !window.simulator.parser) return;
            
            const modal = document.getElementById('parametersModal');
            const tableBody = document.getElementById('parametersTableBody');
            tableBody.innerHTML = '';

            // Z√≠skat se≈ôazen√© parametry, pouze nenulov√© nebo explicitnƒõ definovan√©
            const parameters = Array.from(window.simulator.parser.parameters.entries())
                .filter(([_, value]) => value !== 0) // Filtrovat pouze nenulov√© hodnoty
                .sort((a, b) => {
                    const numA = parseInt(a[0].replace('R', ''));
                    const numB = parseInt(b[0].replace('R', ''));
                    return numA - numB;
                });

            if (parameters.length === 0) {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td colspan="2" style="text-align: center; padding: 20px;">
                        ≈Ω√°dn√© definovan√© parametry
                    </td>
                `;
                tableBody.appendChild(row);
            } else {
                // Naplnit tabulku parametry
                for (const [param, value] of parameters) {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${param}</td>
                        <td>${typeof value === 'number' ? value.toFixed(3) : value}</td>
                    `;
                    tableBody.appendChild(row);
                }
            }

            modal.style.display = 'block';
        }

        function closeParametersModal() {
            const modal = document.getElementById('parametersModal');
            modal.style.display = 'none';
        }

        // P≈ôidat event listener pro zav≈ôen√≠ mod√°lu kliknut√≠m mimo nƒõj
        window.onclick = function(event) {
            const modal = document.getElementById('parametersModal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        }

        // P≈ôidat funkce pro pr√°ci s localStorage
        function saveSimulatorState() {
            if (!window.simulator) return;
            const state = {
                editorContent: editor.value,
                activeProgram: document.querySelector('.program-list-item.active')?.textContent || '',
                viewState: {
                    centerX: window.simulator.centerX,
                    centerY: window.simulator.centerY,
                    zoomFactor: window.simulator.zoomFactor,
                    scale: window.simulator.scale
                },
                timestamp: Date.now()
            };
            localStorage.setItem('simulatorState', JSON.stringify(state));
        }

        function loadSimulatorState() {
            const savedState = localStorage.getItem('simulatorState');
            if (savedState) {
                const state = JSON.parse(savedState);

                // Kontrola zda nen√≠ stav star≈°√≠ ne≈æ 1 hodina
                if (Date.now() - state.timestamp < 3600000) {
                    // Obnovit obsah editoru
                    editor.value = state.editorContent;

                    // Obnovit pozici zobrazen√≠
                    if (window.simulator && state.viewState) {
                        window.simulator.centerX = state.viewState.centerX;
                        window.simulator.centerY = state.viewState.centerY;
                        window.simulator.zoomFactor = state.viewState.zoomFactor;
                        window.simulator.scale = state.viewState.scale;
                    }

                    // Spustit simulaci
                    simulateProgram();
                }
            }
        }

        // Upravit event listener pro DOMContentLoaded
        window.addEventListener('DOMContentLoaded', () => {
            try {
                // ...existing initialization code...

                // P≈ôidat naƒçten√≠ ulo≈æen√©ho stavu
                // loadSimulatorState(); // Doƒçasnƒõ zak√°z√°no, m≈Ø≈æe zp≈Øsobovat konflikty p≈ôi naƒç√≠t√°n√≠

                // Event listener pro ukl√°d√°n√≠ stavu p≈ôi zmƒõn√°ch
                editor.addEventListener('input', debounce(() => {
                    saveSimulatorState();
                    // Simulace se ji≈æ vol√° v 'debouncedSimulate' v hlavn√≠m DOMContentLoaded
                }, 1000));

                // P≈ôidat ukl√°d√°n√≠ p≈ôi zmƒõnƒõ zobrazen√≠
                if (window.simulator && window.simulator.canvas) {
                    window.simulator.canvas.addEventListener('wheel', debounce(() => {
                        saveSimulatorState();
                    }, 1000));

                    window.simulator.canvas.addEventListener('mouseup', () => {
                        if (window.simulator.isDragging) {
                            saveSimulatorState();
                        }
                    });
                }

            } catch (error) {
                console.error('Chyba p≈ôi inicializaci:', error);
            }
        }, { once: true }); // 'once: true' bylo ji≈æ zde, ale loadSimulatorState() by mƒõl b√Ωt vol√°n zde

        // Naƒçten√≠ stavu po pln√© inicializaci
        window.addEventListener('load', () => {
             loadSimulatorState();
        });

        // P≈ôidat ukl√°d√°n√≠ p≈ôi odchodu ze str√°nky
        window.addEventListener('beforeunload', () => {
            saveSimulatorState();
        });
    </script>
</body>
</html>
