<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Karusel CNC SmartGrid Pro v8.16</title>
    <style>
        :root { 
            --bg-canvas: #ffffff;           
            --bg-panel: #2c2c2c;
            --grid-main: #ccc;       
            --grid-sub: #e8e8e8;     
            --axis: #444;            
            --accent: #ff6f00;       
            --text-dark: #333;
            --text-light: #eee;
            --btn-link-color: #4caf50;
            --btn-arc-color: #2196f3;
            --btn-measure-color: #ff9800;
            --btn-mode-color: #00bcd4;
            --btn-undo-color: #4a4a4a; /* Nová barva pro Undo */
            --btn-redo-color: #6a6a6a; /* Nová barva pro Redo */
        }

        body { margin: 0; padding: 0; background: var(--bg-panel); color: var(--text-light); font-family: 'Segoe UI', Roboto, sans-serif; height: 100vh; width: 100vw; overflow: hidden; user-select: none; }

        #app-layout { display: flex; width: 100%; height: 100%; }

        #canvas-area {
            background: var(--bg-canvas); position: relative; flex-shrink: 0; 
            overflow: hidden; box-shadow: 0 0 20px rgba(0,0,0,0.5); z-index: 1;
        }

        svg { width: 100%; height: 100%; display: block; cursor: crosshair; }

        #panel-area {
            flex-grow: 1; background: var(--bg-panel); display: flex; flex-direction: column;
            padding: 20px; box-sizing: border-box; overflow-y: auto; align-items: center;
        }

        .axis-line { stroke: var(--axis); stroke-width: 2px; vector-effect: non-scaling-stroke; }
        .grid-line { stroke: var(--grid-main); stroke-width: 1.5px; vector-effect: non-scaling-stroke; }
        .grid-sub-line { stroke: var(--grid-sub); stroke-width: 1px; vector-effect: non-scaling-stroke; }
        .path-draw { stroke: #00c853; fill: none; vector-effect: non-scaling-stroke; stroke-linecap: round; stroke-linejoin: round; }
        .point-marker { fill: #fff; stroke: var(--accent); vector-effect: non-scaling-stroke; }
        .point-current { fill: var(--accent); }
        .measure-line { stroke: #ff9800; stroke-width: 2.5px; stroke-dasharray: 8, 4; vector-effect: non-scaling-stroke; }
        .measure-point { fill: #ff9800; r: 6px; vector-effect: non-scaling-stroke; }
        .point-center { fill: yellow; r: 4px; vector-effect: non-scaling-stroke; stroke: #333; stroke-width: 0.5px; } /* Styl pro střed oblouku */
        .point-center-clickable { cursor: pointer; fill: rgba(255,255,0,0.01); stroke: transparent; }
        .point-center-clickable:hover { stroke: #ff0; stroke-width: 2px; }

        /* Vizuální prvek pro kliknutí na bod */
        .point-marker-clickable { cursor: pointer; fill: rgba(255,255,255,0.01); stroke: transparent; }
        .point-marker-clickable:hover { stroke: #2196f3; stroke-width: 2px; }


        #coords-hud {
            position: absolute; top: 10px; left: 10px;
            background: rgba(255,255,255,0.9); padding: 6px 12px;
            border-radius: 8px; border: 1px solid #ccc;
            pointer-events: none; display: flex; gap: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .hud-val { font-size: 1.1rem; font-weight: bold; color: #000; font-family: 'Consolas', monospace; }
        .hud-label { font-size: 0.7rem; color: #666; text-transform: uppercase; font-weight: 700; margin-left: 4px; }

        #btn-home {
            position: absolute; top: 15px; right: 15px; width: 45px; height: 45px;
            background: #fff; color: #333; border-radius: 8px; border: 1px solid #ccc;
            display: flex; justify-content: center; align-items: center;
            font-size: 24px; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 10; transition: background 0.2s;
        }
        #btn-home:active { background: #eee; transform: scale(0.95); }

        .panel-group { width: 100%; max-width: 400px; margin-bottom: 20px; }
        .act-btn {
            width: 100%; padding: 15px; border: none; border-radius: 8px; 
            font-weight: bold; cursor: pointer; color: #fff; text-align: center; font-size: 14px;
            background: #444; box-shadow: 0 4px 0 #222; margin-bottom: 10px;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .act-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 #222; }
        
        .btn-linka { background: var(--btn-link-color); font-size: 16px; padding: 15px; text-transform: uppercase; letter-spacing: 1px; }
        .btn-arc { background: var(--btn-arc-color); font-size: 16px; padding: 15px; text-transform: uppercase; letter-spacing: 1px; }
        .btn-measure { background: var(--btn-measure-color); font-size: 16px; padding: 15px; text-transform: uppercase; letter-spacing: 1px; }
        .btn-toggle { background: var(--accent); color: #000; }
        .btn-danger { background: #d32f2f; margin-top: 20px; }
        
        /* Nový layout pro Undo/Redo */
        #undo-redo-group { display: flex; gap: 10px; margin-bottom: 10px; }
        #undo-redo-group .act-btn { margin-bottom: 0; flex: 1; }
        .btn-undo { background: var(--btn-undo-color); color: #fff; }
        .btn-redo { background: var(--btn-redo-color); color: #fff; }
        .btn-disabled { opacity: 0.5; pointer-events: none; }


        @media (orientation: portrait) {
            #app-layout { flex-direction: column; }
            #canvas-area { width: 100%; aspect-ratio: 1 / 1; }
        }
        @media (orientation: landscape) {
            #app-layout { flex-direction: row; }
            #canvas-area { height: 100%; aspect-ratio: 1 / 1; }
        }

        /* MODALS */
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 100; justify-content: center; align-items: center; backdrop-filter: blur(3px); }
        .modal-content { background: #fff; padding: 25px; border-radius: 16px; width: 90%; max-width: 350px; color: #333; border: 1px solid #ccc; box-shadow: 0 10px 25px rgba(0,0,0,0.5); max-height: 90vh; overflow-y: auto; }
        
        .joypad-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; aspect-ratio: 1/0.8; margin-top: 10px; }
        .joy-btn { 
            background: #f0f0f0; border: 1px solid #ccc; border-radius: 8px; 
            color: #333; display: flex; flex-direction: column; justify-content: center; align-items: center; 
            cursor: pointer; transition: background 0.1s; box-shadow: 0 3px 0 #bbb; 
        }
        .joy-btn:active { transform: translateY(2px); box-shadow: 0 1px 0 #bbb; background: var(--accent); color: #fff; }
        .joy-arrow { font-size: 24px; line-height: 1; }
        .joy-desc { font-size: 9px; color: #666; font-weight: bold; margin-top: 2px; }
        .joy-close { background: #e0e0e0; border-color: #999; color: #555; font-size: 12px; font-weight: bold; }

        h3 { margin-top: 0; text-align: center; color: #333; }
        input { width: 100%; padding: 12px; font-size: 18px; text-align: right; border: 1px solid #ccc; border-radius: 6px; margin-bottom: 15px; box-sizing: border-box; background: #fff; color: #000; }
        
        .segmented-control { display: flex; width: 100%; margin-bottom: 15px; border: 1px solid #ccc; border-radius: 6px; overflow: hidden; }
        .seg-opt { flex: 1; padding: 12px; text-align: center; cursor: pointer; background: #f9f9f9; font-weight: bold; font-size: 14px; transition: background 0.2s; }
        .seg-opt.active { background: var(--btn-arc-color); color: white; }
        
        .modal-btn-row { display: flex; gap: 10px; }
        .m-btn { flex: 1; padding: 12px; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; }
        .m-ok { background: var(--btn-link-color); color: #fff; }
        .m-cancel { background: #ddd; color: #333; }

        .chk-row { display: flex; align-items: center; margin-bottom: 15px; background: #f0f8ff; padding: 10px; border-radius: 6px; border: 1px solid #b3d7ff; }
        .chk-row input { width: auto; margin: 0 10px 0 0; transform: scale(1.5); }
        .chk-row label { font-weight: bold; color: #0056b3; cursor: pointer; font-size: 14px; width: 100%; }

        #tangent-choices { display: none; margin-top: 10px; border-top: 1px solid #eee; padding-top: 10px; }
        .choice-btn { 
            width: 100%; padding: 12px; margin-bottom: 8px; 
            background: #fff3cd; border: 1px solid #ffeeba; border-radius: 6px;
            text-align: left; cursor: pointer; font-family: monospace; font-size: 14px;
            display: flex; justify-content: space-between; align-items: center;
        }
        .choice-btn:hover { background: #ffe8a1; }
        .choice-btn span { font-weight: bold; color: #856404; }

        .arc-tabs { display: flex; border-bottom: 2px solid #eee; margin-bottom: 15px; }
        .arc-tab { flex: 1; text-align: center; padding: 10px; cursor: pointer; font-weight: bold; color: #999; border-bottom: 2px solid transparent; }
        .arc-tab.active { color: var(--btn-arc-color); border-bottom-color: var(--btn-arc-color); }
        
        /* Nový styl pro Inkrementální/Absolutní přepínač */
        .mode-toggle .seg-opt.active { background: var(--btn-mode-color); }
        
        /* Styl pro přepínání cíle tangenciální kružnice */
        .tangent-target-toggle .seg-opt.active { background: var(--btn-measure-color); color: white; }

    </style>
</head>
<body>

<div id="app-layout">
    <div id="canvas-area">
        <svg id="svgCanvas" preserveAspectRatio="xMidYMid slice">
            <g id="worldGroup" transform="scale(1, -1)">
                <g id="gridLines"></g> 
                <g id="axisGroup"></g> 
                <g id="pathGroup"></g> 
                <g id="measureLayer"></g> <!-- Vrstva pro měřicí čáry -->
            </g>
            <g id="textGroup"></g>
        </svg>
        
        <div id="coords-hud">
            <div><span class="hud-val" id="hud-x">0.00</span><span class="hud-label">X</span></div>
            <div style="width:1px; background:#ddd;"></div>
            <div><span class="hud-val" id="hud-z">0.00</span><span class="hud-label">Z</span></div>
        </div>

        <div id="btn-home" onclick="setHomeView()" title="Reset pohledu">⌂</div>
    </div>

    <div id="panel-area">
        <div class="panel-group">
            <button class="act-btn btn-linka" onclick="openJoypad()">Linka / Kužel</button>
            <button class="act-btn btn-arc" onclick="openArcModal()">Kružnice (G2/G3)</button>
            <button class="act-btn btn-measure" onclick="openMeasureModal()">Měření</button>
            
            <button id="btn-toggle-dia" class="act-btn btn-toggle" onclick="toggleDiameterMode()">Průměr (Ø)</button>
            <button class="act-btn" onclick="fitToScreen()">Centrovat Pohled</button>
            <button class="act-btn" onclick="openStartModal()">Nový Startovní Bod</button>
            
            <!-- NOVÝ UNDO/REDO PANEL -->
            <div id="undo-redo-group">
                <button id="btn-undo" class="act-btn btn-undo btn-disabled" onclick="undoLastMove()">Zpět (Undo)</button> 
                <button id="btn-redo" class="act-btn btn-redo btn-disabled" onclick="redoLastMove()">Obnovit (Redo)</button>
            </div>
            
            <button class="act-btn btn-danger" onclick="clearAll()">Smazat Vše</button>
        </div>

        <div style="margin-top:auto; font-size:10px; color:#666;">
            Karusel CNC Helper v8.15
        </div>
    </div>
</div>

<!-- MODAL JOYPAD -->
<div id="modal-joypad" class="modal">
    <div class="modal-content">
        <h3>Vyberte směr</h3>
        <div class="joypad-grid">
            <div class="joy-btn" onclick="prepMove('UL')"><span class="joy-arrow">↖</span><span class="joy-desc">Kužel</span></div>
            <div class="joy-btn" onclick="prepMove('U')"><span class="joy-arrow">⬆</span><span class="joy-desc">Z+</span></div>
            <div class="joy-btn" onclick="prepMove('UR')"><span class="joy-arrow">↗</span><span class="joy-desc">Kužel</span></div>
            <div class="joy-btn" onclick="prepMove('L')"><span class="joy-arrow">⬅</span><span class="joy-desc">X-</span></div>
            <div class="joy-btn joy-close" onclick="closeModals()">ZAVŘÍT</div>
            <div class="joy-btn" onclick="prepMove('R')"><span class="joy-arrow">➡</span><span class="joy-desc">X+</span></div>
            <div class="joy-btn" onclick="prepMove('DL')"><span class="joy-arrow">↙</span><span class="joy-desc">Kužel</span></div>
            <div class="joy-btn" onclick="prepMove('D')"><span class="joy-arrow">⬇</span><span class="joy-desc">Z-</span></div>
            <div class="joy-btn" onclick="prepMove('DR')"><span class="joy-arrow">↘</span><span class="joy-desc">Kužel</span></div>
        </div>
    </div>
</div>

<!-- MODAL INPUT (Linka/Kužel) -->
<div id="modal-input" class="modal">
    <div class="modal-content">
        <h3 id="input-title">Zadat hodnoty</h3>
        <div id="input-linear" style="display:none;">
            <label style="display:block; margin-bottom:5px; color:#666; font-size:12px;">Délka pohybu (mm):</label>
            <input type="number" id="inp-len" placeholder="0" inputmode="decimal">
        </div>
        <div id="input-complex" style="display:none;">
            <label id="lbl-inp-x" style="display:block; margin-bottom:5px; color:#666; font-size:12px;">Cílový Průměr X (mm):</label>
            <input type="number" id="inp-x" placeholder="Nevím" inputmode="decimal">
            <label style="display:block; margin-bottom:5px; color:#666; font-size:12px;">Cílová Výška Z (mm):</label>
            <input type="number" id="inp-z" placeholder="Nevím" inputmode="decimal">
            <label style="display:block; margin-bottom:5px; color:#666; font-size:12px;">Úhel (°):</label>
            <input type="text" id="inp-a" placeholder="např. 360-45" inputmode="text">
            
            <!-- NOVÉ POLE PRO DÉLKU ÚSEČKY -->
            <label style="display:block; margin-bottom:5px; color:#666; font-size:12px; margin-top:10px; border-top:1px dashed #ccc; padding-top:5px;">Délka úsečky (L):</label>
            <input type="number" id="inp-l" placeholder="Volitelné (místo X/Z)" inputmode="decimal">
            
            <div style="font-size:11px; color:#999; margin-bottom:15px; text-align:center;">0=Vpravo, 90=Nahoru, 180=Vlevo...</div>
        </div>
        <div class="modal-btn-row">
            <button class="m-btn m-cancel" onclick="openJoypad()">Zpět</button>
            <button class="m-btn m-ok" onclick="commitMove()">Vypočítat</button>
        </div>
    </div>
</div>

<!-- MODAL ARC (Kružnice) -->
<div id="modal-arc" class="modal">
    <div class="modal-content">
        <h3 style="margin-bottom:10px;">Kružnice (Radius)</h3>
        <div class="arc-tabs">
            <div class="arc-tab active" id="tab-r" onclick="switchArcMethod('R')">Rádius (R)</div>
            <div class="arc-tab" id="tab-ik" onclick="switchArcMethod('IK')">Střed (I, K)</div>
        </div>
        <label style="display:block; margin-bottom:5px; color:#666; font-size:12px;">Směr otáčení:</label>
        <div class="segmented-control">
            <div class="seg-opt active" id="seg-g2" onclick="setArcDir(true)">G2 (Po směru)</div>
            <div class="seg-opt" id="seg-g3" onclick="setArcDir(false)">G3 (Proti)</div>
        </div>
        <div id="method-r">
            <div class="chk-row">
                <input type="checkbox" id="chk-tangent" onchange="toggleTangentMode()">
                <label for="chk-tangent">Tangenciální napojení</label>
            </div>
            <label style="display:block; margin-bottom:5px; color:#666; font-size:12px;">Rádius (R):</label>
            <input type="number" id="arc-r" placeholder="Poloměr" inputmode="decimal">
        </div>
        <div id="method-ik" style="display:none;">
            <div class="segmented-control mode-toggle">
                <div class="seg-opt active" id="ik-abs-btn" onclick="toggleIKMode(false)">Absolutní</div>
                <div class="seg-opt" id="ik-inc-btn" onclick="toggleIKMode(true)">Přírůstkové</div>
            </div>
            <p style="font-size:11px; color:#888; margin-bottom:10px;">Rádius se vypočítá automaticky ze středu.</p>
            <label id="lbl-center-x" style="display:block; margin-bottom:5px; color:#666; font-size:12px;">Střed I (Absolutní X):</label>
            <input type="number" id="center-x" placeholder="Střed X" inputmode="decimal">
            <label id="lbl-center-z" style="display:block; margin-bottom:5px; color:#666; font-size:12px;">Střed K (Absolutní Z):</label>
            <input type="number" id="center-z" placeholder="Střed Z" inputmode="decimal">
        </div>
        
        <!-- NOVÁ SEKCE PRO ZADÁVÁNÍ CÍLE TANGENTNÍ KRUŽNICE -->
        <div id="arc-targets">
            <div id="tangent-target-selector" style="margin-bottom: 15px; display: none;">
                <label style="display:block; margin-bottom:5px; color:#666; font-size:12px;">Definovat cíl přes:</label>
                <div class="segmented-control tangent-target-toggle">
                    <div class="seg-opt active" id="target-coord-btn" onclick="setTangentTarget('coord')">X / Z Souřadnice</div>
                    <div class="seg-opt" id="target-cone-btn" onclick="setTangentTarget('cone')">Úhel Kuželu</div>
                </div>
            </div>
            
            <div id="target-coord-inputs">
                <label id="lbl-arc-x" style="display:block; margin-bottom:5px; color:#666; font-size:12px;">Koncové X (Průměr):</label>
                <input type="number" id="arc-x" placeholder="Průměr" inputmode="decimal">
                <label style="display:block; margin-bottom:5px; color:#666; font-size:12px;">Koncové Z:</label>
                <input type="number" id="arc-z" placeholder="Délka" inputmode="decimal">
            </div>
            
            <div id="target-cone-input" style="display: none;">
                <label id="lbl-arc-cone-angle" style="display:block; margin-bottom:5px; color:#666; font-size:12px;">Úhel Kuželu (°):</label>
                <input type="text" id="arc-cone-angle" placeholder="např. 30" inputmode="text">
            </div>
        </div>
        
        <div id="tangent-choices">
            <p style="font-size:12px; color:#666; text-align:center; margin:5px 0;">Nalezeny 2 možnosti. Vyberte:</p>
            <div id="choices-container"></div>
        </div>
        <div class="modal-btn-row" id="arc-main-btns">
            <button class="m-btn m-cancel" onclick="closeModals()">Zrušit</button>
            <button id="btn-arc-ok" class="m-btn m-ok" style="background:var(--btn-arc-color);" onclick="commitArc()">Vykreslit</button>
        </div>
    </div>
</div>

<!-- MODAL START -->
<div id="modal-start" class="modal">
    <div class="modal-content">
        <h3>Nový Startovní Bod</h3>
        <p style="font-size:12px; color:#666; text-align:center;">Zadejte výchozí souřadnice.</p>
        <label id="lbl-start-x" style="display:block; margin-bottom:5px; color:#666; font-size:12px;">Start X (Průměr):</label>
        <input type="number" id="start-x" placeholder="0" inputmode="decimal">
        <label style="display:block; margin-bottom:5px; color:#666; font-size:12px;">Start Z:</label>
        <input type="number" id="start-z" placeholder="0" inputmode="decimal">
        <div class="modal-btn-row">
            <button class="m-btn m-cancel" onclick="closeModals()">Zrušit</button>
            <button class="m-btn m-ok" onclick="confirmNewStart()">Nastavit</button>
        </div>
    </div>
</div>

<!-- MODAL MEASURE -->
<div id="modal-measure" class="modal">
    <div class="modal-content">
        <h3>Měření</h3>
        <p id="measure-info" style="font-size:12px; color:#666; margin-bottom:15px; text-align:center;">Vyberte typ měření.</p>
        
        <div class="segmented-control" style="border-color: var(--btn-measure-color);">
            <div class="seg-opt active" id="meas-dist-btn" onclick="startMeasure('distance')" style="background: var(--btn-measure-color); color: white;">Vzdálenost (L)</div>
            <div class="seg-opt" id="meas-angle-btn" onclick="startMeasure('angle')">Úhel lomu (3 body)</div>
            <div class="seg-opt" id="meas-cone-btn" onclick="startMeasure('cone_angle')">Úhel kuželu (1 bod)</div>
            <div class="seg-opt" id="meas-coord-btn" onclick="startMeasure('coord')">Souřadnice bodu</div>
        </div>

        <p id="measure-instructions" style="font-size:14px; color:#333; font-weight:bold; text-align:center; margin-top:20px;">
            <span style="color:var(--btn-measure-color);">Instrukce:</span> Klikněte na 2 body.
        </p>

        <div id="measure-result" style="margin-top:20px; padding:15px; background:#f0f0f0; border-radius:8px; display:none;">
            <h4 style="margin-top:0;">Výsledek:</h4>
            <div id="measure-output" style="font-family:monospace; font-size:16px; color:#000;"></div>
        </div>

        <div class="modal-btn-row" style="margin-top:20px;">
            <button class="m-btn m-cancel" onclick="stopMeasure()">Zavřít</button>
        </div>
    </div>
</div>

<script>
    let points = [{x: 0, z: 0, break: false, type: 'line', id: 0}]; 
    let historyStack = []; // Pro Undo
    let redoStack = []; // Pro Redo
    let pointIdCounter = 1;
    let currentDir = ''; 
    let isG2 = true; 
    let arcMethod = 'R';
    let isIncrementalIKMode = false;
    let tangentTargetMode = 'coord'; 
    
    // Měření
    let measureMode = null; 
    let measurePoints = []; 

    const savedMode = localStorage.getItem('cnc_diameter_mode');
    let isDiameterMode = savedMode !== null ? (savedMode === 'true') : true;
    
    const svg = document.getElementById('svgCanvas');
    const gridLines = document.getElementById('gridLines');
    const textGroup = document.getElementById('textGroup');
    const pathGroup = document.getElementById('pathGroup');
    const axisGroup = document.getElementById('axisGroup');
    const measureLayer = document.getElementById('measureLayer'); 

    let vb = { x: 0, y: 0, w: 600, h: 600 };
    
    // --- POMOCNÉ FUNKCE HISTORIE ---
    function saveHistory() {
        if (points.length > 0) {
            historyStack.push(JSON.parse(JSON.stringify(points)));
            redoStack = []; 
            updateUndoRedoButtons();
        }
    }

    function updateUndoRedoButtons() {
        document.getElementById('btn-undo').classList.toggle('btn-disabled', historyStack.length === 0);
        document.getElementById('btn-redo').classList.toggle('btn-disabled', redoStack.length === 0);
    }
    
    function undoLastMove() {
        if (historyStack.length > 0) {
            redoStack.push(JSON.parse(JSON.stringify(points)));
            points = historyStack.pop();
            
            // Centrování na poslední bod
            const lastActiveIndex = points.length - 1;
            centerViewOnPoint(points[lastActiveIndex]);
            updatePath();
        } else if (points.length === 1) {
             // Pokud zbývá jen jeden bod, resetovat ho na [0, 0]
            redoStack.push(JSON.parse(JSON.stringify(points)));
            points = [{x: 0, z: 0, break: false, type: 'line', id: 0}];
            setHomeView();
            updatePath();
        }
        updateUndoRedoButtons();
    }
    
    function redoLastMove() {
        if (redoStack.length > 0) {
            historyStack.push(JSON.parse(JSON.stringify(points)));
            points = redoStack.pop();
            const lastActiveIndex = points.length - 1;
            centerViewOnPoint(points[lastActiveIndex]);
            updatePath();
        }
        updateUndoRedoButtons();
    }

    // --- INIT ---
    updateDiameterButtonText();

    function handleResize() {
        const container = document.getElementById('canvas-area');
        const wPx = container.clientWidth;
        const hPx = container.clientHeight;
        if (wPx === 0 || hPx === 0) return;
        vb.h = vb.w; 
        updateViewBox();
        drawDynamicGrid();
        updatePath();
    }
    
    function setHomeView() {
        vb.w = 600; vb.h = 600; vb.y = -580; vb.x = -20; 
        updateViewBox();
        drawDynamicGrid();
        updatePath();
    }

    window.addEventListener('resize', handleResize);
    setTimeout(() => { handleResize(); setHomeView(); saveHistory(); }, 0); // Uložení počátečního stavu

    // --- OVLÁDÁNÍ POHLEDU (DRAG, ZOOM) ---
    let isDragging = false;
    svg.addEventListener('mousedown', e => { isDragging = true; });
    window.addEventListener('mouseup', () => isDragging = false);
    window.addEventListener('mousemove', e => {
        if (!isDragging) return;
        const scale = vb.w / svg.clientWidth; 
        vb.x -= e.movementX * scale; vb.y -= e.movementY * scale; 
        updateViewBox(); requestAnimationFrame(drawDynamicGrid);
    });

    let lastTouchX=0, lastTouchY=0;
    svg.addEventListener('touchstart', e => {
        isDragging = true; lastTouchX = e.touches[0].clientX; lastTouchY = e.touches[0].clientY;
    }, {passive:false});
    window.addEventListener('touchend', () => isDragging = false);
    svg.addEventListener('touchmove', e => {
        if(!isDragging) return; e.preventDefault(); 
        const tx = e.touches[0].clientX; const ty = e.touches[0].clientY;
        const dx = tx - lastTouchX; const dy = ty - lastTouchY;
        lastTouchX = tx; lastTouchY = ty;
        const scale = vb.w / svg.clientWidth;
        vb.x -= dx * scale; vb.y -= dy * scale;
        updateViewBox(); requestAnimationFrame(drawDynamicGrid);
    }, {passive:false});

    const MIN_ZOOM = 0.05; 
    svg.addEventListener('wheel', e => {
        e.preventDefault();
        const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
        const oldW = vb.w; const oldH = vb.h;
        let newW = vb.w * zoomFactor; let newH = vb.h * zoomFactor;
        if (newW < MIN_ZOOM) {
            if (zoomFactor < 1) { newW = MIN_ZOOM; newH = MIN_ZOOM; if (vb.w <= MIN_ZOOM + 0.0001) return; }
        }
        vb.w = newW; vb.h = newH;
        vb.x -= (vb.w - oldW) / 2; vb.y -= (vb.h - oldH) / 2;
        updateViewBox(); drawDynamicGrid(); updatePath();
    }, {passive: false});

    function updateViewBox() {
        svg.setAttribute('viewBox', `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);
    }

    // --- GRID RENDERING (Zkráceno pro přehlednost) ---
    function drawDynamicGrid() {
        gridLines.innerHTML = ''; textGroup.innerHTML = ''; axisGroup.innerHTML = '';
        const minDim = vb.w; 
        const roughStep = minDim / 5; 
        const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));
        const residual = roughStep / magnitude;
        let step;
        if (residual < 2) step = 1 * magnitude;
        else if (residual < 5) step = 2 * magnitude;
        else step = 5 * magnitude;
        const subStep = step / 5;
        let decimals = Math.max(0, Math.ceil(-Math.log10(step)));
        if (step >= 1) decimals = 0;
        const fontSize = Math.max(minDim / 32, step/3.5); 
        const padding = fontSize * 3.0;
        const zMin = -(vb.y + vb.h); const zMax = -vb.y;          
        const xMin = vb.x; const xMax = vb.x + vb.w;    
        const startX = Math.floor(xMin / step) * step;
        const startZ = Math.floor(zMin / step) * step;

        createLine(axisGroup, -100000, 0, 100000, 0, 'axis-line');
        createLine(axisGroup, 0, -100000, 0, 100000, 'axis-line');

        const safeTop = vb.y + padding;
        const safeBottom = vb.y + vb.h - padding;
        let stickyY = Math.max(safeTop, Math.min(safeBottom, 0));
        let baseline = "hanging";
        let isBottom = false;
        if (Math.abs(stickyY - safeBottom) < 0.001) { baseline = "auto"; isBottom = true; } 
        else if (Math.abs(stickyY - safeTop) < 0.001) { baseline = "hanging"; } 
        else { stickyY += fontSize * 0.6; baseline = "hanging"; }

        for (let x = startX; x < xMax + step; x += step) {
            if (x > xMax) break;
            createLine(gridLines, x, zMin, x, zMax, 'grid-line');
            for (let i = 1; i < 5; i++) {
                const subX = x + (subStep * i); if (subX < xMax) createLine(gridLines, subX, zMin, subX, zMax, 'grid-sub-line');
            }
            let staggerOffset = 0;
            const index = Math.round(x / step);
            if (index % 2 !== 0) staggerOffset = (isBottom || baseline === "auto") ? -fontSize*1.2 : fontSize*1.2; 
            const displayVal = isDiameterMode ? (x * 2) : x;
            const valStr = displayVal.toFixed(decimals);
            if (Math.abs(x) > step/100) addText(textGroup, x, stickyY + staggerOffset, valStr, fontSize, "middle", baseline);
            else addText(textGroup, x + fontSize/2, stickyY + staggerOffset, valStr, fontSize, "start", baseline);
        }

        const safeLeft = vb.x + padding;
        const safeRight = vb.x + vb.w - padding;
        let stickyX = Math.max(safeLeft, Math.min(safeRight, 0));
        let anchor = "end";
        if (Math.abs(stickyX - safeRight) < 0.001) anchor = "end"; 
        else if (Math.abs(stickyX - safeLeft) < 0.001) anchor = "start"; 
        else { stickyX -= fontSize * 0.5; anchor = "end"; }

        for (let z = startZ; z < zMax + step; z += step) {
            if (z > zMax) break;
            createLine(gridLines, xMin, z, xMax, z, 'grid-line');
            for (let i = 1; i < 5; i++) {
                const subZ = z + (subStep * i); if (subZ < zMax) createLine(gridLines, xMin, subZ, xMax, subZ, 'grid-sub-line');
            }
            const valStr = z.toFixed(decimals);
            if (Math.abs(z) > step/100) addText(textGroup, stickyX, -z + (fontSize/3), valStr, fontSize, anchor, "auto");
            else addText(textGroup, stickyX, -z - fontSize/2, valStr, fontSize, anchor, "auto");
        }
    }
    
    function createLine(parent, x1, z1, x2, z2, className) {
        const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
        l.setAttribute("x1", x1); l.setAttribute("y1", z1); l.setAttribute("x2", x2); l.setAttribute("y2", z2);
        l.setAttribute("class", className); parent.appendChild(l);
    }

    function addText(parent, screenX, screenY, textStr, size, anchor, baseline) {
        const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
        t.setAttribute("x", screenX); t.setAttribute("y", screenY); t.textContent = textStr;
        t.setAttribute("fill", "#666"); t.setAttribute("font-size", size);
        t.setAttribute("font-family", "Consolas, monospace"); t.setAttribute("font-weight", "bold");
        t.setAttribute("text-anchor", anchor || "middle");
        if(baseline) t.setAttribute("dominant-baseline", baseline);
        t.setAttribute("stroke", "rgba(255,255,255,0.9)"); t.setAttribute("stroke-width", size/3); t.setAttribute("paint-order", "stroke");
        parent.appendChild(t);
    }

    // --- PATH RENDERING AND POINT CLICKING ---
    function onPointClick(e, index) {
        if (isDragging) return;
        const selectedPoint = points[index];
        
        if (measureMode) {
            handleMeasureClick(selectedPoint);
            return;
        }

        if (points.length > 0) {
            const last = points[points.length - 1];
            if (last.x === selectedPoint.x && last.z === selectedPoint.z && last.type === selectedPoint.type) {
                centerViewOnPoint(selectedPoint);
                return;
            }
        }
        
        const newPoint = { 
            x: selectedPoint.x, 
            z: selectedPoint.z, 
            break: true, 
            type: 'line',
            id: pointIdCounter++
        };
        
        saveHistory(); // Uložit historii před přidáním bodu
        points.push(newPoint);
        
        centerViewOnPoint(newPoint);
        updatePath();
    }
    
    function onCenterClick(cx, cz) {
        if (isDragging) return;
        
        if (measureMode) {
            handleMeasureClick({x: cx, z: cz, type: 'center'});
            return;
        }
        
        // Zobrazit souřadnice středu v HUD panelu
        const dispX = isDiameterMode ? cx * 2 : cx;
        document.getElementById('hud-x').innerText = dispX.toFixed(2) + ' (I)';
        document.getElementById('hud-z').innerText = cz.toFixed(2) + ' (K)';
    }


    function updatePath() {
        pathGroup.innerHTML = '';
        if(points.length === 0) return;

        const last = points[points.length-1];
        const xVal = isDiameterMode ? (last.x * 2) : last.x;
        document.getElementById('hud-x').innerText = xVal.toFixed(2);
        document.getElementById('hud-z').innerText = last.z.toFixed(2);

        const clientW = svg.clientWidth || 300;
        const mmPerPx = vb.w / clientW;
        const pointRadiusMm = 4 * mmPerPx;
        const clickableRadiusMm = 10 * mmPerPx;
        const lineWidthMm = 2.5 * mmPerPx;

        let d = "";
        points.forEach((p, i) => {
            const isCurrent = i === points.length - 1;
            
            // 1. Klikatelná oblast bodu (transparentní)
            const clickArea = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            clickArea.setAttribute("cx", p.x); clickArea.setAttribute("cy", p.z);
            clickArea.setAttribute("r", clickableRadiusMm);
            clickArea.setAttribute("class", "point-marker-clickable");
            clickArea.onclick = (e) => onPointClick(e, i);
            pathGroup.appendChild(clickArea);

            // 2. Vizuální bod
            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute("cx", p.x); circle.setAttribute("cy", p.z);
            circle.setAttribute("class", isCurrent ? "point-marker point-current" : "point-marker");
            circle.setAttribute("r", pointRadiusMm);
            circle.setAttribute("stroke-width", lineWidthMm * 0.8); 
            pathGroup.appendChild(circle);
            
            // 3. Střed oblouku (pouze pokud je typ ARC)
            if (p.type === 'arc' && p.cx !== undefined) {
                // Klikatelná oblast pro střed (větší)
                const centerClickArea = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                centerClickArea.setAttribute("cx", p.cx);
                centerClickArea.setAttribute("cy", p.cz);
                centerClickArea.setAttribute("r", clickableRadiusMm * 0.8);
                centerClickArea.setAttribute("class", "point-center-clickable");
                centerClickArea.onclick = () => onCenterClick(p.cx, p.cz);
                pathGroup.appendChild(centerClickArea);

                // Vizuální bod středu
                const centerCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                centerCircle.setAttribute("cx", p.cx);
                centerCircle.setAttribute("cy", p.cz);
                centerCircle.setAttribute("class", "point-center");
                centerCircle.setAttribute("r", pointRadiusMm * 0.6); // Menší žlutá tečka
                centerCircle.setAttribute("stroke-width", lineWidthMm * 0.8); 
                pathGroup.appendChild(centerCircle);
            }


            // 4. Čáry
            if (i === 0) d += `M ${p.x} ${p.z}`;
            else {
                if (p.break) d += ` M ${p.x} ${p.z}`;
                else if (p.type === 'arc') {
                    const sweep = p.cw ? 0 : 1; 
                    d += ` A ${p.r} ${p.r} 0 0 ${sweep} ${p.x} ${p.z}`;
                } else d += ` L ${p.x} ${p.z}`;
            }
        });

        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", d);
        path.setAttribute("class", "path-draw");
        path.setAttribute("stroke-width", lineWidthMm);
        pathGroup.appendChild(path);
        
        // Vykreslení měřicí vrstvy
        updateMeasureDisplay();
        updateUndoRedoButtons(); // Aktualizace tlačítek po každém překreslení
    }

    // --- MĚŘENÍ LOGIKA (Zkráceno pro přehlednost) ---
    function openMeasureModal() {
        if (points.length < 2) {
             alert("Nakreslete alespoň dvě úsečky, abyste mohl měřit vzdálenost nebo úhel.");
             return;
        }
        closeModals();
        document.getElementById('modal-measure').style.display = 'flex';
        startMeasure('distance'); // Výchozí stav
    }

    function startMeasure(mode) {
        measureMode = mode;
        measurePoints = [];
        measureLayer.innerHTML = '';
        document.getElementById('measure-result').style.display = 'none';
        
        document.querySelectorAll('#modal-measure .seg-opt').forEach(btn => btn.classList.remove('active'));
        
        let instructions = "";
        let requiredPoints = 0;

        switch(mode) {
            case 'distance':
                document.getElementById('meas-dist-btn').classList.add('active');
                instructions = "Klikněte na dva body (P1 a P2) pro měření délky úsečky.";
                requiredPoints = 2;
                break;
            case 'angle':
                document.getElementById('meas-angle-btn').classList.add('active');
                instructions = "Klikněte na tři body (P1 -> P2 (vrchol) -> P3) pro měření úhlu lomu.";
                requiredPoints = 3;
                break;
            case 'cone_angle':
                document.getElementById('meas-cone-btn').classList.add('active');
                instructions = "Klikněte na libovolný bod ležící na kuželové ploše, jejíž úhel vůči ose Z chcete zjistit.";
                requiredPoints = 1;
                break;
            case 'coord':
                document.getElementById('meas-coord-btn').classList.add('active');
                instructions = "Klikněte na bod, jehož souřadnice chcete zjistit.";
                requiredPoints = 1;
                break;
        }
        
        document.getElementById('measure-instructions').innerHTML = `<span style="color:var(--btn-measure-color);">Instrukce:</span> ${instructions}`;
        document.getElementById('measure-instructions').dataset.required = requiredPoints;
    }

    function handleMeasureClick(p) {
        if (!measureMode) return;
        
        // Zabraňuje klikání na stejný bod dvakrát
        if (measurePoints.length > 0 && measurePoints[measurePoints.length - 1].x === p.x && measurePoints[measurePoints.length - 1].z === p.z) return;

        measurePoints.push(p);
        const required = parseInt(document.getElementById('measure-instructions').dataset.required);
        
        // Vykreslení vizuální zpětné vazby
        updateMeasureDisplay();

        if (measurePoints.length === required) {
            calculateMeasureResult();
        } else {
            const remaining = required - measurePoints.length;
            document.getElementById('measure-instructions').innerHTML = `<span style="color:var(--btn-measure-color);">Zbývá:</span> Klikněte na ${remaining} bod.`;
        }
    }

    function updateMeasureDisplay() {
        measureLayer.innerHTML = '';
        const clientW = svg.clientWidth || 300;
        const mmPerPx = vb.w / clientW;
        const pointRadiusMm = 5 * mmPerPx;
        
        let d = "";
        measurePoints.forEach((p, i) => {
            // Vizuální body
            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute("cx", p.x); circle.setAttribute("cy", p.z);
            circle.setAttribute("class", "measure-point");
            circle.setAttribute("r", pointRadiusMm); 
            measureLayer.appendChild(circle);

            // Čáry
            if (i === 0) d += `M ${p.x} ${p.z}`;
            else d += ` L ${p.x} ${p.z}`;
        });

        if (d) {
            const line = document.createElementNS("http://www.w3.org/2000/svg", "path");
            line.setAttribute("d", d);
            line.setAttribute("class", "measure-line");
            line.setAttribute("stroke-width", 2.5 * mmPerPx);
            measureLayer.appendChild(line);
        }
    }

    function calculateMeasureResult() {
        let output = "";
        const P = measurePoints;
        document.getElementById('measure-result').style.display = 'block';

        switch (measureMode) {
            case 'distance':
                const dx = P[1].x - P[0].x;
                const dz = P[1].z - P[0].z;
                const L = Math.sqrt(dx*dx + dz*dz);
                const dX = isDiameterMode ? dx * 2 : dx;
                
                output = `Délka úsečky (L): ${L.toFixed(3)} mm<br>`;
                output += `Delta X: ${dX.toFixed(3)} mm<br>`;
                output += `Delta Z: ${dz.toFixed(3)} mm`;
                break;

            case 'angle':
                // Vektory úseček
                const V1 = { x: P[1].x - P[0].x, z: P[1].z - P[0].z }; // P0 -> P1
                const V2 = { x: P[2].x - P[1].x, z: P[2].z - P[1].z }; // P1 -> P2
                
                // Skalární součin
                const dot = V1.x * V2.x + V1.z * V2.z;
                // Velikost vektorů
                const mag1 = Math.sqrt(V1.x*V1.x + V1.z*V1.z);
                const mag2 = Math.sqrt(V2.x*V2.x + V2.z*V2.z);

                if (mag1 === 0 || mag2 === 0) {
                     output = "Chyba: Zvolené body jsou stejné (nulová délka úsečky).";
                     break;
                }

                const cosTheta = dot / (mag1 * mag2);
                const angleRad = Math.acos(Math.max(-1, Math.min(1, cosTheta))); // Ochrana proti numerickým chybám
                const angleDeg = angleRad * (180 / Math.PI);
                
                // Úhel rozevření (180 - vnitřní úhel)
                const extAngle = 180 - angleDeg; 
                
                output = `Vnitřní úhel lomu (P0-P1-P2): ${angleDeg.toFixed(3)}°<br>`;
                output += `Vnější úhel: ${extAngle.toFixed(3)}°`;
                break;
            
            case 'cone_angle':
                const index = points.findIndex(p => p.x === P[0].x && p.z === P[0].z);
                if (index <= 0 || points[index].break) {
                    output = "Chyba: Zvolený bod není součástí úsečky, nebo je to první bod.";
                    break;
                }

                const P_current = points[index];
                let P_prev = null;
                // Najdeme předchozí bod, který není 'break'
                for(let i = index - 1; i >= 0; i--) {
                    if (!points[i].break) {
                        P_prev = points[i];
                        break;
                    }
                }

                if (!P_prev || P_prev.type !== 'line') {
                    output = "Chyba: Předchozí segment není úsečka (Linka), nelze změřit kužel.";
                    break;
                }

                // Vektor úsečky P_prev -> P_current
                const V = { x: P_current.x - P_prev.x, z: P_current.z - P_prev.z };
                
                // Úhel vektoru V vůči ose X (radiány)
                const pathAngleRad = Math.atan2(V.z, V.x); 

                // Úhel kuželu (vůči ose Z, která je 90 stupňů od osy X)
                // Úhel kuželu = Absolutní hodnota (90 stupňů - Úhel dráhy)
                let coneAngleDeg = Math.abs(90 - (pathAngleRad * (180 / Math.PI)));
                
                // Ochrana proti malým hodnotám (zaokrouhlení)
                if (Math.abs(coneAngleDeg) < 0.001) coneAngleDeg = 0;
                
                output = `Úhel dráhy (Path Angle): ${(pathAngleRad * (180 / Math.PI)).toFixed(3)}°<br>`;
                output += `Úhel Kuželu (vůči Ose Z): ${coneAngleDeg.toFixed(3)}°`;
                break;

            case 'coord':
                const dispX = isDiameterMode ? P[0].x * 2 : P[0].x;
                output = `X (${isDiameterMode ? 'Průměr' : 'Poloměr'}): ${dispX.toFixed(3)} mm<br>`;
                output += `Z (Výška): ${P[0].z.toFixed(3)} mm`;
                break;
        }

        document.getElementById('measure-output').innerHTML = output;
        measurePoints = []; // Reset pro další měření
    }

    function stopMeasure() {
        measureMode = null;
        measurePoints = [];
        measureLayer.innerHTML = '';
        closeModals();
        // Reset tlačítek měření
        document.querySelectorAll('#modal-measure .seg-opt').forEach(btn => btn.classList.remove('active'));
    }

    // --- UTILITY FUNCTIONS ---
    function centerViewOnPoint(p) {
        vb.x = p.x - vb.w / 2;
        vb.y = -p.z - vb.h / 2;
        updateViewBox();
        drawDynamicGrid();
    }

    function fitToScreen() {
        if (points.length < 2) { setHomeView(); return; }
        let minX=Infinity, maxX=-Infinity, minZ=Infinity, maxZ=-Infinity;
        points.forEach(p => {
            if(p.x < minX) minX=p.x; if(p.x > maxX) maxX=p.x;
            if(p.z < minZ) minZ=p.z; if(p.z > maxZ) maxZ=p.z;
        });
        const contentW = maxX - minX; const contentH = maxZ - minZ;
        const maxDim = Math.max(contentW, contentH);
        const pad = maxDim * 0.2 + 10;
        const newSize = maxDim + pad*2;
        vb.w = newSize; vb.h = newSize;
        vb.x = (minX + maxX)/2 - newSize/2; vb.y = -(minZ + maxZ)/2 - newSize/2;
        if(vb.w < 10) { vb.w = 50; vb.h = 50; }
        updateViewBox(); drawDynamicGrid(); updatePath(); closeModals();
    }

    function toggleDiameterMode() {
        isDiameterMode = !isDiameterMode;
        localStorage.setItem('cnc_diameter_mode', isDiameterMode);
        updateDiameterButtonText();
        drawDynamicGrid(); updatePath();
    }

    function updateDiameterButtonText() {
        const btn = document.getElementById('btn-toggle-dia');
        if(btn) btn.innerText = isDiameterMode ? "Průměr (Ø)" : "Poloměr";
    }

    function clearAll() { 
        saveHistory(); // Uložit stav před smazáním
        points = [{x: 0, z: 0, break: false, type: 'line', id: pointIdCounter++}]; 
        updatePath(); 
        closeModals(); 
        setHomeView(); // Centrovat po smazání
    }
    
    // --- OSTATNÍ FUNKCE (MODALS) ---
    function openJoypad() { document.getElementById('modal-joypad').style.display = 'flex'; }
    function closeModals() { document.querySelectorAll('.modal').forEach(m => m.style.display = 'none'); }
    
    function evaluateExpression(expression) {
        const cleanExpression = expression.replace(/,/g, '.').replace(/\s/g, '');
        if (!/^[0-9\.\+\-\*\/\(\)]+$/.test(cleanExpression)) {
            return { error: "Neplatný výraz. Použijte pouze čísla, ., +, -, *, /, ()." };
        }
        try {
            const result = new Function('return ' + cleanExpression)();
            if (typeof result !== 'number' || isNaN(result)) {
                return { error: "Vyhodnocení nevrátilo platné číslo." };
            }
            return { result: result };
        } catch (e) {
            return { error: "Chyba při vyhodnocování výrazu: " + e.message };
        }
    }
    
    function prepMove(dir) {
        currentDir = dir;
        closeModals();
        document.getElementById('modal-input').style.display = 'flex';
        document.getElementById('input-linear').style.display = 'none';
        document.getElementById('input-complex').style.display = 'none';
        document.getElementById('inp-len').value = '';
        document.getElementById('inp-x').value = ''; document.getElementById('inp-z').value = ''; 
        document.getElementById('inp-a').value = ''; 
        document.getElementById('inp-l').value = '';

        if (dir.length === 2) {
            document.getElementById('input-complex').style.display = 'block';
            document.getElementById('lbl-inp-x').innerText = isDiameterMode ? "Cílový Průměr X:" : "Cílový Poloměr X:";
            document.getElementById('input-title').innerText = "Kužel / Úkos";
            document.getElementById('inp-a').placeholder = "např. 360-45";
        } else {
            document.getElementById('input-linear').style.display = 'block';
            let txt = "Posun ";
            if(dir === 'U') txt += "Nahoru (Z+)"; if(dir === 'D') txt += "Dolů (Z-)";
            if(dir === 'L') txt += "Doleva (X-)"; if(dir === 'R') txt += "Doprava (X+)";
            document.getElementById('input-title').innerText = txt;
            document.getElementById('inp-len').focus();
        }
    }

    function commitMove() {
        saveHistory(); // Uložit historii před novou operací
        
        const last = points[points.length - 1];
        let next = { x: last.x, z: last.z, type: 'line', break: false, id: pointIdCounter++ };
        
        if (currentDir.length === 2) {
            const txStr = document.getElementById('inp-x').value.replace(',', '.');
            const tzStr = document.getElementById('inp-z').value.replace(',', '.');
            const taStr = document.getElementById('inp-a').value; 
            const lenStr = document.getElementById('inp-l').value.replace(',', '.');
            
            let angleDeg;
            if (taStr !== "") {
                const evalResult = evaluateExpression(taStr);
                if (evalResult.error) { alert("Chyba ve výrazu úhlu: " + evalResult.error); return; }
                angleDeg = evalResult.result;
                document.getElementById('inp-a').value = angleDeg.toFixed(3); 
            } else { alert("Zadejte prosím úhel."); return; }
            
            const rad = angleDeg * (Math.PI / 180);

            if(lenStr !== "") {
                const len = parseFloat(lenStr);
                const dx = len * Math.cos(rad);
                const dz = len * Math.sin(rad);
                next.x = last.x + dx;
                next.z = last.z + dz;
            } else if(tzStr !== "" && txStr === "") {
                next.z = parseFloat(tzStr);
                if(Math.abs(Math.abs(angleDeg)-90)>0.1 && Math.abs(Math.abs(angleDeg)-270)>0.1) 
                    next.x = last.x + (next.z - last.z) / Math.tan(rad);
            } else if(txStr !== "") {
                const valX = parseFloat(txStr);
                next.x = isDiameterMode ? (valX / 2) : valX; 
                next.z = last.z + (next.x - last.x) * Math.tan(rad);
            } else { 
                alert("Zadejte cíl (X, Z) nebo délku (L)!"); return; 
            }
        } else {
            const len = parseFloat(document.getElementById('inp-len').value.replace(',', '.'));
            if(isNaN(len)) return;
            if(currentDir === 'U') next.z += len;
            if(currentDir === 'D') next.z -= len;
            if(currentDir === 'L') next.x -= len; 
            if(currentDir === 'R') next.x += len; 
        }
        points.push(next); centerViewOnPoint(next); updatePath(); closeModals();
    }
    
    function openArcModal() { 
        closeModals();
        document.getElementById('modal-arc').style.display = 'flex';
        document.getElementById('lbl-arc-x').innerText = isDiameterMode ? "Koncové X (Průměr):" : "Koncové X (Poloměr):";
        
        toggleIKMode(isIncrementalIKMode);
        
        document.getElementById('arc-x').value = ''; document.getElementById('arc-z').value = ''; document.getElementById('arc-r').value = '';
        document.getElementById('center-x').value = ''; document.getElementById('center-z').value = '';
        document.getElementById('arc-cone-angle').value = '';
        
        switchArcMethod('R'); 
        document.getElementById('chk-tangent').checked = false;
        toggleTangentMode(); 
        setArcDir(true);
    }
    
    function switchArcMethod(method) {
        arcMethod = method;
        document.getElementById('tab-r').className = (method === 'R') ? 'arc-tab active' : 'arc-tab';
        document.getElementById('tab-ik').className = (method === 'IK') ? 'arc-tab active' : 'arc-tab';
        
        if (method === 'R') {
            document.getElementById('method-r').style.display = 'block';
            document.getElementById('method-ik').style.display = 'none';
        } else {
            document.getElementById('method-r').style.display = 'none';
            document.getElementById('method-ik').style.display = 'block';
            document.getElementById('chk-tangent').checked = false;
            toggleTangentMode();
            toggleIKMode(isIncrementalIKMode); 
        }
    }

    function setArcDir(cw) {
        isG2 = cw;
        document.getElementById('seg-g2').className = cw ? 'seg-opt active' : 'seg-opt';
        document.getElementById('seg-g3').className = !cw ? 'seg-opt active' : 'seg-opt';
    }

    function setTangentTarget(targetMode) {
        tangentTargetMode = targetMode;
        
        document.getElementById('target-coord-btn').classList.toggle('active', targetMode === 'coord');
        document.getElementById('target-cone-btn').classList.toggle('active', targetMode === 'cone');
        
        document.getElementById('target-coord-inputs').style.display = (targetMode === 'coord') ? 'block' : 'none';
        document.getElementById('target-cone-input').style.display = (targetMode === 'cone') ? 'block' : 'none';
        
        const btn = document.getElementById('btn-arc-ok');
        const choices = document.getElementById('tangent-choices');
        choices.style.display = 'none';
        btn.innerText = (targetMode === 'cone') ? "Vykreslit" : "Najít body";
    }

    function toggleTangentMode() {
        const isTang = document.getElementById('chk-tangent').checked;
        const selector = document.getElementById('tangent-target-selector');
        const btn = document.getElementById('btn-arc-ok');
        
        if (isTang && arcMethod === 'R') {
            selector.style.display = 'block';
            setTangentTarget(tangentTargetMode); 
        } else {
            selector.style.display = 'none';
            document.getElementById('tangent-choices').style.display = 'none';
            document.getElementById('target-coord-inputs').style.display = 'block';
            document.getElementById('target-cone-input').style.display = 'none';
            btn.innerText = "Vykreslit";
        }
    }
    
    function toggleIKMode(incremental) {
        isIncrementalIKMode = incremental;

        document.getElementById('ik-abs-btn').classList.toggle('active', !incremental);
        document.getElementById('ik-inc-btn').classList.toggle('active', incremental);
        
        const modeTextX = isDiameterMode 
            ? (incremental ? "Přírůstek I (Inkr. X Průměr):" : "Střed I (Absolutní X Průměr):")
            : (incremental ? "Přírůstek I (Inkr. X Poloměr):" : "Střed I (Absolutní X Poloměr):");
        
        const modeTextZ = incremental ? "Přírůstek K (Inkr. Z):" : "Střed K (Absolutní Z):";

        document.getElementById('lbl-center-x').innerText = modeTextX;
        document.getElementById('lbl-center-z').innerText = modeTextZ;
    }

    function commitArc() {
        saveHistory(); // Uložit historii před novou operací
        
        const xStr = document.getElementById('arc-x').value.replace(/,/, '.');
        const zStr = document.getElementById('arc-z').value.replace(/,/, '.');
        
        if (arcMethod === 'IK') {
            const cxStr = document.getElementById('center-x').value.replace(/,/, '.');
            const czStr = document.getElementById('center-z').value.replace(/,/, '.');
            
            if(!xStr || !zStr || !cxStr || !czStr) { alert("Vyplňte všechny údaje!"); return; }
            
            let ex = parseFloat(xStr);
            const ez = parseFloat(zStr);
            let rawCX = parseFloat(cxStr);
            let rawCZ = parseFloat(czStr);
            
            if(isDiameterMode) { ex = ex / 2; rawCX = rawCX / 2; }
            
            const last = points[points.length - 1];
            
            let cx, cz;
            if (isIncrementalIKMode) {
                // Inkrementální režim: I, K jsou posuny od last.x, last.z
                cx = last.x + rawCX;
                cz = last.z + rawCZ;
            } else {
                // Absolutní režim: I, K jsou absolutní souřadnice středu
                cx = rawCX;
                cz = rawCZ;
            }
            
            const rStart = Math.sqrt(Math.pow(last.x - cx, 2) + Math.pow(last.z - cz, 2));
            const rEnd = Math.sqrt(Math.pow(ex - cx, 2) + Math.pow(ez - cz, 2));
            
            if (Math.abs(rStart - rEnd) > 0.1) {
                if(!confirm("Pozor: Vzdálenost středu od startu a konce se liší o více než 0.1mm. Chcete přesto pokračovat?")) return;
            }
            
            points.push({x: ex, z: ez, type: 'arc', r: rStart, cw: isG2, break: false, cx: cx, cz: cz, id: pointIdCounter++}); // Uložení středu
            updatePath(); closeModals();
            return;
        }

        const isTang = document.getElementById('chk-tangent').checked;
        const rStr = document.getElementById('arc-r').value.replace(/,/, '.');
        
        if(!rStr) { alert("Zadejte Rádius!"); return; }
        const r = Math.abs(parseFloat(rStr));

        if(!isTang) {
            if(!xStr || !zStr) { alert("Vyplňte obě souřadnice!"); return; }
            let ex = parseFloat(xStr);
            const ez = parseFloat(zStr);
            if(isDiameterMode) ex = ex / 2;
            
            // Výpočet středu pro vykreslení
            const last = points[points.length - 1];
            const dist = Math.sqrt(Math.pow(ex - last.x, 2) + Math.pow(ez - last.z, 2));
            if (dist > 2 * r) { alert("Rádius je příliš malý na vzdálenost X/Z!"); return; }
            
            // Komplexní výpočet středu (pro Absolutní R + EndPoint)
            const midX = (last.x + ex) / 2;
            const midZ = (last.z + ez) / 2;
            const dist_mid = dist / 2;
            const h = Math.sqrt(r * r - dist_mid * dist_mid);
            const angle = Math.atan2(ez - last.z, ex - last.x);
            
            const cx1 = midX + h * Math.sin(angle);
            const cz1 = midZ - h * Math.cos(angle);
            const cx2 = midX - h * Math.sin(angle);
            const cz2 = midZ + h * Math.cos(angle);
            
            // Výběr středu: 
            const crossProduct1 = (ex - last.x) * (cz1 - last.z) - (ez - last.z) * (cx1 - last.x);
            
            let cx, cz;
            if (isG2) { // CW
                cx = (crossProduct1 < 0) ? cx1 : cx2;
                cz = (crossProduct1 < 0) ? cz1 : cz2;
            } else { // CCW
                cx = (crossProduct1 > 0) ? cx1 : cx2;
                cz = (crossProduct1 > 0) ? cz1 : cz2;
            }

            points.push({x: ex, z: ez, type: 'arc', r: r, cw: isG2, break: false, cx: cx, cz: cz, id: pointIdCounter++});
            updatePath(); closeModals();
            return;
        }

        const last = points[points.length - 1];
        if(points.length < 2 && !last.break) { alert("Nelze určit tangenci pro první bod!"); return; }
        
        let prevAngle = 0;
        const prev = points.length > 1 ? points[points.length-2] : null;
        if(points.length > 1 && !last.break) {
             const dx = last.x - prev.x;
             const dz = last.z - prev.z;
             prevAngle = Math.atan2(dz, dx);
        }

        // 1. Vypočet středu (Cx, Cz) na kolmici k příjezdové ploše (last point)
        let normAngle = isG2 ? (prevAngle - Math.PI/2) : (prevAngle + Math.PI/2);
        const cx = last.x + Math.cos(normAngle) * r;
        const cz = last.z + Math.sin(normAngle) * r;

        let candidates = [];

        if (tangentTargetMode === 'coord') {
             // LOGIKA CÍL PODLE X/Z SOUŘADNIC
            if(zStr !== "" && xStr === "") {
                const targetZ = parseFloat(zStr);
                const term = r*r - (targetZ - cz)*(targetZ - cz);
                if(term < 0) { alert("Kružnice nedosáhne na zadané Z!"); return; }
                const dx = Math.sqrt(term);
                candidates.push({x: cx + dx, z: targetZ});
                candidates.push({x: cx - dx, z: targetZ});
            } 
            else if(xStr !== "" && zStr === "") {
                let targetX = parseFloat(xStr);
                if(isDiameterMode) targetX = targetX / 2;
                const term = r*r - (targetX - cx)*(targetX - cx);
                if(term < 0) { alert("Kružnice nedosáhne na zadané X!"); return; }
                const dz = Math.sqrt(term);
                candidates.push({x: targetX, z: cz + dz});
                candidates.push({x: targetX, z: cz - dz});
            } else { alert("Pro tangenci zadejte jen JEDNU souřadnici (X nebo Z)."); return; }
        
        } else if (tangentTargetMode === 'cone') {
            // LOGIKA CÍL PODLE ÚHLU KUŽELU (OPRAVENO)
            const coneAngleStr = document.getElementById('arc-cone-angle').value;
            if (!coneAngleStr) { alert("Zadejte Úhel Kuželu."); return; }
            
            const evalResult = evaluateExpression(coneAngleStr);
            if (evalResult.error) { alert("Chyba ve výrazu úhlu: " + evalResult.error); return; }
            let coneAngleDeg = evalResult.result;
            
            // Požadovaný úhel tečny (nová úsečka) vůči X ose
            const targetPathRad = (90 - coneAngleDeg) * (Math.PI / 180);
            
            // Poloměr v cílovém bodě musí být kolmý na cílovou tečnu.
            const normAngleTarget = targetPathRad + (Math.PI / 2); 
            
            // Dva kandidáti pro bod na kružnici
            const T1_x = cx + r * Math.cos(normAngleTarget);
            const T1_z = cz + r * Math.sin(normAngleTarget);
            const T2_x = cx + r * Math.cos(normAngleTarget - Math.PI); 
            const T2_z = cz + r * Math.sin(normAngleTarget - Math.PI); 
            
            // Uložení do objektů pro snadnější manipulaci
            const T1 = {x: T1_x, z: T1_z};
            const T2 = {x: T2_x, z: T2_z};
            
            // Vektor od středu k bodu startu
            const V_center_to_Start = { x: last.x - cx, z: last.z - cz };
            
            // Vektory od středu k T1 a T2
            const V_center_to_T1 = { x: T1_x - cx, z: T1_z - cz };
            const V_center_to_T2 = { x: T2_x - cx, z: T2_z - cz };
            
            // Křížový součin: Zjistíme, který bod (T1 nebo T2) je v daném směru G2/G3
            const crossProduct1 = V_center_to_Start.x * V_center_to_T1.z - V_center_to_Start.z * V_center_to_T1.x;
            const crossProduct2 = V_center_to_Start.x * V_center_to_T2.z - V_center_to_Start.z * V_center_to_T2.x;
            
            let finalPoint;
            
            // Test rovnoběžnosti (pro 0 a 90 stupňů kuželu)
            const isVerticalCone = Math.abs(coneAngleDeg - 90) < 0.1 || Math.abs(coneAngleDeg - 270) < 0.1; // Kužel 90 (Path 0/180)

            if (isVerticalCone) {
                // Kužel 90deg (válcová plocha) => T_end musí být vodorovně se středem (Cx = Tx)
                
                // Kontrolujeme jen Z souřadnici vůči středu (Cx je fixní)
                if (isG2) { // CW
                    // Měl by jít dolů (Z-)
                    finalPoint = (T1_z < cz) ? T1 : T2; 
                } else { // CCW
                    // Měl by jít nahoru (Z+)
                    finalPoint = (T1_z > cz) ? T1 : T2; 
                }
            } else {
                // Obecný případ s křížovým součinem
                if (isG2) { // CW
                    if (crossProduct1 < 0) finalPoint = T1;
                    else finalPoint = T2;
                } else { // CCW
                    if (crossProduct1 > 0) finalPoint = T1;
                    else finalPoint = T2;
                }
            }


            // Přidáme jen jeden bod a okamžitě ho vykreslíme
            points.push({x: finalPoint.x, z: finalPoint.z, type: 'arc', r: r, cw: isG2, break: false, cx: cx, cz: cz, id: pointIdCounter++});
            updatePath();
            closeModals();
            return;
        }

        const container = document.getElementById('choices-container');
        container.innerHTML = '';
        document.getElementById('tangent-choices').style.display = 'block';
        
        candidates.forEach((c, i) => {
            const btn = document.createElement('div');
            btn.className = 'choice-btn';
            const dispX = isDiameterMode ? c.x * 2 : c.x;
            btn.innerHTML = `<span>Možnost ${i+1}</span> X:${dispX.toFixed(2)} / Z:${c.z.toFixed(2)}`;
            btn.onclick = function() {
                points.push({x: c.x, z: c.z, type: 'arc', r: r, cw: isG2, break: false, cx: cx, cz: cz, id: pointIdCounter++});
                updatePath();
                closeModals();
            };
            container.appendChild(btn);
        });
    }

    function clearAll() { 
        saveHistory(); // Uložit stav před smazáním
        points = [{x: 0, z: 0, break: false, type: 'line', id: pointIdCounter++}]; 
        updatePath(); 
        closeModals(); 
        setHomeView(); // Centrovat po smazání
    }
    
    // Nová funkce pro Undo
    function undoLastMove() {
        if (historyStack.length > 0) {
            redoStack.push(JSON.parse(JSON.stringify(points)));
            points = historyStack.pop();
            
            // Centrování na poslední bod
            const lastActiveIndex = points.length - 1;
            centerViewOnPoint(points[lastActiveIndex]);
            updatePath();
        } else if (points.length === 1) {
             // Pokud zbývá jen jeden bod, resetovat ho na [0, 0]
            redoStack.push(JSON.parse(JSON.stringify(points)));
            points = [{x: 0, z: 0, break: false, type: 'line', id: 0}];
            setHomeView();
            updatePath();
        }
        updateUndoRedoButtons();
    }
    
    function redoLastMove() {
        if (redoStack.length > 0) {
            historyStack.push(JSON.parse(JSON.stringify(points)));
            points = redoStack.pop();
            const lastActiveIndex = points.length - 1;
            centerViewOnPoint(points[lastActiveIndex]);
            updatePath();
        }
        updateUndoRedoButtons();
    }
    
    // Nově přidaná funkce
    function openStartModal() {
        closeModals();
        document.getElementById('modal-start').style.display = 'flex';
        document.getElementById('lbl-start-x').innerText = isDiameterMode ? "Start X (Průměr):" : "Start X (Poloměr):";
        document.getElementById('start-x').value = '';
        document.getElementById('start-z').value = '';
    }
    
    // Nově přidaná funkce pro confirmNewStart
    function confirmNewStart() {
        saveHistory(); // Uložit stav před novou operací
        
        let valX = parseFloat(document.getElementById('start-x').value.replace(',', '.') || '0');
        const valZ = parseFloat(document.getElementById('start-z').value.replace(',', '.') || '0');
        if(isNaN(valX) || isNaN(valZ)) { alert("Chyba zadání!"); return; }
        if(isDiameterMode) valX = valX / 2;
        
        points.push({x: valX, z: valZ, break: true, type: 'line', id: pointIdCounter++});
        
        centerViewOnPoint(points[points.length-1]);
        updatePath(); 
        closeModals();
    }


</script>
</body>
</html>
