<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Karusel CNC SmartGrid Mobile v8.53 Fixed</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root { 
            --bg-canvas: #ffffff; --bg-panel: #1e1e1e; --bg-btn: #333;
            --grid-main: #999; --grid-sub: #e0e0e0; --axis: #444; --accent: #ff6f00; --text-light: #eee;
            --c-draw: #2e7d32; --c-arc: #1565c0; --c-circle: #6a1b9a;
            --c-meas: #ef6c00; --c-util: #0097a7; --c-undo: #757575; --c-del: #d32f2f;     
        }
        
        body { 
            margin: 0; padding: 0; background: var(--bg-panel); color: var(--text-light); 
            font-family: 'Segoe UI', Roboto, sans-serif; 
            height: 100vh; width: 100vw; overflow: hidden; 
            user-select: none; -webkit-user-select: none; 
            overscroll-behavior: none; touch-action: none; 
        }
        * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }

        #app-layout { display: flex; flex-direction: column; width: 100%; height: 100%; }
        #canvas-area { flex-grow: 1; background: var(--bg-canvas); position: relative; overflow: hidden; box-shadow: 0 0 20px rgba(0,0,0,0.5); z-index: 1; touch-action: none; }
        svg { width: 100%; height: 100%; display: block; cursor: crosshair; }
        
        #panel-area { 
            flex-shrink: 0; background: var(--bg-panel); 
            padding: 8px 8px 60px 8px;
            box-shadow: 0 -4px 10px rgba(0,0,0,0.3); z-index: 10; 
            overflow-y: auto; max-height: 45vh; 
            touch-action: pan-y; 
        }
        
        .panel-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 6px; width: 100%; max-width: 700px; margin: 0 auto; }
        @media (orientation: landscape) { #app-layout { flex-direction: row; } #panel-area { width: 280px; max-height: 100%; border-left: 1px solid #444; padding-bottom: 100px; } .panel-grid { grid-template-columns: repeat(3, 1fr); } }

        .icon-btn { background: var(--bg-btn); border: none; border-radius: 10px; aspect-ratio: 1/0.9; display: flex; flex-direction: column; justify-content: center; align-items: center; cursor: pointer; color: #ccc; transition: all 0.1s; position: relative; padding: 4px; }
        .icon-btn:active { transform: scale(0.95); background: #444; }
        .icon-btn.active-mode { background: var(--c-util); color: #fff; box-shadow: inset 0 0 10px rgba(0,0,0,0.5); border: 2px solid #fff; }
        .icon-btn i { font-size: 20px; margin-bottom: 4px; } .icon-btn span { font-size: 9px; font-weight: 600; line-height: 1.1; text-align: center; }
        
        .btn-draw i { color: #4caf50; } .btn-arc i { color: #2196f3; } .btn-circ i { color: #9c27b0; } .btn-meas i { color: #ff9800; } .btn-util i { color: #00bcd4; } 
        .btn-del { background: #3e2723; border: 1px solid #4e342e; } .btn-del i { color: #ff5252; }
        .btn-disabled { opacity: 0.3; pointer-events: none; }

        #coords-hud { position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.95); padding: 6px 10px; border-radius: 8px; border: 2px solid #444; pointer-events: none; display: flex; gap: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); z-index: 20; }
        .hud-val { font-size: 1.1rem; font-weight: bold; color: #333; font-family: 'Consolas', monospace; min-width: 50px; text-align: left; }
        .hud-label { font-size: 0.9rem; color: #666; text-transform: uppercase; font-weight: 900; margin-right: 4px; }
        .hud-snap-indicator { color: red; font-weight: bold; font-size: 0.7rem; display:none; margin-left: 5px;}
        #btn-home { position: absolute; top: 10px; right: 10px; width: 40px; height: 40px; background: #fff; color: #333; border-radius: 50%; border: 2px solid #888; display: flex; justify-content: center; align-items: center; font-size: 20px; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.2); z-index: 10; }

        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 100; justify-content: center; align-items: center; backdrop-filter: blur(5px); }
        .modal-content { background: #fff; width: 90%; max-width: 350px; max-height: 90vh; border-radius: 16px; border: 1px solid #999; color: #000; display: flex; flex-direction: column; overflow: hidden; box-shadow: 0 10px 30px rgba(0,0,0,0.5); position: relative; }
        .modal-header { padding: 15px 20px 10px; border-bottom: 2px solid #eee; flex-shrink: 0; background: #fff; display: flex; justify-content: space-between; align-items: center; }
        .modal-header h3 { margin: 0; font-size: 20px; color: #000; font-weight: 800; }
        .close-icon { font-size: 24px; color: #555; cursor: pointer; padding: 0 5px; transition: color 0.2s; }
        .close-icon:hover { color: #d32f2f; }
        .modal-body { padding: 15px 20px; overflow-y: auto; flex-grow: 1; background: #fff; }
        .modal-footer { padding: 15px 20px; border-top: 2px solid #eee; background: #f8f8f8; flex-shrink: 0; }

        .segmented-control { display: flex; width: 100%; margin-bottom: 15px; border: 2px solid #666; border-radius: 8px; overflow: hidden; background: #fff; }
        .seg-opt { flex: 1; padding: 12px; text-align: center; cursor: pointer; background: #fff; color: #333; font-weight: bold; font-size: 15px; transition: 0.1s; border-right: 1px solid #ccc; }
        .seg-opt:last-child { border-right: none; }
        .seg-opt:hover { background: #eee; color: #000; }
        .seg-opt.active { background: var(--c-arc); color: #fff; text-shadow: 0 1px 1px rgba(0,0,0,0.5); }
        .mode-toggle .seg-opt.active { background: var(--c-util); } .tangent-target-toggle .seg-opt.active { background: var(--c-meas); } .circle-toggle .seg-opt.active { background: var(--c-circle); }

        input { width: 100%; padding: 12px; font-size: 20px; text-align: right; font-weight: bold; font-family: 'Consolas', monospace; border: 2px solid #777; border-radius: 6px; margin-bottom: 15px; box-sizing: border-box; background: #fff; color: #000; }
        input:focus { border-color: var(--c-arc); outline: none; background: #f0f8ff; }
        
        .joypad-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; aspect-ratio: 1/0.8; margin-top: 5px; }
        .joy-btn { background: #f0f0f0; border: 2px solid #ccc; border-radius: 8px; color: #222; display: flex; flex-direction: column; justify-content: center; align-items: center; cursor: pointer; box-shadow: 0 3px 0 #bbb; transition: 0.1s; }
        .joy-btn:active:not(.disabled) { transform: translateY(2px); box-shadow: 0 1px 0 #bbb; background: var(--accent); color: #fff; }
        .joy-btn.disabled { opacity: 0.4; cursor: default; background: #e0e0e0; border-color: #ddd; box-shadow: none; }
        .joy-arrow { font-size: 28px; line-height: 1; font-weight: bold; } .joy-desc { font-size: 10px; font-weight: 800; margin-top: 2px; }
        #btn-joy-tangent { background: #e3f2fd; border-color: #2196f3; color: #0d47a1; }
        #btn-joy-tangent.disabled { background: #f0f0f0; color: #999; border-color: #ccc; }

        .modal-btn-row { display: flex; gap: 10px; width: 100%; }
        .m-btn { flex: 1; padding: 14px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 14px; text-transform: uppercase; display: flex; align-items: center; justify-content: center; gap: 5px; }
        .m-cancel { background: #ddd; color: #000; border: 1px solid #bbb; }
        .btn-primary-arc { background: var(--c-arc); color: #fff; box-shadow: 0 3px 0 #0d47a1; }
        .btn-primary-circ { background: var(--c-circle); color: #fff; box-shadow: 0 3px 0 #4a148c; }
        .btn-primary-draw { background: var(--c-draw); color: #fff; box-shadow: 0 3px 0 #1b5e20; }
        .btn-primary-util { background: var(--c-util); color: #fff; box-shadow: 0 3px 0 #006064; }

        .chk-row { display: flex; align-items: center; margin-bottom: 15px; background: #e3f2fd; padding: 12px; border-radius: 8px; border: 2px solid #90caf9; cursor: pointer; }
        .chk-row:hover { background: #bbdefb; }
        .chk-row input { width: 24px; height: 24px; margin: 0 15px 0 0; border: 2px solid #555; }
        .chk-row label { font-weight: 800; color: #0d47a1; font-size: 15px; width: 100%; pointer-events: none; }
        .arc-tabs { display: flex; border-bottom: 3px solid #eee; margin-bottom: 20px; }
        .arc-tab { flex: 1; text-align: center; padding: 12px; cursor: pointer; font-weight: 800; font-size: 15px; color: #888; border-bottom: 3px solid transparent; margin-bottom: -3px; }
        .arc-tab.active { color: var(--c-arc); border-bottom-color: var(--c-arc); }
        .choice-btn { width: 100%; padding: 12px; margin-bottom: 8px; background: #fff8e1; border: 2px solid #ffecb3; border-radius: 6px; text-align: left; cursor: pointer; font-family: monospace; font-size: 14px; font-weight: bold; color: #000; }
        .section-label { font-size: 13px; color: #111; text-transform: uppercase; font-weight: 900; margin-bottom: 6px; display:block; letter-spacing: 0.5px; }
        .separator { width:100%; height:2px; background:#ddd; margin:15px 0; }

        .axis-line { stroke: var(--axis); stroke-width: 2px; vector-effect: non-scaling-stroke; }
        .grid-line { stroke: var(--grid-main); stroke-width: 1.5px; vector-effect: non-scaling-stroke; }
        .grid-sub-line { stroke: var(--grid-sub); stroke-width: 1px; vector-effect: non-scaling-stroke; }
        .path-draw { stroke: #00c853; fill: none; stroke-width: 3px; vector-effect: non-scaling-stroke; stroke-linecap: round; stroke-linejoin: round; }
        .point-marker { fill: #fff; stroke: var(--accent); vector-effect: non-scaling-stroke; }
        .point-current { fill: var(--accent); }
        .point-center { fill: yellow; stroke: #333; stroke-width: 1px; vector-effect: non-scaling-stroke; }
        .helper-full-circle { fill: none; stroke: rgba(0,0,0,0.4); stroke-width: 1px; stroke-dasharray: 4,4; vector-effect: non-scaling-stroke; }
        .helper-radius-line { stroke: rgba(33, 150, 243, 0.8); stroke-width: 1px; stroke-dasharray: 2,2; vector-effect: non-scaling-stroke; }
        .helper-target-tangent { stroke: #9c27b0; stroke-width: 1.5px; vector-effect: non-scaling-stroke; }
        .intersection-marker { fill: none; stroke: #666; stroke-width: 2px; vector-effect: non-scaling-stroke; opacity: 0.7; }
        .snap-highlight { fill: none; stroke: #f00; stroke-width: 3px; vector-effect: non-scaling-stroke; pointer-events: none; }
        .entity-highlight { stroke: #ff9800; stroke-width: 6px; stroke-opacity: 0.6; fill: none; vector-effect: non-scaling-stroke; pointer-events: none; }
        .line-selected { stroke: #2196f3; stroke-width: 6px; stroke-opacity: 0.8; fill: none; vector-effect: non-scaling-stroke; pointer-events: none; }
        .measure-line { stroke: #ff9800; stroke-width: 2.5px; stroke-dasharray: 8, 4; vector-effect: non-scaling-stroke; }
        .measure-point { fill: #ff9800; vector-effect: non-scaling-stroke; }
        .mobile-cursor-line { stroke: rgba(33, 150, 243, 0.6); stroke-width: 2px; vector-effect: non-scaling-stroke; stroke-dasharray: 4,4; pointer-events: none; }
        .mobile-cursor-crosshair { stroke: #d32f2f; stroke-width: 2px; vector-effect: non-scaling-stroke; pointer-events: none; }
        .mobile-finger-pos { fill: rgba(33, 150, 243, 0.3); stroke: #2196f3; stroke-width: 2px; vector-effect: non-scaling-stroke; pointer-events: none; }
        .click-area { fill: rgba(255,255,255,0.01); stroke: transparent; cursor: pointer; }
        text { paint-order: stroke; stroke: rgba(255,255,255,0.8); stroke-width: 4px; stroke-linejoin: round; }
    </style>
</head>
<body oncontextmenu="return false;">

<div id="app-layout">
    <div id="canvas-area">
        <svg id="svgCanvas" preserveAspectRatio="xMidYMid slice">
            <g id="worldGroup" transform="scale(1, -1)">
                <g id="gridLines"></g> <g id="axisGroup"></g> 
                <g id="pathGroup"></g> <g id="intersectionGroup"></g>
                <g id="measureLayer"></g> <g id="snapCursorGroup"></g> 
            </g>
            <g id="mobileCursorGroup"></g>
            <g id="textGroup"></g>
        </svg>
        <div id="coords-hud">
            <div><span class="hud-label">X</span><span class="hud-val" id="hud-x">0.00</span></div>
            <div style="width:1px; background:#999;"></div>
            <div><span class="hud-label">Z</span><span class="hud-val" id="hud-z">0.00</span></div>
            <div id="hud-snap-info" class="hud-snap-indicator">SNAP</div>
        </div>
        <div id="btn-home" onclick="setHomeView()" title="Reset"><i class="fas fa-home"></i></div>
    </div>

    <div id="panel-area">
        <div class="panel-grid">
            <!-- 5 TLAČÍTEK V ŘADĚ -->
            <button class="icon-btn btn-draw" onclick="openJoypad()"><i class="fas fa-minus" style="transform: rotate(-45deg)"></i><span>Linka</span></button>
            <button class="icon-btn btn-arc" onclick="openArcModal()"><i class="fas fa-bezier-curve"></i><span>Rádius</span></button>
            <button class="icon-btn btn-circ" onclick="openCircleModal()"><i class="fas fa-circle-notch"></i><span>Kruh</span></button>
            <button class="icon-btn btn-meas" onclick="openMeasureModal()"><i class="fas fa-ruler-combined"></i><span>Měřit</span></button>
            <button class="icon-btn btn-util" onclick="fitToScreen()"><i class="fas fa-compress-arrows-alt"></i><span>Centrovat</span></button>
            
            <button id="btn-toggle-dia" class="icon-btn btn-util" onclick="toggleDiameterMode()"><i class="fas fa-expand-arrows-alt"></i><span>Ø Průměr</span></button>
            <button id="btn-start-pick" class="icon-btn btn-util" onclick="toggleStartPick()"><i class="fas fa-pen-nib"></i><span>Start Bod</span></button>
            <button id="btn-undo" class="icon-btn btn-disabled" onclick="undoLastMove()"><i class="fas fa-undo"></i><span>Zpět</span></button>
            <button id="btn-redo" class="icon-btn btn-disabled" onclick="redoLastMove()"><i class="fas fa-redo"></i><span>Vpřed</span></button>
            <button class="icon-btn btn-del" onclick="confirmClearAll()"><i class="fas fa-trash-alt"></i><span>Smazat</span></button>
        </div>
        <div style="margin-top:15px; text-align:center; font-size:10px; color:#555;">v8.53 Fixed (MeasureFix + BackTangent)</div>
    </div>
</div>

<!-- MODALS -->
<div id="modal-joypad" class="modal">
    <div class="modal-content">
        <div class="modal-header"><h3>Vyberte směr</h3><span class="close-icon" onclick="closeModals()"><i class="fas fa-times"></i></span></div>
        <div class="modal-body">
            <div class="joypad-grid">
                <div class="joy-btn" onclick="prepMove('UL')"><span class="joy-arrow">↖</span><span class="joy-desc">Kužel</span></div>
                <div class="joy-btn" onclick="prepMove('U')"><span class="joy-arrow">⬆</span><span class="joy-desc">Z+</span></div>
                <div class="joy-btn" onclick="prepMove('UR')"><span class="joy-arrow">↗</span><span class="joy-desc">Kužel</span></div>
                <div class="joy-btn" onclick="prepMove('L')"><span class="joy-arrow">⬅</span><span class="joy-desc">X-</span></div>
                <div id="btn-joy-tangent" class="joy-btn" onclick="prepMove('TANGENT')"><span class="joy-arrow" style="font-size:18px;">⤤</span><span class="joy-desc">TEČNA</span></div>
                <div class="joy-btn" onclick="prepMove('R')"><span class="joy-arrow">➡</span><span class="joy-desc">X+</span></div>
                <div class="joy-btn" onclick="prepMove('DL')"><span class="joy-arrow">↙</span><span class="joy-desc">Kužel</span></div>
                <div class="joy-btn" onclick="prepMove('D')"><span class="joy-arrow">⬇</span><span class="joy-desc">Z-</span></div>
                <div class="joy-btn" onclick="prepMove('DR')"><span class="joy-arrow">↘</span><span class="joy-desc">Kužel</span></div>
            </div>
        </div>
    </div>
</div>

<div id="modal-input" class="modal">
    <div class="modal-content">
        <div class="modal-header"><h3 id="input-title">Parametry pohybu</h3><span class="close-icon" onclick="closeModals()"><i class="fas fa-times"></i></span></div>
        <div class="modal-body">
            <label class="section-label">Délka pohybu (mm):</label><input type="number" id="inp-len" placeholder="Např. 50" inputmode="decimal">
            <div class="separator"></div>
            <label class="section-label" style="color:#0097a7">Cílové souřadnice:</label>
            <label id="lbl-inp-x" class="section-label">Cílové X:</label><input type="number" id="inp-x" placeholder="Prázdné = beze změny" inputmode="decimal">
            <label class="section-label">Cílové Z:</label><input type="number" id="inp-z" placeholder="Prázdné = beze změny" inputmode="decimal">
            <div class="separator"></div>
            <label class="section-label" style="color:#ef6c00">Polární zadání (Kužel):</label>
            <label class="section-label">Úhel (°):</label><input type="number" id="inp-angle" placeholder="Úhel sklonu" inputmode="decimal">
            <div class="chk-row" style="margin-top:5px;" onclick="document.getElementById('chk-rel-angle').click();"><input type="checkbox" id="chk-rel-angle" onclick="event.stopPropagation()"><label for="chk-rel-angle">Úhel od předchozí čáry</label></div>
        </div>
        <div class="modal-footer"><div class="modal-btn-row"><button class="m-btn m-cancel" onclick="openJoypad()">Zpět</button><button class="m-btn btn-primary-draw" onclick="commitMove()">Vypočítat</button></div></div>
    </div>
</div>

<div id="modal-arc" class="modal"><div class="modal-content"><div class="modal-header"><h3>Radius</h3><span class="close-icon" onclick="closeModals()"><i class="fas fa-times"></i></span><div class="arc-tabs"><div class="arc-tab active" id="tab-r" onclick="switchArcMethod('R')">Rádius</div><div class="arc-tab" id="tab-ik" onclick="switchArcMethod('IK')">Střed</div></div></div><div class="modal-body"><div class="segmented-control"><div class="seg-opt active" id="seg-g2" onclick="setArcDir(true)">G2</div><div class="seg-opt" id="seg-g3" onclick="setArcDir(false)">G3</div></div><div id="method-r">
    <div class="chk-row" id="row-chk-tangent" onclick="document.getElementById('chk-tangent').click();"><input type="checkbox" id="chk-tangent" onchange="toggleTangentMode()" onclick="event.stopPropagation()"><label for="chk-tangent">Tangenciální napojení (Vpřed)</label></div>
    <div class="chk-row" id="row-chk-back-tangent" onclick="document.getElementById('chk-back-tangent').click();" style="background:#fff3e0; border-color:#ffe0b2;"><input type="checkbox" id="chk-back-tangent" onchange="toggleBackTangentMode()" onclick="event.stopPropagation()"><label for="chk-back-tangent" style="color:#e65100;">Zpětná tangenta (Upravit start)</label></div>
    <label class="section-label">Rádius:</label><input type="number" id="arc-r"></div><div id="method-ik" style="display:none;"><div class="segmented-control mode-toggle"><div class="seg-opt active" id="ik-abs-btn" onclick="toggleIKMode(false)">Absolutní</div><div class="seg-opt" id="ik-inc-btn" onclick="toggleIKMode(true)">Přírůstkové</div></div><label class="section-label">Střed I:</label><input type="number" id="center-x"><label class="section-label">Střed K:</label><input type="number" id="center-z"><div class="separator"></div><label class="section-label">Cíl X:</label><input type="number" id="ik-target-x"><label class="section-label">Cíl Z:</label><input type="number" id="ik-target-z"><label class="section-label">Úhel:</label><input type="number" id="ik-target-angle"><div class="chk-row"><input type="checkbox" id="chk-ik-long-arc"><label for="chk-ik-long-arc">Delší oblouk</label></div></div><div id="arc-targets"><div id="tangent-target-selector" style="display:none;"><label class="section-label">Cíl:</label><div class="segmented-control tangent-target-toggle"><div class="seg-opt active" id="target-coord-btn" onclick="setTangentTarget('coord')">X / Z</div><div class="seg-opt" id="target-cone-btn" onclick="setTangentTarget('cone')">Úhel</div></div></div><div id="target-coord-inputs"><label id="lbl-arc-x" class="section-label">X:</label><input type="number" id="arc-x"><label class="section-label">Z:</label><input type="number" id="arc-z"></div><div id="target-cone-input" style="display:none;"><label class="section-label">Úhel (°):</label><input type="text" id="arc-cone-angle"></div></div><div id="tangent-choices" style="display:none;"><div id="choices-container"></div></div></div><div class="modal-footer"><div class="modal-btn-row"><button class="m-btn m-cancel" onclick="closeModals()">Zrušit</button><button id="btn-arc-ok" class="m-btn btn-primary-arc" onclick="commitArc()">Vykreslit</button></div></div></div></div>

<div id="modal-circle" class="modal">
    <div class="modal-content">
        <div class="modal-header"><h3>Celá Kružnice</h3><span class="close-icon" onclick="closeModals()"><i class="fas fa-times"></i></span></div>
        <div class="modal-body">
            <label class="section-label">Velikost zadat jako:</label>
            <div class="segmented-control circle-toggle">
                <div class="seg-opt active" id="circ-rad-btn" onclick="setCircleMode('R')">Rádius (R)</div>
                <div class="seg-opt" id="circ-dia-btn" onclick="setCircleMode('D')">Průměr (D)</div>
            </div>
            <label id="lbl-circ-val" class="section-label">Hodnota R:</label>
            <input type="number" id="circ-val" placeholder="Zadejte velikost" inputmode="decimal">
            <div class="separator"></div>
            <label class="section-label" style="color:#6a1b9a">Souřadnice Středu:</label>
            <label id="lbl-circ-cx" class="section-label">Střed X:</label><input type="number" id="circ-cx" placeholder="Absolutní X" inputmode="decimal">
            <label class="section-label">Střed Z:</label><input type="number" id="circ-cz" placeholder="Absolutní Z" inputmode="decimal">
        </div>
        <div class="modal-footer">
            <div class="modal-btn-row"><button class="m-btn m-cancel" onclick="closeModals()">Zrušit</button><button class="m-btn btn-primary-circ" onclick="commitCircle()">Vykreslit</button></div>
        </div>
    </div>
</div>

<div id="modal-start" class="modal">
    <div class="modal-content">
        <div class="modal-header"><h3>Nový Bod</h3><span class="close-icon" onclick="closeModals()"><i class="fas fa-times"></i></span></div>
        <div class="modal-body">
            <p style="font-size:12px; color:#444; margin-bottom:10px; text-align:center;">Vybrané souřadnice:</p>
            <label id="lbl-start-x" class="section-label">X:</label><input type="number" id="start-x" inputmode="decimal">
            <label class="section-label">Z:</label><input type="number" id="start-z" inputmode="decimal">
            <div class="separator"></div>
            <label class="section-label">Co udělat dál?</label>
        </div>
        <div class="modal-footer">
             <div class="modal-btn-row" style="flex-wrap:wrap;">
                <button class="m-btn btn-primary-util" style="background:#757575;" onclick="actionMoveOnly()"><i class="fas fa-map-marker-alt"></i> Jen Bod</button>
                <button class="m-btn btn-primary-draw" onclick="actionMoveAndLine()"><i class="fas fa-minus" style="transform:rotate(-45deg);"></i> Linka</button>
                <button class="m-btn btn-primary-circ" onclick="actionCircleCenter()"><i class="fas fa-circle-notch"></i> Kruh</button>
             </div>
        </div>
    </div>
</div>

<div id="modal-measure" class="modal">
    <div class="modal-content">
        <div class="modal-header"><h3>Měření</h3><span class="close-icon" onclick="closeModals()"><i class="fas fa-times"></i></span></div>
        <div class="modal-body">
            <div class="segmented-control" style="border-color:var(--c-meas);">
                <div class="seg-opt active" id="meas-dist-btn" onclick="selectMeasure('distance')" style="background:var(--c-meas);color:white;">Délka</div>
                <div class="seg-opt" id="meas-angle-btn" onclick="selectMeasure('angle')">Úhel</div>
                <div class="seg-opt" id="meas-coord-btn" onclick="selectMeasure('radius')">Rádius</div>
            </div>
            <p id="measure-instructions" style="text-align:center;font-weight:bold;">Vyberte nástroj a označte prvek v mapě.</p>
            <div id="measure-result" style="display:none;padding:10px;background:#fff3e0;margin-top:10px;border-radius:4px;"><div id="measure-output" style="font-family:monospace;font-size:14px;font-weight:bold;"></div></div>
        </div>
        <div class="modal-footer"><div class="modal-btn-row"><button class="m-btn m-cancel" onclick="stopMeasure()">Ukončit</button></div></div>
    </div>
</div>

<script>
    const $ = function(id) { return document.getElementById(id); };
    const svg = $('svgCanvas');
    const gridLines = $('gridLines');
    const textGroup = $('textGroup');
    const pathGroup = $('pathGroup');
    const axisGroup = $('axisGroup');
    const measureLayer = $('measureLayer');
    const intersectGrp = $('intersectionGroup');
    const snapGrp = $('snapCursorGroup');
    const mobCursorGrp = $('mobileCursorGroup');
    
    let points = [{x: 0, z: 0, break: false, type: 'line', id: 0}]; 
    let historyStack = [];
    let redoStack = []; 
    let pointIdCounter = 1;
    let currentDir = '';
    let isG2 = true;
    let arcMethod = 'R';
    let isIncrementalIKMode = false;
    let tangentTargetMode = 'cone';
    let measureMode = null; 
    let circleInputMode = 'R';
    let pickingStartPoint = false;
    let measurePoints = [];
    let activeIntersections = [];
    let lastVirtualSnap = null;
    let vb = { x: -50, y: -600, w: 800, h: 800 };
    let measureLineBuffer = null;
    const TOUCH_OFFSET_Y = 100;
    let isDiameterMode = true;
    if (localStorage.getItem('cnc_diameter_mode') === 'false') {
        isDiameterMode = false;
    }
    
    let longPressTimer = null;
    let isLongPressActive = false;
    const LONG_PRESS_DURATION = 600;
    
    let initialPinchDist = 0;
    let initialVbW = 0;
    let initialVbH = 0;

    function svgEl(tag, attrs) {
        const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
        for (let k in attrs) {
            if (k === 'textContent') {
                el.textContent = attrs[k];
            } else {
                el.setAttribute(k, attrs[k]);
            }
        }
        return el;
    }
    
    function dist(p1, p2) {
        return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.z - p1.z, 2));
    }

    function getClosestOnSeg(pWorld, p1, p2) {
        if (p2.type !== 'arc') {
            const dx = p2.x - p1.x;
            const dz = p2.z - p1.z;
            const l2 = dx * dx + dz * dz;
            if (l2 === 0) {
                return { x: p1.x, z: p1.z, dist: dist(pWorld, p1) };
            }
            let t = ((pWorld.x - p1.x) * dx + (pWorld.z - p1.z) * dz) / l2;
            if (t < 0) t = 0;
            if (t > 1) t = 1;
            const px = p1.x + t * dx;
            const pz = p1.z + t * dz;
            return { x: px, z: pz, dist: dist(pWorld, { x: px, z: pz }) };
        } else {
            const cx = p2.cx;
            const cz = p2.cz;
            const r = p2.r;
            const dx = pWorld.x - cx;
            const dz = pWorld.z - cz;
            const dCenter = Math.sqrt(dx * dx + dz * dz);
            
            const px = cx + (dx / dCenter) * r;
            const pz = cz + (dz / dCenter) * r;
            
            const aStart = Math.atan2(p1.z - cz, p1.x - cx);
            const aEnd = Math.atan2(p2.z - cz, p2.x - cx);
            const aP = Math.atan2(pz - cz, px - cx);
            
            let sweep = aEnd - aStart;
            let sweepP = aP - aStart;
            
            if (p2.cw) {
                if (sweep > 0) sweep -= 2 * Math.PI;
                if (sweepP > 0) sweepP -= 2 * Math.PI;
            } else {
                if (sweep < 0) sweep += 2 * Math.PI;
                if (sweepP < 0) sweepP += 2 * Math.PI;
            }
            
            let onArc = false;
            if (p2.cw) {
                if (sweepP <= 0 && sweepP >= sweep) onArc = true;
            } else {
                if (sweepP >= 0 && sweepP <= sweep) onArc = true;
            }
            
            if (onArc) {
                return { x: px, z: pz, dist: Math.abs(dCenter - r) };
            }
            return { dist: Infinity };
        }
    }

    function updateHistoryState() {
        $('btn-undo').classList.toggle('btn-disabled', !historyStack.length);
        $('btn-redo').classList.toggle('btn-disabled', !redoStack.length);
    }

    function saveHistory() {
        if (points.length && (historyStack.length === 0 || JSON.stringify(historyStack[historyStack.length - 1]) !== JSON.stringify(points))) {
            historyStack.push(JSON.parse(JSON.stringify(points)));
            redoStack = []; updateHistoryState();
        }
    }

    function undoLastMove() {
        if (!historyStack.length) {
            if (points.length > 1) {
                redoStack.push(JSON.parse(JSON.stringify(points)));
                points = points.slice(0, 1);
                setHomeView(); updatePath();
            }
            return;
        }
        redoStack.push(JSON.parse(JSON.stringify(points)));
        points = historyStack.pop();
        centerViewOnPoint(points[points.length - 1]);
        updatePath(); updateHistoryState();
    }

    function redoLastMove() {
        if (!redoStack.length) return;
        historyStack.push(JSON.parse(JSON.stringify(points)));
        points = redoStack.pop();
        centerViewOnPoint(points[points.length - 1]);
        updatePath(); updateHistoryState();
    }

    function handleResize() {
        if ($('canvas-area').clientWidth) {
            vb.h = vb.w;
            updateViewBox();
            drawDynamicGrid();
            updatePath();
        }
    }

    function setHomeView() {
        vb.w = 800; 
        vb.h = 800; 
        vb.y = -600; 
        vb.x = -50; 
        updateViewBox(); 
        drawDynamicGrid(); 
        updatePath();
    }

    function updateViewBox() {
        svg.setAttribute('viewBox', vb.x + " " + vb.y + " " + vb.w + " " + vb.h);
    }

    function centerViewOnPoint(p) {
        vb.x = p.x - vb.w / 2;
        vb.y = -p.z - vb.h / 2;
        updateViewBox(); drawDynamicGrid();
    }

    function fitToScreen() {
        if (points.length < 2) { setHomeView(); return; }
        let b = { minX: Infinity, maxX: -Infinity, minZ: Infinity, maxZ: -Infinity };
        for(let i=0; i<points.length; i++) {
            let p = points[i];
            b.minX = Math.min(b.minX, p.x);
            b.maxX = Math.max(b.maxX, p.x);
            b.minZ = Math.min(b.minZ, p.z);
            b.maxZ = Math.max(b.maxZ, p.z);
        }
        const s = Math.max(b.maxX - b.minX, b.maxZ - b.minZ) * 1.4 || 50;
        vb.w = s; vb.h = s;
        vb.x = (b.minX + b.maxX) / 2 - s / 2;
        vb.y = -(b.minZ + b.maxZ) / 2 - s / 2;
        updateViewBox(); drawDynamicGrid(); updatePath(); closeModals();
    }

    function drawDynamicGrid() {
        if (!svg.clientWidth) return;
        gridLines.innerHTML = '';
        textGroup.innerHTML = '';
        axisGroup.innerHTML = '';
        
        let stepPow = Math.pow(10, Math.floor(Math.log10(vb.w / 5)));
        let step = stepPow;
        if (vb.w / 5 / stepPow < 2) step = 1 * stepPow;
        else if (vb.w / 5 / stepPow < 5) step = 2 * stepPow;
        else step = 5 * stepPow;
        
        const subStep = step / 5;
        const fs = Math.max(vb.w / 32, step / 3.5);

        axisGroup.appendChild(svgEl("line", { x1: -100000, y1: 0, x2: 100000, y2: 0, class: 'axis-line' }));
        axisGroup.appendChild(svgEl("line", { x1: 0, y1: -100000, x2: 0, y2: 100000, class: 'axis-line' }));

        const sX = Math.floor(vb.x / step) * step;
        const eX = vb.x + vb.w;
        
        for (let v = sX; v < eX + step; v += step) {
            if (v > eX) break;
            gridLines.appendChild(svgEl("line", { x1: v, y1: -(vb.y + vb.h), x2: v, y2: -vb.y, class: 'grid-line' }));
            for (let i = 1; i < 5; i++) {
                const sv = v + subStep * i;
                if (sv < eX) {
                    gridLines.appendChild(svgEl("line", { x1: sv, y1: -(vb.y + vb.h), x2: sv, y2: -vb.y, class: 'grid-sub-line' }));
                }
            }
            if (Math.abs(v) > step / 100) {
                let tVal = isDiameterMode ? v * 2 : v;
                let dec = (step < 1) ? Math.ceil(-Math.log10(step)) : 0;
                const tX = v;
                const tY = Math.min(0, vb.y + vb.h - fs * 4.5) + ((Math.round(v / step) % 2 !== 0) ? fs * 1.2 : 0);
                textGroup.appendChild(svgEl("text", { x: tX, y: tY, fill: "#222", "font-size": fs, "text-anchor": "middle", "dominant-baseline": "auto", textContent: tVal.toFixed(dec) }));
            }
        }

        const sZ = Math.floor(-(vb.y + vb.h) / step) * step;
        const eZ = -vb.y;
        
        for (let v = sZ; v < eZ + step; v += step) {
            gridLines.appendChild(svgEl("line", { x1: vb.x, y1: v, x2: vb.x + vb.w, y2: v, class: 'grid-line' }));
            for (let i = 1; i < 5; i++) {
                const sv = v + subStep * i;
                if (sv < eZ) gridLines.appendChild(svgEl("line", { x1: vb.x, y1: sv, x2: vb.x + vb.w, y2: sv, class: 'grid-sub-line' }));
            }
            if (Math.abs(v) > step / 100) {
                let dec = (step < 1) ? Math.ceil(-Math.log10(step)) : 0;
                let tX = Math.max(vb.x + fs * 4.5, Math.min(vb.x + vb.w - fs * 4, -fs));
                let anch = "end";
                if (Math.abs(tX - (vb.x + fs * 4.5)) < fs * 1.0) anch = "start";
                textGroup.appendChild(svgEl("text", { x: tX, y: -v, fill: "#222", "font-size": fs, "text-anchor": anch, "dominant-baseline": "middle", textContent: v.toFixed(dec) }));
            }
        }
    }

    function handleMouseSnap(p) {
        if (isDragging && !isTouch && !isLongPressActive) { snapGrp.innerHTML = ''; return null; }

        let c = null;
        let md = 15 * (vb.w / svg.clientWidth);
        const pWorld = { x: p.x, z: -p.y };

        let allTargets = [];
        for (let i = 0; i < activeIntersections.length; i++) {
             allTargets.push({ x: activeIntersections[i].x, z: activeIntersections[i].z, type: 'intersection' });
        }
        for (let i = 0; i < points.length; i++) {
             if (points[i].type !== 'arc') {
                 allTargets.push({ x: points[i].x, z: points[i].z, type: 'point' });
             } else {
                 allTargets.push({ x: points[i].x, z: points[i].z, type: 'point' });
                 allTargets.push({ x: points[i].cx, z: points[i].cz, type: 'center' });
             }
        }

        for (let i = 0; i < allTargets.length; i++) {
            const t = allTargets[i];
            const d = dist(pWorld, t);
            if (d < md) {
                md = d;
                c = t;
            }
        }

        const hX = $('hud-x');
        const hZ = $('hud-z');
        const hS = $('hud-snap-info');
        snapGrp.innerHTML = '';

        if (c) {
            let dispX = isDiameterMode ? c.x * 2 : c.x;
            hX.innerText = dispX.toFixed(3);
            hX.style.color = "red";
            hZ.innerText = c.z.toFixed(3);
            hZ.style.color = "red";
            hS.style.display = 'block';
            let typeText = "BOD";
            if (c.type === 'center') typeText = "STŘED";
            if (c.type === 'intersection') typeText = "PRŮSEČÍK";
            hS.innerText = typeText;
            const s = 20 * (vb.w / svg.clientWidth);
            snapGrp.appendChild(svgEl("path", { d: `M ${c.x - s / 2} ${c.z} L ${c.x + s / 2} ${c.z} M ${c.x} ${c.z - s / 2} L ${c.x} ${c.z + s / 2}`, class: "snap-highlight" }));
            return c;
        }

        let bestSeg = null;
        let segMd = 20 * (vb.w / svg.clientWidth);

        for (let i = 0; i < points.length - 1; i++) {
            const p1 = points[i];
            const p2 = points[i + 1];
            if (p2.break) continue;
            if (measureMode === 'radius' && p2.type !== 'arc') continue;

            const snap = getClosestOnSeg(pWorld, p1, p2);
            if (snap.dist < segMd) {
                segMd = snap.dist;
                bestSeg = { x: snap.x, z: snap.z, index: i, p2: p2 };
            }
        }

        if (bestSeg) {
            let dispX = isDiameterMode ? bestSeg.x * 2 : bestSeg.x;
            hX.innerText = dispX.toFixed(3);
            hX.style.color = "orange";
            hZ.innerText = bestSeg.z.toFixed(3);
            hZ.style.color = "orange";
            hS.style.display = 'block';
            hS.innerText = measureMode === 'radius' ? "NA OBLOUKU" : "NA ÚSEČCE";

            const s = 15 * (vb.w / svg.clientWidth);
            snapGrp.appendChild(svgEl("path", { d: `M ${bestSeg.x - s / 2} ${bestSeg.z} L ${bestSeg.x + s / 2} ${bestSeg.z} M ${bestSeg.x} ${bestSeg.z - s / 2} L ${bestSeg.x} ${bestSeg.z + s / 2}`, class: "snap-highlight", stroke: "orange" }));

            if (measureMode === 'distance' || measureMode === 'radius' || measureMode === 'angle') {
                const p1 = points[bestSeg.index];
                const p2 = points[bestSeg.index + 1];
                let dp = "";
                if (p2.type === 'arc') {
                    dp = `M ${p1.x} ${p1.z} A ${p2.r} ${p2.r} 0 0 ${p2.cw ? 0 : 1} ${p2.x} ${p2.z}`;
                } else {
                    dp = `M ${p1.x} ${p1.z} L ${p2.x} ${p2.z}`;
                }
                snapGrp.appendChild(svgEl("path", { d: dp, class: "entity-highlight" }));
            }
            return { x: bestSeg.x, z: bestSeg.z, type: 'segment_stick', index: bestSeg.index };
        }

        hX.style.color = "#444";
        hZ.style.color = "#444";
        hS.style.display = 'none';
        let dX = isDiameterMode ? pWorld.x * 2 : pWorld.x;
        hX.innerText = dX.toFixed(2);
        hZ.innerText = pWorld.z.toFixed(2);
        return { x: pWorld.x, z: pWorld.z };
    }

    // --- MOVED FUNCTION TO TOP SCOPE FOR SAFETY ---
    function updateMeasureDisplay() {
        measureLayer.innerHTML = '';
        if (!measurePoints.length) return;
        
        const s = vb.w / svg.clientWidth;
        const r = 5 * s;

        for (let i = 0; i < measurePoints.length; i++) {
            const p = measurePoints[i];
            measureLayer.appendChild(svgEl("circle", { 
                cx: p.x, cy: p.z, r: r, 
                class: "measure-point" 
            }));
        }
        
        for (let i = 0; i < measurePoints.length - 1; i++) {
             const p1 = measurePoints[i];
             const p2 = measurePoints[i+1];
             measureLayer.appendChild(svgEl("line", { 
                 x1: p1.x, y1: p1.z, x2: p2.x, y2: p2.z, 
                 class: "measure-line"
             }));
        }
    }

    function updatePath() {
        pathGroup.innerHTML = '';
        intersectGrp.innerHTML = '';
        measureLayer.innerHTML = '';
        
        activeIntersections = [];
        for (let i = 0; i < points.length - 1; i++) {
            for (let j = i + 1; j < points.length - 1; j++) {
                const s1p1 = points[i];
                const s1p2 = points[i + 1];
                const s2p1 = points[j];
                const s2p2 = points[j + 1];

                if (s1p2.break || s2p2.break || s1p2 === s2p1 || s1p1 === s2p2) continue;

                if (s1p2.type !== 'arc' && s2p2.type !== 'arc') {
                    const d = (s1p2.z - s1p1.z) * (s2p1.x - s2p2.x) - (s1p1.x - s1p2.x) * (s2p2.z - s2p1.z);
                    if (Math.abs(d) > 1e-4) {
                        const x = ((s1p2.x * s1p1.z - s1p1.x * s1p2.z) * (s2p1.x - s2p2.x) - (s1p2.x - s1p1.x) * (s2p1.x * s2p2.z - s2p2.x * s2p1.z)) / d;
                        const z = ((s1p2.x * s1p1.z - s1p1.x * s1p2.z) * (s2p1.z - s2p2.z) - (s1p2.z - s1p1.z) * (s2p1.x * s2p2.z - s2p2.x * s2p1.z)) / d;
                        const onSeg1 = x >= Math.min(s1p1.x, s1p2.x) - 0.001 && x <= Math.max(s1p1.x, s1p2.x) + 0.001 && z >= Math.min(s1p1.z, s1p2.z) - 0.001 && z <= Math.max(s1p1.z, s1p2.z) + 0.001;
                        const onSeg2 = x >= Math.min(s2p1.x, s2p2.x) - 0.001 && x <= Math.max(s2p1.x, s2p2.x) + 0.001 && z >= Math.min(s2p1.z, s2p2.z) - 0.001 && z <= Math.max(s2p1.z, s2p2.z) + 0.001;
                        if (onSeg1 && onSeg2) {
                            activeIntersections.push({ x: x, z: z });
                        }
                    }
                }
            }
        }

        if (points.length === 0) return;
        const l = points[points.length - 1];
        let lX = isDiameterMode ? l.x * 2 : l.x;
        $('hud-x').innerText = lX.toFixed(2);
        $('hud-z').innerText = l.z.toFixed(2);
        const s = vb.w / svg.clientWidth;
        const pr = 6 * s;
        const cr = 15 * s;

        for (let i = 0; i < activeIntersections.length; i++) {
            const p = activeIntersections[i];
            const size = 10 * s;
            intersectGrp.appendChild(svgEl("path", { d: `M ${p.x - size} ${p.z - size} L ${p.x + size} ${p.z + size} M ${p.x - size} ${p.z + size} L ${p.x + size} ${p.z - size}`, class: "intersection-marker" }));
        }

        let d = "";
        for (let i = 0; i < points.length; i++) {
            const p = points[i];
            let cls = "point-marker";
            if (i === points.length - 1) cls += " point-current";
            
            pathGroup.appendChild(svgEl("circle", { cx: p.x, cy: p.z, r: pr, class: cls }));
            const h = svgEl("circle", { cx: p.x, cy: p.z, r: cr, class: "click-area" });
            h.onclick = function() { onPointClick(i); };
            pathGroup.appendChild(h);

            if (p.type === 'arc') {
                pathGroup.appendChild(svgEl("circle", { cx: p.cx, cy: p.cz, r: pr, class: "point-center" }));
                pathGroup.appendChild(svgEl("circle", { cx: p.cx, cy: p.cz, r: p.r, class: "helper-full-circle" }));
                pathGroup.appendChild(svgEl("line", { x1: p.cx, y1: p.cz, x2: p.x, y2: p.z, class: "helper-radius-line" }));
                const ch = svgEl("circle", { cx: p.cx, cy: p.cz, r: cr * 1.5, class: "click-area" });
                ch.onclick = function() { onCenterClick(p.cx, p.cz); };
                pathGroup.appendChild(ch);
            }
            
            if (i === 0) {
                d += `M ${p.x} ${p.z}`;
            } else {
                if (p.break) {
                    d += ` M ${p.x} ${p.z}`;
                } else if (p.type === 'arc') {
                    // FIX: Vypočítat, zda je třeba vykreslit velký oblouk (largeArc)
                    const prev = points[i - 1];
                    const angStart = Math.atan2(prev.z - p.cz, prev.x - p.cx);
                    const angEnd = Math.atan2(p.z - p.cz, p.x - p.cx);
                    let sweepDiff = angEnd - angStart;
                    if (p.cw) { 
                        if (sweepDiff > 0) sweepDiff -= 2 * Math.PI; 
                    } else { 
                        if (sweepDiff < 0) sweepDiff += 2 * Math.PI; 
                    }
                    const largeArcFlag = Math.abs(sweepDiff) > Math.PI ? 1 : 0;
                    const sweepFlag = p.cw ? 0 : 1;
                    
                    d += ` A ${p.r} ${p.r} 0 ${largeArcFlag} ${sweepFlag} ${p.x} ${p.z}`;
                } else {
                    d += ` L ${p.x} ${p.z}`;
                }
            }
        }
        pathGroup.appendChild(svgEl("path", { d: d, class: "path-draw" }));
        
        if (measureMode) updateMeasureDisplay();
        if (measureMode === 'angle' && measureLineBuffer) {
            const p1 = points[measureLineBuffer.index];
            const p2 = points[measureLineBuffer.index + 1];
            let dp = "";
            if (p2.type === 'arc') {
                dp = `M ${p1.x} ${p1.z} A ${p2.r} ${p2.r} 0 0 ${p2.cw ? 0 : 1} ${p2.x} ${p2.z}`;
            } else {
                dp = `M ${p1.x} ${p1.z} L ${p2.x} ${p2.z}`;
            }
            measureLayer.appendChild(svgEl("path", { d: dp, class: "line-selected" }));
        }
    }

    // --- EVENT LISTENERS ---
    let isDragging = false, lastTouch = { x: 0, y: 0 }, isTouch = false;

    svg.addEventListener('mousedown', function() { isDragging = true; });
    window.addEventListener('mouseup', function() { isDragging = false; });

    svg.addEventListener('click', function(e) {
        if (isDragging) return;
        if (pickingStartPoint) {
            let pickX = 0, pickZ = 0;
            if (lastVirtualSnap && lastVirtualSnap.type !== 'segment_stick') {
                pickX = lastVirtualSnap.x; pickZ = lastVirtualSnap.z;
            } else {
                const m = svg.getScreenCTM();
                pickX = (e.clientX - m.e) / m.a;
                pickZ = -((e.clientY - m.f) / m.d);
            }
            openStartModal(pickX, pickZ);
            return;
        }
        if (lastVirtualSnap) {
            if (lastVirtualSnap.type === 'segment_stick') {
                if (measureMode === 'distance' || measureMode === 'radius') measureSegment(lastVirtualSnap.index);
                else if (measureMode === 'angle') handleAngleLineClick(lastVirtualSnap.index);
            } else if (lastVirtualSnap.type === 'point') {
                const idx = points.findIndex(function(p) { return Math.abs(p.x - lastVirtualSnap.x) < 0.001 && Math.abs(p.z - lastVirtualSnap.z) < 0.001; });
                if (idx !== -1) onPointClick(idx);
            } else if (lastVirtualSnap.type === 'center') onCenterClick(lastVirtualSnap.x, lastVirtualSnap.z);
            else if (lastVirtualSnap.type === 'intersection') {
                saveHistory();
                points.push({ x: lastVirtualSnap.x, z: lastVirtualSnap.z, break: true, type: 'line', id: pointIdCounter++ });
                centerViewOnPoint(points[points.length - 1]);
                updatePath();
            }
        }
    });

    svg.addEventListener('touchstart', function(e) {
        if (e.touches.length > 1) {
            clearTimeout(longPressTimer);
            isLongPressActive = false;
            isDragging = false;
            const t1 = e.touches[0]; const t2 = e.touches[1];
            initialPinchDist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
            initialVbW = vb.w; initialVbH = vb.h;
            return;
        }
        const t = e.touches[0];
        isTouch = true;
        lastTouch = { x: t.clientX, y: t.clientY };
        isLongPressActive = false;
        longPressTimer = setTimeout(function() {
            isLongPressActive = true;
            if (navigator.vibrate) navigator.vibrate(50);
            updateMobileCursor(t);
        }, LONG_PRESS_DURATION);
    }, { passive: false });

    window.addEventListener('touchend', function() {
        clearTimeout(longPressTimer);
        if (isLongPressActive) {
            if (lastVirtualSnap) {
               if (pickingStartPoint) {
                   openStartModal(lastVirtualSnap.x, lastVirtualSnap.z);
               } else if (lastVirtualSnap.type === 'segment_stick') {
                   if (measureMode === 'distance' || measureMode === 'radius') measureSegment(lastVirtualSnap.index);
                   else if (measureMode === 'angle') handleAngleLineClick(lastVirtualSnap.index);
               } else if (lastVirtualSnap.type === 'point') {
                   const idx = points.findIndex(function(p) { return Math.abs(p.x - lastVirtualSnap.x) < 0.001 && Math.abs(p.z - lastVirtualSnap.z) < 0.001; });
                   if (idx !== -1) onPointClick(idx);
               } else if (lastVirtualSnap.type === 'center') {
                   onCenterClick(lastVirtualSnap.x, lastVirtualSnap.z);
               } else if (lastVirtualSnap.type === 'intersection') {
                   saveHistory(); points.push({x:lastVirtualSnap.x, z:lastVirtualSnap.z, break:true, type:'line', id:pointIdCounter++}); centerViewOnPoint(points[points.length-1]); updatePath();
               }
            } else if (pickingStartPoint) {
               if(lastVirtualSnap) openStartModal(lastVirtualSnap.x, lastVirtualSnap.z);
            }
            
            mobCursorGrp.innerHTML = ''; snapGrp.innerHTML = ''; lastVirtualSnap = null; isLongPressActive = false; isDragging = false;
        } else {
            isDragging = false; isTouch = false;
        }
    });

    function moveHandler(dx, dy, cx, cy) {
        if (isTouch) {
            if (isLongPressActive) {
                updateMobileCursor({ clientX: cx, clientY: cy });
            } else {
                if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                    clearTimeout(longPressTimer);
                    const s = vb.w / svg.clientWidth;
                    vb.x -= dx * s;
                    vb.y -= dy * s;
                    requestRender();
                }
            }
        } else {
            if (isDragging) {
                const s = vb.w / svg.clientWidth;
                vb.x -= dx * s;
                vb.y -= dy * s;
                requestRender();
            }
            const m = svg.getScreenCTM();
            lastVirtualSnap = handleMouseSnap({ x: (cx - m.e) / m.a, y: (cy - m.f) / m.d });
        }
    }

    window.addEventListener('mousemove', function(e) { moveHandler(e.movementX, e.movementY, e.clientX, e.clientY); });
    
    svg.addEventListener('touchmove', function(e) {
        e.preventDefault();
        if (e.touches.length === 2) {
            clearTimeout(longPressTimer);
            const t1 = e.touches[0]; const t2 = e.touches[1];
            const dist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
            if (initialPinchDist > 0) {
                const scale = initialPinchDist / dist;
                const oldW = vb.w; const oldH = vb.h;
                vb.w = initialVbW * scale;
                vb.h = initialVbH * scale;
                vb.x -= (vb.w - oldW) / 2;
                vb.y -= (vb.h - oldH) / 2;
                requestRender();
                updatePath();
            }
            return;
        }
        const t = e.touches[0];
        const dx = t.clientX - lastTouch.x;
        const dy = t.clientY - lastTouch.y;
        moveHandler(dx, dy, t.clientX, t.clientY);
        lastTouch = { x: t.clientX, y: t.clientY };
    }, { passive: false });

    svg.addEventListener('wheel', function(e) {
        e.preventDefault();
        const z = e.deltaY > 0 ? 1.1 : 0.9;
        const m = svg.getScreenCTM();
        const mx = (e.clientX - m.e) / m.a;
        const my = (e.clientY - m.f) / m.d;
        const rx = (mx - vb.x) / vb.w;
        const ry = (my - vb.y) / vb.h;
        vb.w *= z; vb.h *= z;
        vb.x = mx - rx * vb.w;
        vb.y = my - ry * vb.h;
        requestRender();
        updatePath();
    }, { passive: false });

    function updateMobileCursor(t) {
        const m = svg.getScreenCTM();
        const wx = (t.clientX - m.e) / m.a;
        const wy = ((t.clientY - TOUCH_OFFSET_Y) - m.f) / m.d;
        lastVirtualSnap = handleMouseSnap({ x: wx, y: wy });
        
        const fx = (t.clientX - m.e) / m.a;
        const fy = (t.clientY - m.f) / m.d;
        const s = 20 * (vb.w / svg.clientWidth);
        
        const cx = (t.clientX - m.e) / m.a;
        const cy = (t.clientY - m.f) / m.d - (TOUCH_OFFSET_Y / m.d);
        
        mobCursorGrp.innerHTML = '';
        mobCursorGrp.appendChild(svgEl("circle", { cx: fx, cy: fy, r: 8 * s / 20, class: "mobile-finger-pos" }));
        mobCursorGrp.appendChild(svgEl("path", { d: `M ${fx} ${fy} L ${cx} ${cy}`, class: "mobile-cursor-crosshair", "vector-effect": "non-scaling-stroke" }));
        mobCursorGrp.appendChild(svgEl("path", { d: `M ${cx - s} ${cy} L ${cx + s} ${cy} M ${cx} ${cy - s} L ${cx} ${cy + s}`, class: "mobile-cursor-crosshair", "vector-effect": "non-scaling-stroke" }));
        
        lastVirtualSnap = handleMouseSnap({ x: cx, y: cy });
    }

    // --- UI ACTIONS ---
    function openJoypad() {
        closeModals();
        $('modal-joypad').style.display = 'flex';
        const l = points[points.length - 1];
        const btn = $('btn-joy-tangent');
        if (l && l.type === 'arc' && !l.break) {
            btn.classList.remove('disabled');
            btn.onclick = function() { prepMove('TANGENT'); };
        } else {
            btn.classList.add('disabled');
            btn.onclick = null;
        }
    }

    function prepMove(d) {
        currentDir = d;
        closeModals();
        $('modal-input').style.display = 'flex';
        let title = "Posun: " + d;
        if (d === 'TANGENT') title = "Tečná linka";
        $('input-title').innerText = title;
        $('inp-len').value = '';
        $('inp-x').value = '';
        $('inp-z').value = '';
        $('inp-angle').value = '';
        $('chk-rel-angle').checked = false;
        $('inp-len').focus();
    }
    
    function commitMove() {
        const lS = $('inp-len').value.replace(',', '.');
        const xS = $('inp-x').value.replace(',', '.');
        const zS = $('inp-z').value.replace(',', '.');
        const aS = $('inp-angle').value.replace(',', '.');
        if (!lS && !xS && !zS && !aS) { alert("Hodnoty?"); return; }
        saveHistory();
        const l = points[points.length - 1];
        let nx = l.x; let nz = l.z;
        if (xS && zS) { nx = parseFloat(xS) / (isDiameterMode ? 2 : 1); nz = parseFloat(zS); }
        else if (aS) {
            let ad = parseFloat(aS);
            if ($('chk-rel-angle').checked) {
                let pa = 0;
                if (points.length > 1 && !l.break) { const p = points[points.length - 2]; pa = Math.atan2(l.z - p.z, l.x - p.x) * (180 / Math.PI); }
                ad += pa;
            }
            const ar = ad * (Math.PI / 180);
            if (lS) { const ln = parseFloat(lS); nx += ln * Math.cos(ar); nz += ln * Math.sin(ar); }
            else if (xS) { let tx = parseFloat(xS) / (isDiameterMode ? 2 : 1); if (Math.abs(Math.cos(ar)) < 1e-6) { alert("90° vs X"); return; } nx = tx; nz += (tx - l.x) / Math.cos(ar) * Math.sin(ar); }
            else if (zS) { let tz = parseFloat(zS); if (Math.abs(Math.sin(ar)) < 1e-6) { alert("0° vs Z"); return; } nz = tz; nx += (tz - l.z) / Math.sin(ar) * Math.cos(ar); }
        } else if (xS || zS) { if (xS) nx = parseFloat(xS) / (isDiameterMode ? 2 : 1); if (zS) nz = parseFloat(zS); }
        else if (lS) {
            const ln = parseFloat(lS);
            if (currentDir === 'TANGENT') {
                const a = Math.atan2(l.z - l.cz, l.x - l.cx) + (l.cw ? -Math.PI / 2 : Math.PI / 2);
                nx += ln * Math.cos(a); nz += ln * Math.sin(a);
            } else {
                const s = ln * 0.7071;
                const D = { 'U': [0, 1], 'D': [0, -1], 'L': [-1, 0], 'R': [1, 0], 'UL': [-s, s], 'UR': [s, s], 'DL': [-s, -s], 'DR': [s, -s] };
                if (D[currentDir]) { nx += D[currentDir][0] * ln; nz += D[currentDir][1] * ln; }
            }
        }
        points.push({ x: nx, z: nz, break: false, type: 'line', id: pointIdCounter++ });
        centerViewOnPoint({ x: nx, z: nz }); updatePath(); closeModals();
    }

    function openArcModal() { closeModals(); $('modal-arc').style.display = 'flex'; $('arc-r').value = 100; $('chk-tangent').checked = true; $('arc-x').value = ''; $('arc-z').value = ''; $('center-x').value = ''; $('center-z').value = ''; $('ik-target-x').value = ''; $('ik-target-z').value = ''; $('ik-target-angle').value = ''; switchArcMethod('R'); setArcDir(true); }
    function switchArcMethod(m) { arcMethod = m; $('tab-r').classList.toggle('active', m === 'R'); $('tab-ik').classList.toggle('active', m === 'IK'); $('method-r').style.display = m === 'R' ? 'block' : 'none'; $('method-ik').style.display = m === 'IK' ? 'block' : 'none'; $('arc-targets').style.display = m === 'R' ? 'block' : 'none'; toggleTangentMode(); }
    function setArcDir(cw) { isG2 = cw; $('seg-g2').classList.toggle('active', cw); $('seg-g3').classList.toggle('active', !cw); }
    function toggleIKMode(i) { isIncrementalIKMode = i; $('ik-abs-btn').classList.toggle('active', !i); $('ik-inc-btn').classList.toggle('active', i); }
    function setTangentTarget(t) { tangentTargetMode = t; $('target-coord-btn').classList.toggle('active', t === 'coord'); $('target-cone-btn').classList.toggle('active', t === 'cone'); $('target-coord-inputs').style.display = t === 'coord' ? 'block' : 'none'; $('target-cone-input').style.display = t === 'cone' ? 'block' : 'none'; }
    function toggleTangentMode() { const t = $('chk-tangent').checked; $('tangent-target-selector').style.display = (arcMethod === 'R' && t) ? 'block' : 'none'; if (!t && arcMethod === 'R') { $('target-coord-inputs').style.display = 'block'; $('target-cone-input').style.display = 'none'; } else if (arcMethod === 'R') setTangentTarget(tangentTargetMode); }
    
    function toggleBackTangentMode() {
        const bt = $('chk-back-tangent').checked;
        if (bt) {
             $('chk-tangent').checked = false;
             toggleTangentMode();
        }
    }
    
    function commitArc() {
        saveHistory(); const l = points[points.length - 1]; let ex, ez, cx, cz, r;
        
        // --- BACK TANGENT LOGIC (FIXED) ---
        if (arcMethod === 'R' && $('chk-back-tangent').checked) {
            if (points.length < 2) { alert("Nelze použít zpětnou tangentu."); return; }
            const prevP = points[points.length-2]; 
            const rV = parseFloat($('arc-r').value.replace(',', '.'));
            if (isNaN(rV)) { alert("R?"); return; } r = Math.abs(rV);
            let tx = parseFloat($('arc-x').value.replace(',', '.'));
            let tz = parseFloat($('arc-z').value.replace(',', '.'));
            if (isNaN(tx) || isNaN(tz)) { alert("Cíl?"); return; }
            if (isDiameterMode) tx /= 2;
            
            // 1. Získáme vektor původní přímky (směr jízdy)
            let dx = l.x - prevP.x; 
            let dz = l.z - prevP.z;
            let len = Math.sqrt(dx*dx + dz*dz);
            if(len < 0.001) { alert("Krátká úsečka"); return; }
            
            let ux = dx / len;
            let uz = dz / len;

            // 2. Určíme offset pro střed kružnice (Normálový vektor)
            let offsetX, offsetZ;
            if (isG2) { 
                // G2 = CW -> Střed VPRAVO
                offsetX = uz * r;
                offsetZ = -ux * r;
            } else {
                // G3 = CCW -> Střed VLEVO
                offsetX = -uz * r;
                offsetZ = ux * r;
            }

            // 3. Definujeme "Čáru možných středů"
            let shiftedStartX = prevP.x + offsetX;
            let shiftedStartZ = prevP.z + offsetZ;

            // 4. Hledáme průsečík s kružnicí cíle
            let diffX = shiftedStartX - tx;
            let diffZ = shiftedStartZ - tz;

            let a = 1; 
            let b = 2 * (ux * diffX + uz * diffZ);
            let c = (diffX*diffX + diffZ*diffZ) - (r*r);

            let det = b*b - 4*a*c;
            
            if (det < 0) {
                alert("Nelze zkonstruovat tečnu (Geometricky nemožné).");
                return;
            }

            let t1 = (-b + Math.sqrt(det)) / (2*a);
            let t2 = (-b - Math.sqrt(det)) / (2*a);

            const getSweep = function(t_val) {
                let cx_try = shiftedStartX + t_val * ux;
                let cz_try = shiftedStartZ + t_val * uz;
                let sx_try = prevP.x + t_val * ux; 
                let sz_try = prevP.z + t_val * uz;
                
                let angStart = Math.atan2(sz_try - cz_try, sx_try - cx_try);
                let angEnd = Math.atan2(tz - cz_try, tx - cx_try);
                let sweep = angEnd - angStart;
                
                if (isG2) { if (sweep > 0) sweep -= 2 * Math.PI; }
                else { if (sweep < 0) sweep += 2 * Math.PI; }
                
                return { t: t_val, sw: Math.abs(sweep), cx: cx_try, cz: cz_try, sx: sx_try, sz: sz_try };
            };

            let s1 = getSweep(t1);
            let s2 = getSweep(t2);

            let best = (s1.sw < s2.sw) ? s1 : s2;

            points[points.length-1].x = best.sx;
            points[points.length-1].z = best.sz;
            
            ex = tx; ez = tz; cx = best.cx; cz = best.cz;
            points.push({x: ex, z: ez, type: 'arc', r: r, cw: isG2, break: false, cx: cx, cz: cz, id: pointIdCounter++}); 
            updatePath(); closeModals();
            return;
        }

        if (arcMethod === 'IK') {
            const cX = parseFloat($('center-x').value.replace(',', '.')), cZ = parseFloat($('center-z').value.replace(',', '.'));
            if (isNaN(cX) || isNaN(cZ)) { alert("Střed?"); return; }
            cx = isIncrementalIKMode ? l.x + (isDiameterMode ? cX / 2 : cX) : (isDiameterMode ? cX / 2 : cX);
            cz = isIncrementalIKMode ? l.z + cZ : cZ;
            r = dist(l, { x: cx, z: cz });
            const tA = $('ik-target-angle').value, tX = $('ik-target-x').value, tZ = $('ik-target-z').value;
            if (tA) {
                const a = Math.atan2(l.z - cz, l.x - cx) + parseFloat(tA.replace(',', '.')) * (Math.PI / 180) * (isG2 ? -1 : 1);
                ex = cx + r * Math.cos(a); ez = cz + r * Math.sin(a);
            } else if (tX || tZ) {
                let c = [];
                if (tX) { let tx = parseFloat(tX.replace(',', '.')) / (isDiameterMode ? 2 : 1), tm = r * r - Math.pow(tx - cx, 2); if (tm >= 0) { let d = Math.sqrt(tm); c.push({ x: tx, z: cz + d }, { x: tx, z: cz - d }); } }
                if (tZ) { let tz = parseFloat(tZ.replace(',', '.')), tm = r * r - Math.pow(tz - cz, 2); if (tm >= 0) { let d = Math.sqrt(tm); c.push({ x: cx + d, z: tz }, { x: cx - d, z: tz }); } }
                if (!c.length) { alert("Mimo dosah"); return; }
                const sA = Math.atan2(l.z - cz, l.x - cx);
                c.forEach(function(k) { let d = Math.atan2(k.z - cz, k.x - cx) - sA; if (isG2 && d > 0) d -= 2 * Math.PI; else if (!isG2 && d < 0) d += 2 * Math.PI; k.s = Math.abs(d); });
                c.sort(function(a, b) { return a.s - b.s; });
                const s = ($('chk-ik-long-arc').checked && c.length > 1) ? c[1] : c[0];
                ex = s.x; ez = s.z;
            } else { alert("Cíl?"); return; }
        } else {
            const rV = parseFloat($('arc-r').value.replace(',', '.')); if (isNaN(rV)) { alert("R?"); return; } r = Math.abs(rV);
            if (!$('chk-tangent').checked) {
                let tx = parseFloat($('arc-x').value.replace(',', '.')), tz = parseFloat($('arc-z').value.replace(',', '.'));
                if (isNaN(tx) || isNaN(tz)) { alert("Cíl?"); return; } if (isDiameterMode) tx /= 2; ex = tx; ez = tz;
                const d = dist(l, { x: ex, z: ez }); if (d > 2 * r) { alert("Malé R"); return; }
                const h = Math.sqrt(r * r - (d / 2) * (d / 2)), a = Math.atan2(ez - l.z, ex - l.x), mx = (l.x + ex) / 2, mz = (l.z + ez) / 2, c1x = mx + h * Math.sin(a), c1z = mz - h * Math.cos(a), c2x = mx - h * Math.sin(a), c2z = mz + h * Math.cos(a), cr = (ex - l.x) * (c1z - l.z) - (ez - l.z) * (c1x - l.x);
                cx = isG2 ? (cr < 0 ? c1x : c2x) : (cr > 0 ? c1x : c2x); cz = isG2 ? (cr < 0 ? c1z : c2z) : (cr > 0 ? c1z : c2z);
            } else {
                let pA = 0;
                if (l.type === 'arc' && !l.break) { const ra = Math.atan2(l.z - l.cz, l.x - l.cx); pA = l.cw ? ra - Math.PI / 2 : ra + Math.PI / 2; }
                else if (points.length > 1) { const p = points[points.length - 2]; pA = Math.atan2(l.z - p.z, l.x - p.x); }
                const nA = isG2 ? pA - Math.PI / 2 : pA + Math.PI / 2;
                cx = l.x + Math.cos(nA) * r; cz = l.z + Math.sin(nA) * r;
                if (tangentTargetMode === 'cone') {
                    const ang = parseFloat($('arc-cone-angle').value.replace(',', '.')); if (isNaN(ang)) { alert("Úhel?"); return; }
                    const eA = Math.atan2(l.z - cz, l.x - cx) + ang * (Math.PI / 180) * (isG2 ? -1 : 1);
                    ex = cx + r * Math.cos(eA); ez = cz + r * Math.sin(eA);
                } else {
                    let c = [], tX = $('arc-x').value, tZ = $('arc-z').value;
                    if (tZ) { let tz = parseFloat(tZ.replace(',', '.')), tm = r * r - Math.pow(tz - cz, 2); if (tm >= 0) { let d = Math.sqrt(tm); c.push({ x: cx + d, z: tz }); c.push({ x: cx - d, z: tz }); } }
                    else if (tX) { let tx = parseFloat(tX.replace(',', '.')) / (isDiameterMode ? 2 : 1), tm = r * r - Math.pow(tx - cx, 2); if (tm >= 0) { let d = Math.sqrt(tm); c.push({ x: tx, z: cz + d }); c.push({ x: tx, z: cz - d }); } }
                    else { alert("Souřadnice?"); return; }
                    const ct = $('choices-container'); ct.innerHTML = ''; $('tangent-choices').style.display = 'block';
                    for(let k=0; k<c.length; k++) {
                        const cand = c[k];
                        const b = document.createElement('div'); b.className = 'choice-btn';
                        let dX = isDiameterMode ? cand.x * 2 : cand.x;
                        b.innerHTML = `<span>Bod ${k + 1}</span> X:${dX.toFixed(2)} Z:${cand.z.toFixed(2)}`;
                        b.onclick = function() { points.push({ x: cand.x, z: cand.z, type: 'arc', r: r, cw: isG2, break: false, cx: cx, cz: cz, id: pointIdCounter++ }); updatePath(); closeModals(); };
                        ct.appendChild(b);
                    }
                    return;
                }
            }
        }
        points.push({ x: ex, z: ez, type: 'arc', r: r, cw: isG2, break: false, cx: cx, cz: cz, id: pointIdCounter++ }); updatePath(); closeModals();
    }

    function openCircleModal() { closeModals(); $('modal-circle').style.display = 'flex'; $('circ-val').value = ''; $('circ-cx').value = ''; $('circ-cz').value = ''; setCircleMode('R'); }
    function setCircleMode(m) { circleInputMode = m; $('circ-rad-btn').classList.toggle('active', m === 'R'); $('circ-dia-btn').classList.toggle('active', m === 'D'); $('lbl-circ-val').innerText = m === 'R' ? 'Hodnota R:' : 'Hodnota D:'; updateDiameterButtonText(); }
    function commitCircle() {
        const sS = $('circ-val').value.replace(',', '.');
        const cS = $('circ-cx').value.replace(',', '.');
        const zS = $('circ-cz').value.replace(',', '.');
        if (!sS || !cS || !zS) { alert("Všechna pole?"); return; }
        const v = parseFloat(sS);
        let cX = parseFloat(cS); if (isDiameterMode) cX /= 2;
        const cZ = parseFloat(zS), r = circleInputMode === 'R' ? v : v / 2;
        saveHistory();
        points.push({ x: cX + r, z: cZ, break: true, type: 'line', id: pointIdCounter++ });
        points.push({ x: cX - r, z: cZ, type: 'arc', r: r, cw: true, cx: cX, cz: cZ, id: pointIdCounter++ });
        points.push({ x: cX + r, z: cZ, type: 'arc', r: r, cw: true, cx: cX, cz: cZ, id: pointIdCounter++ });
        updatePath(); centerViewOnPoint({ x: cX, z: cZ }); closeModals();
    }

    function onPointClick(i) {
        if (isDragging && !lastVirtualSnap && !isLongPressActive) return;
        const p = points[i];
        if (measureMode) { handleMeasureClick(p); return; }
        if (points.length > 0 && points[points.length - 1] === p) { centerViewOnPoint(p); return; }
        if (!pickingStartPoint) { saveHistory(); points.push({ x: p.x, z: p.z, break: points.length === 0, type: 'line', id: pointIdCounter++ }); centerViewOnPoint(points[points.length - 1]); updatePath(); }
        else openStartModal(p.x, p.z);
    }
    function onCenterClick(cx, cz) {
        if (isDragging && !lastVirtualSnap && !isLongPressActive) return;
        if (measureMode) handleMeasureClick({ x: cx, z: cz });
        else { $('hud-x').innerText = (isDiameterMode ? cx * 2 : cx).toFixed(2) + " (I)"; $('hud-z').innerText = cz.toFixed(2) + " (K)"; }
    }
    function toggleDiameterMode() { isDiameterMode = !isDiameterMode; localStorage.setItem('cnc_diameter_mode', isDiameterMode); updateDiameterButtonText(); drawDynamicGrid(); updatePath(); }
    function updateDiameterButtonText() {
        const b = $('btn-toggle-dia'); if (!b) return;
        b.querySelector('span').innerText = isDiameterMode ? "Ø Průměr" : "R Poloměr";
        b.querySelector('i').className = isDiameterMode ? 'fas fa-expand-arrows-alt' : 'fas fa-compress-arrows-alt';
        ['lbl-arc-x', 'lbl-center-x', 'lbl-start-x', 'lbl-inp-x', 'lbl-circ-cx', 'lbl-circ-val'].forEach(function(id) { if ($(id)) $(id).innerText = $(id).innerText.replace(/Průměr|Poloměr/, isDiameterMode ? "Průměr" : "Poloměr"); });
    }
    function confirmClearAll() { if (confirm("Opravdu smazat celý výkres?")) clearAll(); }
    function clearAll() { saveHistory(); points = [{ x: 0, z: 0, break: false, type: 'line', id: pointIdCounter++ }]; updatePath(); closeModals(); setHomeView(); }

    function openMeasureModal() { if (points.length < 2) { alert("Málo bodů"); return; } closeModals(); $('modal-measure').style.display = 'flex'; setMeasureMode('distance'); $('measure-result').style.display = 'none'; }
    function setMeasureMode(m) {
        measureMode = m; measurePoints = []; measureLineBuffer = null; measureLayer.innerHTML = ''; $('measure-result').style.display = 'none';
        const opts = document.querySelectorAll('#modal-measure .seg-opt');
        for (let i = 0; i < opts.length; i++) opts[i].classList.remove('active');
        const btnId = m === 'distance' ? 'meas-dist-btn' : (m === 'angle' ? 'meas-angle-btn' : 'meas-coord-btn');
        if ($(btnId)) $(btnId).classList.add('active');
        let instr = "Vyberte body.";
        if (m === 'distance') instr = "Vyberte úsečku nebo 2 body.";
        if (m === 'angle') instr = "Vyberte 2 úsečky nebo 3 body.";
        if (m === 'radius') instr = "Vyberte oblouk.";
        $('measure-instructions').innerText = instr;
    }
    function selectMeasure(m) { setMeasureMode(m); $('modal-measure').style.display = 'none'; }
    function stopMeasure() { measureMode = null; measurePoints = []; measureLineBuffer = null; measureLayer.innerHTML = ''; updatePath(); closeModals(); }
    function handleMeasureClick(p) {
        if (!measureMode) return;
        measurePoints.push(p); updateMeasureDisplay();
        const r = measureMode === 'angle' ? 3 : (measureMode === 'distance' ? 2 : 1);
        if (measurePoints.length === r) {
            let o = "", P = measurePoints;
            $('modal-measure').style.display = 'flex'; $('measure-result').style.display = 'block';
            if (measureMode === 'distance') {
                const dx = P[1].x - P[0].x, dz = P[1].z - P[0].z;
                o = `L: ${Math.sqrt(dx * dx + dz * dz).toFixed(3)}<br>X: ${(isDiameterMode ? dx * 2 : dx).toFixed(3)} Z: ${dz.toFixed(3)}`;
            } else if (measureMode === 'angle') {
                const v1 = { x: P[1].x - P[0].x, z: P[1].z - P[0].z }, v2 = { x: P[2].x - P[1].x, z: P[2].z - P[1].z };
                o = `Úhel: ${(Math.acos((v1.x * v2.x + v1.z * v2.z) / (dist({ x: 0, z: 0 }, v1) * dist({ x: 0, z: 0 }, v2))) * (180 / Math.PI)).toFixed(3)}°`;
            } else o = `X: ${(isDiameterMode ? P[0].x * 2 : P[0].x).toFixed(3)}<br>Z: ${P[0].z.toFixed(3)}`;
            $('measure-output').innerHTML = o; measurePoints = [];
        }
    }
    function measureSegment(i) {
        const p1 = points[i], p2 = points[i + 1]; if (!p1 || !p2) return;
        $('modal-measure').style.display = 'flex'; $('measure-result').style.display = 'block';
        let o = "";
        if (measureMode === 'radius') {
            if (p2.type !== 'arc') return;
            const cX = isDiameterMode ? p2.cx * 2 : p2.cx;
            o = `Rádius (R): ${p2.r.toFixed(3)}<br>Střed X: ${cX.toFixed(3)}<br>Střed Z: ${p2.cz.toFixed(3)}`;
        } else {
            if (p2.type === 'arc') {
                const sa = Math.atan2(p1.z - p2.cz, p1.x - p2.cx), ea = Math.atan2(p2.z - p2.cz, p2.x - p2.cx);
                let d = ea - sa; if (p2.cw) { if (d > 0) d -= 2 * Math.PI; d = Math.abs(d); } else { if (d < 0) d += 2 * Math.PI; d = Math.abs(d); }
                o = `Délka obl.: ${(d * p2.r).toFixed(3)}<br>R: ${p2.r.toFixed(3)}<br>Úhel: ${(d * 180 / Math.PI).toFixed(2)}°`;
            } else {
                const dx = p2.x - p1.x, dz = p2.z - p1.z;
                o = `Délka: ${Math.sqrt(dx * dx + dz * dz).toFixed(3)}<br>DX: ${(isDiameterMode ? dx * 2 : dx).toFixed(3)}<br>DZ: ${dz.toFixed(3)}`;
            }
        }
        $('measure-output').innerHTML = o; measureLayer.innerHTML = '';
        if (p2.type === 'arc') measureLayer.appendChild(svgEl("path", { d: `M ${p1.x} ${p1.z} A ${p2.r} ${p2.r} 0 0 ${p2.cw ? 0 : 1} ${p2.x} ${p2.z}`, class: "entity-highlight" }));
        else measureLayer.appendChild(svgEl("path", { d: `M ${p1.x} ${p1.z} L ${p2.x} ${p2.z}`, class: "entity-highlight" }));
    }
    function handleAngleLineClick(i) {
        if (measureLineBuffer === null) {
            measureLineBuffer = { index: i };
            $('measure-instructions').innerText = "Vyberte druhou úsečku.";
            updatePath();
        } else {
            const i1 = measureLineBuffer.index; const i2 = i;
            const p1a = points[i1], p1b = points[i1 + 1];
            const p2a = points[i2], p2b = points[i2 + 1];
            const v1 = { x: p1b.x - p1a.x, z: p1b.z - p1a.z };
            const v2 = { x: p2b.x - p2a.x, z: p2b.z - p2a.z };
            const dot = v1.x * v2.x + v1.z * v2.z;
            const mag1 = Math.sqrt(v1.x * v1.x + v1.z * v1.z);
            const mag2 = Math.sqrt(v2.x * v2.x + v2.z * v2.z);
            const angleRad = Math.acos(Math.max(-1, Math.min(1, dot / (mag1 * mag2))));
            const angleDeg = angleRad * (180 / Math.PI);
            $('modal-measure').style.display = 'flex'; $('measure-result').style.display = 'block';
            $('measure-output').innerHTML = `Úhel mezi úsečkami: ${angleDeg.toFixed(3)}°<br>Doplněk do 180: ${(180 - angleDeg).toFixed(3)}°`;
            measureLineBuffer = null; $('measure-instructions').innerText = "Vyberte 2 úsečky."; updatePath();
        }
    }

    function toggleStartPick() {
        pickingStartPoint = !pickingStartPoint;
        const btn = $('btn-start-pick');
        if (pickingStartPoint) {
            btn.classList.add('active-mode');
            stopMeasure();
        } else {
            btn.classList.remove('active-mode');
        }
    }
    function openStartModal(x, z) {
        closeModals(); $('modal-start').style.display = 'flex';
        if (x !== undefined && z !== undefined) {
            const dX = isDiameterMode ? x * 2 : x;
            $('start-x').value = dX.toFixed(3); $('start-z').value = z.toFixed(3);
        } else { $('start-x').value = ''; $('start-z').value = ''; }
        pickingStartPoint = false; $('btn-start-pick').classList.remove('active-mode');
    }
    function confirmNewStart() {
        saveHistory();
        let vx = parseFloat($('start-x').value.replace(',', '.') || '0');
        let vz = parseFloat($('start-z').value.replace(',', '.') || '0');
        if (isDiameterMode) vx /= 2;
        points.push({ x: vx, z: vz, break: true, type: 'line', id: pointIdCounter++ });
        centerViewOnPoint(points[points.length - 1]);
        updatePath();
        closeModals();
    }
    function actionMoveOnly() { confirmNewStart(); toggleStartPick(); }
    function actionMoveAndLine() { confirmNewStart(); toggleStartPick(); openJoypad(); }
    function actionCircleCenter() {
        const sx = $('start-x').value; const sz = $('start-z').value;
        closeModals(); toggleStartPick(); openCircleModal();
        $('circ-cx').value = sx; $('circ-cz').value = sz; $('circ-val').focus();
    }

    function closeModals() {
        const modals = document.querySelectorAll('.modal');
        for (let i = 0; i < modals.length; i++) modals[i].style.display = 'none';
    }

    function requestRender() {
        requestAnimationFrame(function(){ 
             updateViewBox(); 
             drawDynamicGrid(); 
        });
    }

    setTimeout(function() { handleResize(); setHomeView(); saveHistory(); setTimeout(drawDynamicGrid, 100); }, 50);
    window.addEventListener('resize', handleResize);
</script>
</body>
</html>
