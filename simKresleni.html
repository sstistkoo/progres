<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Karusel CNC SmartGrid Pro v7.0</title>
    <style>
        :root { 
            --bg-canvas: #ffffff;           
            --bg-panel: #2c2c2c;
            --grid-main: #ccc;       
            --grid-sub: #e8e8e8;     
            --axis: #444;            
            --accent: #ff6f00;       
            --text-dark: #333;
            --text-light: #eee;
        }

        body { margin: 0; padding: 0; background: var(--bg-panel); color: var(--text-light); font-family: 'Segoe UI', Roboto, sans-serif; height: 100vh; width: 100vw; overflow: hidden; user-select: none; }

        /* --- HLAVNÍ ROZLOŽENÍ (Split View) --- */
        #app-layout {
            display: flex;
            width: 100%;
            height: 100%;
        }

        /* 1. Kreslicí plocha (Vždy čtverec) */
        #canvas-area {
            background: var(--bg-canvas);
            position: relative;
            /* Flexibilita: na mobilu se přizpůsobí šířce, na PC výšce */
            flex-shrink: 0; 
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            z-index: 1;
        }

        /* SVG */
        svg { width: 100%; height: 100%; display: block; cursor: crosshair; }

        /* 2. Ovládací panel (Zbytek místa) */
        #panel-area {
            flex-grow: 1;
            background: var(--bg-panel);
            display: flex;
            flex-direction: column;
            padding: 15px;
            box-sizing: border-box;
            overflow-y: auto;
            align-items: center;
            justify-content: center;
        }

        /* --- GRAFIKA SVG --- */
        .axis-line { stroke: var(--axis); stroke-width: 2px; vector-effect: non-scaling-stroke; }
        .grid-line { stroke: var(--grid-main); stroke-width: 1.5px; vector-effect: non-scaling-stroke; }
        .grid-sub-line { stroke: var(--grid-sub); stroke-width: 1px; vector-effect: non-scaling-stroke; }
        .path-line { stroke: #00c853; stroke-width: 2.5px; fill: none; vector-effect: non-scaling-stroke; stroke-linecap: round; stroke-linejoin: round; }
        .phantom-line { stroke: #999; stroke-width: 1px; stroke-dasharray: 5,5; vector-effect: non-scaling-stroke; }
        .point-marker { fill: #fff; stroke: var(--accent); stroke-width: 2px; vector-effect: non-scaling-stroke; r: 4px; }
        .point-current { fill: var(--accent); r: 6px; }

        /* --- UI ELEMENTS (HUD) --- */
        #coords-hud {
            position: absolute; top: 10px; left: 10px;
            background: rgba(255,255,255,0.9); padding: 6px 12px;
            border-radius: 8px; border: 1px solid #ccc;
            pointer-events: none;
            display: flex; gap: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .hud-val { font-size: 1.1rem; font-weight: bold; color: #000; font-family: 'Consolas', monospace; }
        .hud-label { font-size: 0.7rem; color: #666; text-transform: uppercase; font-weight: 700; margin-left: 4px; }

        /* --- OVLÁDACÍ PRVKY V PANELU --- */
        .panel-group {
            width: 100%; max-width: 400px;
            margin-bottom: 15px;
        }
        .panel-label { font-size: 12px; color: #888; text-transform: uppercase; margin-bottom: 5px; text-align: center; letter-spacing: 1px; }

        /* Joypad Grid */
        .joypad-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; aspect-ratio: 1/0.8; }
        .joy-btn { 
            background: #3d3d3d; border: 1px solid #555; border-radius: 8px; 
            color: #fff; display: flex; flex-direction: column; justify-content: center; align-items: center; 
            cursor: pointer; transition: background 0.1s; 
            box-shadow: 0 4px 0 #222; /* 3D efekt */
        }
        .joy-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 #222; background: var(--accent); color: #000; }
        .joy-arrow { font-size: 24px; line-height: 1; }
        .joy-desc { font-size: 9px; color: #aaa; font-weight: bold; margin-top: 2px; }
        .joy-btn:active .joy-desc { color: #000; }
        
        .joy-menu { background: #555; border-color: #777; }

        /* Action Buttons Row */
        .action-row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
        .act-btn {
            padding: 12px; border: none; border-radius: 6px; font-weight: bold; cursor: pointer;
            color: #fff; text-align: center; font-size: 13px;
            background: #444; box-shadow: 0 3px 0 #222;
        }
        .act-btn:active { transform: translateY(2px); box-shadow: 0 1px 0 #222; }
        .act-primary { background: var(--accent); color: #000; }
        .act-danger { background: #d32f2f; }

        /* --- MEDIA QUERIES PRO ROZLOŽENÍ --- */
        /* MOBIL (Portrait) */
        @media (orientation: portrait) {
            #app-layout { flex-direction: column; }
            #canvas-area { 
                width: 100%; 
                aspect-ratio: 1 / 1; /* Čtverec na šířku displeje */
            }
        }

        /* PC (Landscape) */
        @media (orientation: landscape) {
            #app-layout { flex-direction: row; }
            #canvas-area { 
                height: 100%; 
                aspect-ratio: 1 / 1; /* Čtverec na výšku okna */
            }
        }

        /* --- MODALS (Overlays) --- */
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 100; justify-content: center; align-items: center; backdrop-filter: blur(3px); }
        .modal-content { background: #fff; padding: 25px; border-radius: 16px; width: 90%; max-width: 350px; color: #333; }
        
        input { width: 100%; padding: 12px; font-size: 18px; text-align: right; border: 1px solid #ccc; border-radius: 6px; margin-bottom: 15px; box-sizing: border-box; }
        .modal-btn-row { display: flex; gap: 10px; }
        .m-btn { flex: 1; padding: 12px; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; }
        .m-ok { background: var(--accent); color: #fff; }
        .m-cancel { background: #eee; color: #333; }

    </style>
</head>
<body>

<div id="app-layout">
    <!-- LEVÁ/HORNÍ ČÁST: KRESLENÍ -->
    <div id="canvas-area">
        <svg id="svgCanvas" preserveAspectRatio="xMidYMid slice">
            <g id="worldGroup" transform="scale(1, -1)">
                <g id="gridLines"></g> 
                <g id="axisGroup"></g> 
                <g id="pathGroup"></g> 
            </g>
            <g id="textGroup"></g>
        </svg>
        
        <!-- HUD přímo na plátně -->
        <div id="coords-hud">
            <div><span class="hud-val" id="hud-x">0.00</span><span class="hud-label" id="lbl-x">Ø</span></div>
            <div style="width:1px; background:#ddd;"></div>
            <div><span class="hud-val" id="hud-z">0.00</span><span class="hud-label">Z</span></div>
        </div>
    </div>

    <!-- PRAVÁ/DOLNÍ ČÁST: OVLÁDACÍ PANEL -->
    <div id="panel-area">
        
        <!-- Hlavní Ovladač -->
        <div class="panel-group">
            <div class="panel-label">Posuv & Kužel</div>
            <div class="joypad-grid">
                <div class="joy-btn" onclick="prepMove('UL')"><span class="joy-arrow">↖</span><span class="joy-desc">Kužel</span></div>
                <div class="joy-btn" onclick="prepMove('U')"><span class="joy-arrow">⬆</span><span class="joy-desc">Z+</span></div>
                <div class="joy-btn" onclick="prepMove('UR')"><span class="joy-arrow">↗</span><span class="joy-desc">Kužel</span></div>
                
                <div class="joy-btn" onclick="prepMove('L')"><span class="joy-arrow">⬅</span><span class="joy-desc">X-</span></div>
                <div class="joy-btn joy-menu" onclick="setHomeView()"><span class="joy-arrow">⌂</span><span class="joy-desc">RESET</span></div>
                <div class="joy-btn" onclick="prepMove('R')"><span class="joy-arrow">➡</span><span class="joy-desc">X+</span></div>
                
                <div class="joy-btn" onclick="prepMove('DL')"><span class="joy-arrow">↙</span><span class="joy-desc">Kužel</span></div>
                <div class="joy-btn" onclick="prepMove('D')"><span class="joy-arrow">⬇</span><span class="joy-desc">Z-</span></div>
                <div class="joy-btn" onclick="prepMove('DR')"><span class="joy-arrow">↘</span><span class="joy-desc">Kužel</span></div>
            </div>
        </div>

        <!-- Rychlé Akce -->
        <div class="panel-group">
            <div class="panel-label">Nástroje</div>
            <div class="action-row">
                <button id="btn-toggle-dia" class="act-btn" onclick="toggleDiameterMode()">Režim: Ø</button>
                <button class="act-btn" onclick="fitToScreen()">Centrovat</button>
                <button class="act-btn" onclick="resetOrigin()">Nový Start</button>
                <button class="act-btn act-danger" onclick="clearAll()">Smazat</button>
            </div>
        </div>

        <div style="margin-top:auto; font-size:10px; color:#666;">
            Karusel CNC Helper v7.0
        </div>
    </div>
</div>

<!-- MODAL INPUT (Pouze pro zadávání hodnot) -->
<div id="modal-input" class="modal">
    <div class="modal-content">
        <h3 id="input-title" style="margin-top:0; text-align:center;">Zadat hodnoty</h3>
        
        <div id="input-linear" style="display:none;">
            <label style="display:block; margin-bottom:5px; color:#666; font-size:12px;">Délka pohybu (mm):</label>
            <input type="number" id="inp-len" placeholder="0" inputmode="decimal">
        </div>

        <div id="input-complex" style="display:none;">
            <label id="lbl-inp-x" style="display:block; margin-bottom:5px; color:#666; font-size:12px;">Cílový Průměr X (mm):</label>
            <input type="number" id="inp-x" placeholder="Nevím" inputmode="decimal">
            
            <label style="display:block; margin-bottom:5px; color:#666; font-size:12px;">Cílová Výška Z (mm):</label>
            <input type="number" id="inp-z" placeholder="Nevím" inputmode="decimal">
            
            <label style="display:block; margin-bottom:5px; color:#666; font-size:12px;">Úhel (°):</label>
            <input type="number" id="inp-a" placeholder="45" inputmode="decimal">
            
            <div style="font-size:11px; color:#999; margin-bottom:15px; text-align:center;">0=Vpravo, 90=Nahoru, 180=Vlevo...</div>
        </div>

        <div class="modal-btn-row">
            <button class="m-btn m-cancel" onclick="closeModals()">Zrušit</button>
            <button class="m-btn m-ok" onclick="commitMove()">Vypočítat</button>
        </div>
    </div>
</div>

<script>
    let points = [{x: 0, z: 0, break: false}]; 
    let currentDir = ''; 
    
    const savedMode = localStorage.getItem('cnc_diameter_mode');
    let isDiameterMode = savedMode !== null ? (savedMode === 'true') : true;
    
    const svg = document.getElementById('svgCanvas');
    const gridLines = document.getElementById('gridLines');
    const textGroup = document.getElementById('textGroup');
    const pathGroup = document.getElementById('pathGroup');
    const axisGroup = document.getElementById('axisGroup');

    // ViewBox - začínáme s defaultem, ale hned se přepočítá
    let vb = { x: 0, y: 0, w: 600, h: 600 };

    // --- INIT ---
    updateDiameterButtonText();

    // --- RESIZE LOGIC PRO ČTVERCOVÉ OKNO ---
    function handleResize() {
        // Zjistíme velikost kontejneru canvasu
        const container = document.getElementById('canvas-area');
        const wPx = container.clientWidth;
        const hPx = container.clientHeight;
        
        if (wPx === 0 || hPx === 0) return;

        // Protože máme v CSS nastaveno aspect-ratio: 1/1 nebo fixní rozměry,
        // wPx by se mělo rovnat hPx (přibližně).
        // Ujistíme se, že ViewBox je taky čtverec.
        
        // Pokud se změnila velikost okna, chceme zachovat ZOOM (měřítko).
        // Tedy pokud vidím 600mm na šířku, chci vidět 600mm i po resize.
        
        // Protože je to čtverec, vb.w = vb.h
        vb.h = vb.w; 
        
        updateViewBox();
        drawDynamicGrid();
    }
    
    function setHomeView() {
        vb.w = 600;
        vb.h = 600;
        // Offset 20mm
        vb.x = -20;
        vb.y = 20 - 600; // World Z=20 -> Screen Y = -(20) = -20. World Z-580 -> Screen Y = 580.
        // Počkat, moje logika Y v SVG je: 
        // Y v SVG jde dolů.
        // World Z jde nahoru (transform scale 1,-1).
        // Takže World Z=20 je SVG Y=-20.
        // Pokud chci, aby World Z=-20 bylo dole na obrazovce (ve ViewBoxu y+h):
        // World ZMin = -20.
        // SVG YMax = -(-20) = 20.
        // SVG YMin = SVG YMax - h = 20 - 600 = -580.
        
        // Zkusme jednodušší logiku:
        // Chci vidět rozsah Z od -20 do +580.
        // V SVG (invertované Y) to odpovídá Y od -580 do +20.
        // Takže vb.y (horní okraj v SVG) = -580.
        // vb.h = 600.
        // Spodní okraj v SVG = -580 + 600 = 20.
        // A to odpovídá World Z = -20. Perfektní.
        
        vb.y = -580; 
        vb.x = -20; // Rozsah X od -20 do 580.

        updateViewBox();
        drawDynamicGrid();
    }

    window.addEventListener('resize', handleResize);
    // Init po načtení
    setTimeout(() => { 
        handleResize(); 
        setHomeView(); 
    }, 0);

    // --- DRAG & ZOOM ---
    let isDragging = false;
    
    svg.addEventListener('mousedown', e => { isDragging = true; });
    window.addEventListener('mouseup', () => isDragging = false);
    window.addEventListener('mousemove', e => {
        if (!isDragging) return;
        const scale = vb.w / svg.clientWidth; 
        vb.x -= e.movementX * scale;
        vb.y -= e.movementY * scale; // Y v SVG je dolů, myš dolů = +Y. Posun kamery dolů = vidím víc nahoře.
        // Ale v "mapovém" ovládání: táhnu dolů -> chci vidět to co je nahoře -> posouvám viewbox nahoru (zmenšuji Y).
        // Počkat, táhnu dolů (movementY > 0). Chci posunout papír dolů.
        // Takže kamera (viewbox) jde nahoru?
        // Ano: vb.y -= dy.
        updateViewBox();
        requestAnimationFrame(drawDynamicGrid);
    });

    // Touch events
    let lastTouchX=0, lastTouchY=0;
    svg.addEventListener('touchstart', e => {
        isDragging = true;
        lastTouchX = e.touches[0].clientX;
        lastTouchY = e.touches[0].clientY;
    }, {passive:false});
    
    window.addEventListener('touchend', () => isDragging = false);
    
    svg.addEventListener('touchmove', e => {
        if(!isDragging) return;
        e.preventDefault(); // Stop scroll
        const tx = e.touches[0].clientX;
        const ty = e.touches[0].clientY;
        const dx = tx - lastTouchX;
        const dy = ty - lastTouchY;
        lastTouchX = tx; lastTouchY = ty;
        
        const scale = vb.w / svg.clientWidth;
        vb.x -= dx * scale;
        vb.y -= dy * scale;
        
        updateViewBox();
        requestAnimationFrame(drawDynamicGrid);
    }, {passive:false});


    const MIN_ZOOM = 0.05; 
    svg.addEventListener('wheel', e => {
        e.preventDefault();
        const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
        let newW = vb.w * zoomFactor;
        let newH = vb.h * zoomFactor;

        if (newW < MIN_ZOOM) {
            if (zoomFactor < 1) {
                newW = MIN_ZOOM; newH = MIN_ZOOM;
                if (vb.w <= MIN_ZOOM + 0.0001) return; 
            }
        }
        vb.w = newW; vb.h = newH;
        // Zoom to center (zjednodušené)
        // Lepší by bylo zoom k myši, ale stačí střed
        const cx = vb.x + (vb.w/1.1 - newW)/2; // oprava offsetu
        // Jednoduše: posunout x a y tak, aby střed zůstal
        // starý střed
        const oldCx = vb.x + (vb.w / zoomFactor) / 2;
        const oldCy = vb.y + (vb.h / zoomFactor) / 2;
        
        vb.x += (vb.w / zoomFactor - vb.w) / 2;
        vb.y += (vb.h / zoomFactor - vb.h) / 2;

        updateViewBox();
        drawDynamicGrid();
    }, {passive: false});

    function updateViewBox() {
        svg.setAttribute('viewBox', `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);
    }

    // --- GRID RENDERING ---
    function drawDynamicGrid() {
        gridLines.innerHTML = ''; 
        textGroup.innerHTML = '';
        axisGroup.innerHTML = '';

        const minDim = vb.w; // Je to čtverec
        const roughStep = minDim / 5; 
        
        const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));
        const residual = roughStep / magnitude;
        
        let step;
        if (residual < 2) step = 1 * magnitude;
        else if (residual < 5) step = 2 * magnitude;
        else step = 5 * magnitude;

        const subStep = step / 5;
        let decimals = Math.max(0, Math.ceil(-Math.log10(step)));
        if (step >= 1) decimals = 0;

        const fontSize = Math.max(minDim / 32, step/3.5); 
        const padding = fontSize * 3.0;

        // World Bounds
        const zMin = -(vb.y + vb.h); 
        const zMax = -vb.y;          
        const xMin = vb.x;           
        const xMax = vb.x + vb.w;    

        // Zarovnání na krok
        const startX = Math.floor(xMin / step) * step;
        const startZ = Math.floor(zMin / step) * step;

        createLine(axisGroup, -100000, 0, 100000, 0, 'axis-line');
        createLine(axisGroup, 0, -100000, 0, 100000, 'axis-line');

        // Sticky Logic (Clamp)
        const safeTop = vb.y + padding;
        const safeBottom = vb.y + vb.h - padding;
        let stickyY = Math.max(safeTop, Math.min(safeBottom, 0));
        
        let baseline = "hanging";
        let isBottom = false;
        if (Math.abs(stickyY - safeBottom) < 0.001) {
            baseline = "auto"; isBottom = true;
        } else if (Math.abs(stickyY - safeTop) < 0.001) {
            baseline = "hanging"; 
        } else {
            stickyY += fontSize * 0.6; baseline = "hanging";
        }

        // X Loop
        for (let x = startX; x < xMax + step; x += step) {
            if (x > xMax) break;
            createLine(gridLines, x, zMin, x, zMax, 'grid-line');
            for (let i = 1; i < 5; i++) {
                const subX = x + (subStep * i);
                if (subX < xMax) createLine(gridLines, subX, zMin, subX, zMax, 'grid-sub-line');
            }
            
            let staggerOffset = 0;
            const index = Math.round(x / step);
            if (index % 2 !== 0) {
                staggerOffset = (isBottom || baseline === "auto") ? -fontSize*1.2 : fontSize*1.2; 
            }

            const displayVal = isDiameterMode ? (x * 2) : x;
            const valStr = displayVal.toFixed(decimals);
            
            if (Math.abs(x) > step/100) { 
                addText(textGroup, x, stickyY + staggerOffset, valStr, fontSize, "middle", baseline);
            } else {
                addText(textGroup, x + fontSize/2, stickyY + staggerOffset, valStr, fontSize, "start", baseline);
            }
        }

        // Z Loop
        const safeLeft = vb.x + padding;
        const safeRight = vb.x + vb.w - padding;
        let stickyX = Math.max(safeLeft, Math.min(safeRight, 0));
        let anchor = "end";
        
        if (Math.abs(stickyX - safeRight) < 0.001) anchor = "end"; 
        else if (Math.abs(stickyX - safeLeft) < 0.001) anchor = "start"; 
        else { stickyX -= fontSize * 0.5; anchor = "end"; }

        for (let z = startZ; z < zMax + step; z += step) {
            if (z > zMax) break;
            createLine(gridLines, xMin, z, xMax, z, 'grid-line');
            for (let i = 1; i < 5; i++) {
                const subZ = z + (subStep * i);
                if (subZ < zMax) createLine(gridLines, xMin, subZ, xMax, subZ, 'grid-sub-line');
            }

            const valStr = z.toFixed(decimals);
            if (Math.abs(z) > step/100) {
                addText(textGroup, stickyX, -z + (fontSize/3), valStr, fontSize, anchor, "auto");
            } else {
                addText(textGroup, stickyX, -z - fontSize/2, valStr, fontSize, anchor, "auto");
            }
        }
    }
    
    function createLine(parent, x1, z1, x2, z2, className) {
        const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
        l.setAttribute("x1", x1); l.setAttribute("y1", z1);
        l.setAttribute("x2", x2); l.setAttribute("y2", z2);
        l.setAttribute("class", className); 
        parent.appendChild(l);
    }

    function addText(parent, screenX, screenY, textStr, size, anchor, baseline) {
        const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
        t.setAttribute("x", screenX);
        t.setAttribute("y", screenY);
        t.textContent = textStr;
        t.setAttribute("fill", "#666");
        t.setAttribute("font-size", size);
        t.setAttribute("font-family", "Consolas, monospace");
        t.setAttribute("font-weight", "bold");
        t.setAttribute("text-anchor", anchor || "middle");
        if(baseline) t.setAttribute("dominant-baseline", baseline);
        t.setAttribute("stroke", "rgba(255,255,255,0.9)");
        t.setAttribute("stroke-width", size/3);
        t.setAttribute("paint-order", "stroke");
        parent.appendChild(t);
    }

    // --- GAMEPLAY LOGIC ---
    function updatePath() {
        pathGroup.innerHTML = '';
        if(points.length === 0) return;

        const last = points[points.length-1];
        const xVal = isDiameterMode ? (last.x * 2) : last.x;
        document.getElementById('hud-x').innerText = xVal.toFixed(2);
        document.getElementById('lbl-x').innerText = isDiameterMode ? "Ø" : "R";
        document.getElementById('hud-z').innerText = last.z.toFixed(2);

        points.forEach((p, i) => {
            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute("cx", p.x); circle.setAttribute("cy", p.z);
            circle.setAttribute("class", i === points.length-1 ? "point-marker point-current" : "point-marker");
            const r_mm = 5 * (vb.w / (svg.clientWidth || 300));
            circle.setAttribute("r", r_mm); 
            pathGroup.appendChild(circle);

            if (i > 0 && !p.break) {
                const prev = points[i-1];
                const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
                l.setAttribute("x1", prev.x); l.setAttribute("y1", prev.z);
                l.setAttribute("x2", p.x); l.setAttribute("y2", p.z);
                l.setAttribute("class", "path-line");
                l.setAttribute("stroke-width", 2 * (vb.w / (svg.clientWidth || 300)));
                pathGroup.appendChild(l);
            }
        });
    }

    function fitToScreen() {
        if (points.length < 2) {
             setHomeView();
        } else {
            let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
            points.forEach(p => {
                if(p.x < minX) minX = p.x; if(p.x > maxX) maxX = p.x;
                if(p.z < minZ) minZ = p.z; if(p.z > maxZ) maxZ = p.z;
            });
            
            const contentW = maxX - minX;
            const contentH = maxZ - minZ;
            const maxDim = Math.max(contentW, contentH);
            const pad = maxDim * 0.2 + 10;
            
            const newSize = maxDim + pad*2;
            
            vb.w = newSize;
            vb.h = newSize;
            
            const midX = (minX + maxX) / 2;
            const midZ = (minZ + maxZ) / 2; 
            
            vb.x = midX - newSize/2;
            vb.y = -midZ - newSize/2; 
            
            if(vb.w < 10) { vb.w = 50; vb.h = 50; }
            
            updateViewBox();
            drawDynamicGrid();
        }
    }

    function toggleDiameterMode() {
        isDiameterMode = !isDiameterMode;
        localStorage.setItem('cnc_diameter_mode', isDiameterMode);
        updateDiameterButtonText();
        drawDynamicGrid();
        updatePath();
    }

    function updateDiameterButtonText() {
        const btn = document.getElementById('btn-toggle-dia');
        if(btn) btn.innerText = isDiameterMode ? "Režim: Ø" : "Režim: R";
    }

    function closeModals() { document.querySelectorAll('.modal').forEach(m => m.style.display = 'none'); }

    function prepMove(dir) {
        currentDir = dir;
        const m = document.getElementById('modal-input');
        const lin = document.getElementById('input-linear');
        const cpx = document.getElementById('input-complex');
        const tit = document.getElementById('input-title');

        document.getElementById('inp-len').value = '';
        document.getElementById('inp-x').value = '';
        document.getElementById('inp-z').value = '';
        document.getElementById('inp-a').value = '';

        m.style.display = 'flex';
        
        const isDiagonal = dir.length === 2; 
        
        if (isDiagonal) {
            lin.style.display = 'none';
            cpx.style.display = 'block';
            document.getElementById('lbl-inp-x').innerText = isDiameterMode ? "Cílový Průměr X (mm):" : "Cílový Poloměr X (mm):";
            tit.innerText = "Kužel / Úkos";
            let angle = '';
            if(dir === 'UR') angle = 45;
            if(dir === 'UL') angle = 135;
            if(dir === 'DL') angle = 225;
            if(dir === 'DR') angle = 315;
            document.getElementById('inp-a').value = angle;
        } else {
            lin.style.display = 'block';
            cpx.style.display = 'none';
            let txt = "Posun ";
            if(dir === 'U') txt += "Nahoru (Z+)";
            if(dir === 'D') txt += "Dolů (Z-)";
            if(dir === 'L') txt += "Doleva (X-)";
            if(dir === 'R') txt += "Doprava (X+)";
            tit.innerText = txt;
            document.getElementById('inp-len').focus();
        }
    }

    function commitMove() {
        const last = points[points.length - 1];
        let next = { x: last.x, z: last.z };
        const isDiagonal = currentDir.length === 2;
        
        if (!isDiagonal) {
            const valStr = document.getElementById('inp-len').value.replace(',', '.');
            const len = parseFloat(valStr);
            if(isNaN(len)) return;
            if(currentDir === 'U') next.z += len;
            if(currentDir === 'D') next.z -= len;
            if(currentDir === 'R') next.x += len; 
            if(currentDir === 'L') next.x -= len;
        } else {
            const txStr = document.getElementById('inp-x').value.replace(',', '.');
            const tzStr = document.getElementById('inp-z').value.replace(',', '.');
            const taStr = document.getElementById('inp-a').value.replace(',', '.');
            const targetX_Input = txStr; const targetZ = tzStr;
            const angleDeg = parseFloat(taStr);
            
            if(isNaN(angleDeg)) { alert("Zadejte úhel!"); return; }
            const rad = angleDeg * (Math.PI / 180);
            
            if(targetZ !== "" && targetX_Input === "") {
                next.z = parseFloat(targetZ);
                if(Math.abs(Math.abs(angleDeg)-90) > 0.1 && Math.abs(Math.abs(angleDeg)-270) > 0.1) {
                     next.x = last.x + (next.z - last.z) / Math.tan(rad);
                }
            } else if(targetX_Input !== "") {
                const valX = parseFloat(targetX_Input);
                next.x = isDiameterMode ? (valX / 2) : valX; 
                next.z = last.z + (next.x - last.x) * Math.tan(rad);
            } else {
                alert("Zadejte alespoň cílové X nebo Z!"); return;
            }
        }
        points.push(next);
        updatePath();
        closeModals();
    }

    function resetOrigin() { points = [{x: 0, z: 0, break: true}]; updatePath(); closeModals(); }
    function clearAll() { points = [{x: 0, z: 0, break: false}]; updatePath(); closeModals(); }

</script>
</body>
</html>
