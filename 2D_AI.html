<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0a0a0a">
    <title>Soustru≈æn√≠k - Parametrick√© kreslen√≠ + AI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh; /* Dynamick√° v√Ω≈°ka pro mobily */
            overflow: hidden;
            margin: 0;
            padding: 0;
        }

        .tool-group {
            margin-bottom: 15px;
            background: #222;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #333;
        }

        .tool-group h3 {
            color: #6ab0ff;
            margin: 0 0 10px 0;
            font-size: 14px;
            user-select: none;
        }
        
        .tool-group h3[onclick] {
            transition: color 0.2s;
        }
        
        .tool-group h3[onclick]:hover {
            color: #8ac0ff;
        }
        
        .tool-group > div[id$="Section"] {
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
        }

        .input-group {
            margin-bottom: 10px;
        }

        .input-group label {
            display: block;
            margin-bottom: 4px;
            color: #b0b0b0;
            font-size: 12px;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 8px;
            background: #0a0a0a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .btn {
            width: 100%;
            padding: 10px;
            background: #3a7bc8;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 8px;
            transition: background 0.2s;
        }

        .btn:active {
            background: #5a9be8;
        }

        .preset-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin: 8px 0;
        }

        .preset-btn {
            padding: 8px;
            background: #2a4a4a;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .preset-btn:active {
            background: #3a5a5a;
        }

        .calc-result {
            background: #1a2a1a;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            border: 1px solid #2a4a2a;
            font-size: 11px;
            line-height: 1.5;
        }

        .result-title {
            color: #90ee90;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .canvas-area {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #0a0a0a;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            touch-action: none;
            width: 100%;
            height: 100%;
        }

        /* --- TOOLBAR --- */
        .toolbar {
            position: absolute;
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            
            background: rgba(15, 15, 15, 0.98);
            backdrop-filter: blur(10px);
            border: 1px solid #333;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.6);
        }
        
        /* Desktop a tablet - dole */
        @media (min-width: 769px) {
            .toolbar {
                bottom: 0;
                left: 0;
                right: 0;
                flex-direction: row;
                border-top: 1px solid #333;
                border-left: none;
                border-right: none;
                border-bottom: none;
                padding: 10px;
                padding-bottom: max(10px, env(safe-area-inset-bottom));
            }
        }
        
        /* Mobil na ≈°√≠≈ôku - vpravo */
        @media (max-width: 768px) and (orientation: landscape) {
            .toolbar {
                top: 10px;
                bottom: 10px;
                right: 10px;
                left: auto;
                flex-direction: column;
                padding: 10px 8px;
                border-radius: 12px;
                gap: 12px;
                max-height: calc(100vh - 20px);
                overflow-y: auto;
            }
        }
        
        /* Mobil na v√Ω≈°ku - dole uvnit≈ô canvasu s offsetem */
        @media (max-width: 768px) and (orientation: portrait) {
            .toolbar {
                bottom: max(30px, calc(20px + env(safe-area-inset-bottom)));
                left: 50%;
                right: auto;
                transform: translateX(-50%);
                flex-direction: row;
                flex-wrap: nowrap;
                padding: 5px 3px;
                border-radius: 12px;
                gap: 3px; /* Minim√°ln√≠ mezery */
                width: auto;
                max-width: 98%;
                justify-content: center;
            }
        }

        /* --- SUBMENU NAD TOOLBAREM --- */
        .tool-submenu {
            position: absolute;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            z-index: 999;
            justify-content: center;
            animation: slideUp 0.2s ease-out;
            pointer-events: none;
        }
        
        .tool-submenu > * {
            pointer-events: auto;
        }
        
        /* Desktop - nad toolbarem */
        @media (min-width: 769px) {
            .tool-submenu {
                bottom: 70px;
                left: 10px;
                right: 10px;
            }
        }
        
        /* Mobil na ≈°√≠≈ôku - vlevo od toolbaru */
        @media (max-width: 768px) and (orientation: landscape) {
            .tool-submenu {
                top: 50%;
                right: 80px;
                left: 10px;
                transform: translateY(-50%);
                animation: slideLeft 0.2s ease-out;
            }
            
            @keyframes slideLeft {
                from { transform: translateY(-50%) translateX(10px); opacity: 0; }
                to { transform: translateY(-50%) translateX(0); opacity: 1; }
            }
        }
        
        /* Mobil na v√Ω≈°ku - nad toolbarem uvnit≈ô canvasu */
        @media (max-width: 768px) and (orientation: portrait) {
            .tool-submenu {
                bottom: max(120px, calc(110px + env(safe-area-inset-bottom))); /* Nad toolbarem */
                left: 10px;
                right: 10px;
            }
        }
        
        /* Zv√Ω≈°en√≠ z-indexu pro AI panel, aby byl nad canvas controls */
        #toolsAi {
            z-index: 1001; /* Nad toolbarem */
        }

        /* --- TOUCH CURSOR (k≈ô√≠≈æek nad prstem na mobilu) --- */
        .touch-cursor {
            position: absolute;
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 10000;
            display: none;
            transform: translate(-50%, -50%);
        }
        
        .touch-cursor.active {
            display: block;
            animation: touchCursorAppear 0.2s ease-out;
        }
        
        @keyframes touchCursorAppear {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        
        .touch-cursor::before,
        .touch-cursor::after {
            content: '';
            position: absolute;
            background: #ff4444;
            box-shadow: 0 0 10px rgba(255, 68, 68, 0.8),
                        0 0 3px rgba(255, 255, 255, 0.9);
        }
        
        /* Vertik√°ln√≠ ƒç√°ra */
        .touch-cursor::before {
            width: 2px;
            height: 40px;
            left: 50%;
            top: 0;
            transform: translateX(-50%);
        }
        
        /* Horizont√°ln√≠ ƒç√°ra */
        .touch-cursor::after {
            width: 40px;
            height: 2px;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }
        
        /* St≈ôed k≈ô√≠≈æku - mal√Ω krou≈æek */
        .touch-cursor-center {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #ff4444;
            border: 2px solid white;
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 5px rgba(255, 68, 68, 0.8);
        }

        .tool-submenu > * {
            pointer-events: auto;
        }

        @keyframes slideUp {
            from { transform: translateY(10px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .coords-panel {
            justify-content: center; /* Na mobilu radƒõji na st≈ôed */
            max-width: 500px;
            margin: 0 auto;
        }
        
        /* --- OVL√ÅD√ÅN√ç PL√ÅTNA (VPRAVO NAHO≈òE) --- */
        .canvas-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 101;
        }

        .canvas-btn {
            background: rgba(42, 42, 42, 0.9);
            border: 1px solid #555;
            color: white;
            width: 48px;
            height: 48px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            backdrop-filter: blur(5px);
            transition: all 0.2s;
        }
        
        .canvas-btn span {
            font-size: 20px;
        }
        
        .canvas-btn div {
            font-size: 9px;
            margin-top: 2px;
        }

        .canvas-btn:active {
            transform: scale(0.95);
        }

        .canvas-btn.active {
            background: #3a7bc8;
            border-color: #5a9be8;
            box-shadow: 0 0 10px rgba(58, 123, 200, 0.5);
        }

        @media (max-width: 768px) {
            .toolbar {
                gap: 10px;
            }
            
            /* Mobil na v√Ω≈°ku - men≈°√≠ tlaƒç√≠tka, podobn√© jako Posun/Centr */
            @media (orientation: portrait) {
                .toolbar {
                    bottom: max(30px, calc(20px + env(safe-area-inset-bottom)));
                    left: 50%;
                    right: auto;
                    transform: translateX(-50%);
                    width: auto;
                    max-width: 98%;
                }
                
                .toolbar .tool-btn {
                    min-width: 48px !important;
                    max-width: 48px !important;
                    min-height: 56px !important;
                    width: 48px !important;
                    height: auto !important;
                    padding: 4px 2px !important;
                    flex: 0 0 auto;
                }
                
                .toolbar .tool-btn span {
                    font-size: 20px !important;
                    margin: 0 !important;
                }
                
                .toolbar .tool-btn div {
                    font-size: 8px !important;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    max-width: 48px;
                    margin-top: 2px !important;
                }
            }
            
            /* Mobil na ≈°√≠≈ôku - standardn√≠ velikost */
            @media (orientation: landscape) {
                .tool-btn {
                    min-width: 60px;
                    min-height: 60px;
                    padding: 6px 8px;
                }
                
                .tool-btn span {
                    font-size: 20px !important;
                }
                
                .tool-btn div {
                    font-size: 10px !important;
                }
            }
            
            /* Controller Modal - Responzivn√≠ pro mobil */
            #controllerModal .modal-window {
                width: 95%;
                max-width: 100%;
                padding: 15px;
                max-height: 90vh;
                overflow-y: auto;
            }
            
            /* Zmƒõna layoutu na vertik√°ln√≠ pro mobil */
            #controllerLayout {
                display: flex !important;
                flex-direction: column !important;
                gap: 15px !important;
            }
            
            /* Smƒõrov√© tlaƒç√≠tka - men≈°√≠ na mobilu */
            .controller-btn {
                width: 55px !important;
                height: 55px !important;
            }
            
            .controller-btn span {
                font-size: 24px !important;
            }
            
            /* Grid pro smƒõrov√° tlaƒç√≠tka */
            #directionPad {
                grid-template-columns: repeat(3, 55px) !important;
                grid-template-rows: repeat(3, 55px) !important;
                gap: 3px !important;
            }
            
            /* Mini kl√°vesnice - men≈°√≠ tlaƒç√≠tka */
            .mini-key, .mini-key-action, .mini-key-back {
                padding: 5px !important;
                font-size: 11px !important;
            }
            
            .mini-key span, .mini-key-action span {
                font-size: 6px !important;
            }
            
            /* Nadpisy v controlleru men≈°√≠ */
            #controllerModal h2 {
                font-size: 14px !important;
            }
            
            #controllerModal h4 {
                font-size: 10px !important;
            }
            
            /* Controller input pole */
            #controllerInput {
                font-size: 13px !important;
                padding: 7px !important;
            }
            
            /* G90/G91 tlaƒç√≠tka */
            #btnG90, #btnG91 {
                padding: 6px 8px !important;
                font-size: 10px !important;
            }
            
            /* Confirm button */
            #controllerModal button[onclick="confirmControllerInput()"] {
                padding: 8px 12px !important;
                font-size: 14px !important;
            }
            
            /* Quick Input Keyboard - men≈°√≠ tlaƒç√≠tka */
            .keypad-btn {
                padding: 8px 0 !important;
                font-size: 14px !important;
            }
            
            .keypad-btn span {
                font-size: 8px !important;
            }
            
            /* Quick Input Modal */
            #quickInputModal .modal-window {
                width: 95%;
                max-width: 100%;
            }
            
            /* Canvas controls - men≈°√≠ na mobilu */
            .canvas-btn {
                width: 44px !important;
                height: 44px !important;
            }
            
            .canvas-btn span {
                font-size: 18px !important;
            }
            
            .canvas-btn small {
                font-size: 9px !important;
            }
        }
        
        /* Velmi mal√© displeje (mobily v portr√©tn√≠m m√≥du) */
        @media (max-width: 480px) {
            /* Toolbar - je≈°tƒõ men≈°√≠ tlaƒç√≠tka */
            .toolbar {
                gap: 6px;
                padding: 8px;
            }
            
            .tool-btn {
                min-width: 50px;
                min-height: 50px;
                padding: 4px 6px;
            }
            
            .tool-btn span {
                font-size: 18px !important;
            }
            
            .tool-btn div {
                font-size: 9px !important;
            }
            
            /* Controller - je≈°tƒõ men≈°√≠ */
            .controller-btn {
                width: 48px !important;
                height: 48px !important;
            }
            
            .controller-btn span {
                font-size: 20px !important;
            }
            
            #directionPad {
                grid-template-columns: repeat(3, 48px) !important;
                grid-template-rows: repeat(3, 48px) !important;
                gap: 2px !important;
            }
            
            /* Controller modal - scrollov√°n√≠ */
            #controllerModal .modal-window {
                max-height: 95vh;
                overflow-y: auto;
            }
            
            /* Mini kl√°vesnice v controlleru - je≈°tƒõ men≈°√≠ */
            .mini-key, .mini-key-action, .mini-key-back {
                padding: 4px !important;
                font-size: 10px !important;
            }
            
            .mini-key span, .mini-key-action span {
                font-size: 5px !important;
            }
            
            /* Controller input a tlaƒç√≠tka */
            #controllerInput {
                font-size: 12px !important;
                padding: 6px !important;
            }
            
            #btnG90, #btnG91 {
                padding: 5px 6px !important;
                font-size: 9px !important;
            }
            
            #controllerModal h2 {
                font-size: 12px !important;
            }
            
            #controllerModal h4 {
                font-size: 9px !important;
            }
            
            /* Mod√°ln√≠ okna - maxim√°ln√≠ vyu≈æit√≠ prostoru */
            .modal-window {
                width: 98%;
                padding: 12px;
            }
            
            #controllerModal h2 {
                font-size: 13px !important;
            }
            
            /* Keypad - kompaktnƒõj≈°√≠ */
            .keypad-grid {
                gap: 5px !important;
            }
            
            .keypad-btn {
                padding: 6px 0 !important;
                font-size: 13px !important;
            }
        }

        .tool-btn {
            background: rgba(42, 42, 42, 1);
            border: 1px solid #444;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            min-width: 65px;
            min-height: 65px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            user-select: none;
            /* Lep≈°√≠ st√≠n pro oddƒõlen√≠ od pozad√≠ */
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .tool-btn:hover {
            background: rgba(58, 123, 200, 0.8);
            border-color: #5a9be8;
            transform: translateY(-2px);
        }

        .tool-btn:active, .tool-btn.active {
            background: #3a7bc8;
            border-color: #5a9be8;
            box-shadow: 0 0 15px rgba(58, 123, 200, 0.6);
            transform: translateY(0);
        }

        /* --- AI STYL --- */
        .tool-btn.ai-btn {
            border-color: #8b5cf6;
            color: #e9d5ff;
        }
        
        .tool-btn.ai-btn.active {
            background: #7c3aed;
            border-color: #a78bfa;
            box-shadow: 0 0 15px rgba(124, 58, 237, 0.6);
        }
        
        /* CHAT STYLES */
        .chat-container {
            max-height: 40vh; /* Dynamic height to avoid overlapping top buttons */
            min-height: 150px;
            overflow-y: auto; 
            background: #111; 
            border: 1px solid #444; 
            border-radius: 6px; 
            padding: 10px; 
            margin-bottom: 10px; 
            display: flex; 
            flex-direction: column; 
            gap: 12px;
        }

        .chat-msg {
            padding: 10px 14px;
            border-radius: 12px;
            max-width: 85%;
            font-size: 13px;
            line-height: 1.4;
            word-wrap: break-word;
            position: relative;
        }

        .chat-msg.user {
            align-self: flex-end;
            background: #3a7bc8;
            color: white;
            border-bottom-right-radius: 2px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .chat-msg.model {
            align-self: flex-start;
            background: #2a2a2a;
            color: #e0e0e0;
            border-bottom-left-radius: 2px;
            border: 1px solid #444;
        }

        .chat-msg .shape-tag {
            display: inline-block;
            background: rgba(0,0,0,0.3);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            margin-right: 4px;
            margin-top: 4px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .loading-dots {
            display: inline-flex;
            gap: 4px;
        }
        .loading-dots div {
            width: 6px; height: 6px;
            background: #aaa;
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out both;
        }
        .loading-dots div:nth-child(1) { animation-delay: -0.32s; }
        .loading-dots div:nth-child(2) { animation-delay: -0.16s; }
        
        @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1); } }

        .loading-spinner {
            width: 14px;
            height: 14px;
            border: 2px solid #fff;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { from {transform: rotate(0deg);} to {transform: rotate(360deg);} }
        
        /* RECORDING ANIMATION */
        .recording-pulse {
            animation: pulse-red 1.5s infinite;
            background: #ef4444 !important;
            border-color: #dc2626 !important;
        }
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
        
        /* SELECTION CHIPS */
        .selection-list {
            display: flex;
            gap: 6px;
            overflow-x: auto;
            padding-bottom: 6px;
            margin-bottom: 8px;
        }
        
        .selection-chip {
            background: #2a2a2a;
            border: 1px solid #ff66ff;
            color: #ffccff;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .selection-chip .letter-badge {
            background: #ff66ff;
            color: #000;
            font-weight: bold;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        /* --- SETTINGS & QUICK INPUT MODAL STYL --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(4px);
            z-index: 2000;
            display: none; /* Default hidden */
            align-items: center;
            justify-content: center;
        }
        
        .modal-window {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 12px;
            width: 90%;
            max-width: 450px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            color: #e0e0e0;
        }
        
        /* Quick Input Display inside modal */
        .quick-input-display {
            width: 100%;
            background: #000;
            color: #0f0; /* CNC Screen style */
            font-family: 'Courier New', monospace;
            font-size: 16px;
            font-weight: bold;
            padding: 12px;
            border: 1px solid #444;
            border-radius: 6px;
            margin-bottom: 12px;
            resize: none;
            outline: none;
            height: 60px;
        }
        
        /* KEYPAD GRID */
        .keypad-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            margin-top: 5px;
        }
        
        .keypad-btn {
            background: #2a2a2a;
            border: 1px solid #444;
            color: white;
            padding: 10px 0;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: background 0.1s;
        }
        
        .keypad-btn:active {
            background: #666;
            transform: translateY(2px);
        }
        
        .keypad-btn span {
            font-size: 9px;
            font-weight: normal;
            color: #888;
            margin-top: 2px;
        }
        
        .keypad-btn.action {
            background: #333;
            border-color: #555;
        }
        
        .keypad-btn.cnc-code {
            background: #2d3748; /* Blueish grey for G-code */
            border-color: #4a5568;
            color: #90cdf4;
        }
        
        .keypad-btn.confirm {
            grid-column: span 3;
            background: #3a7bc8;
            border-color: #5a9be8;
            padding: 12px;
        }
        
        .keypad-btn.backspace {
            background: #7f1d1d;
            border-color: #991b1b;
        }
        
        .keypad-btn.help {
            background: #1e3a5f;
            border-color: #2d5a8f;
            color: #90cdf4;
        }
        
        /* Controller Modal Styles */
        .controller-btn {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            border: 2px solid #4a5568;
            color: #e2e8f0;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .controller-btn:hover {
            background: linear-gradient(135deg, #3d4758 0%, #2a303c 100%);
            border-color: #6b7280;
            transform: scale(1.05);
        }
        
        .controller-btn:active {
            background: linear-gradient(135deg, #4a5568 0%, #374151 100%);
            transform: scale(0.98);
            box-shadow: 0 1px 4px rgba(0,0,0,0.4);
        }
        
        .mini-key, .mini-key-action, .mini-key-back {
            background: #2d3748;
            border: 1px solid #4a5568;
            color: #e2e8f0;
            border-radius: 6px;
            padding: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.15s;
        }
        
        .mini-key:hover, .mini-key-action:hover {
            background: #374151;
            border-color: #6b7280;
        }
        
        .mini-key:active, .mini-key-action:active {
            background: #4a5568;
            transform: scale(0.95);
        }
        
        .mini-key-action {
            background: #1e3a5f;
            border-color: #2d5a8f;
            color: #90cdf4;
        }
        
        .mini-key-back {
            background: #7f1d1d;
            border-color: #991b1b;
            color: white;
        }
        
        .mini-key-back:hover {
            background: #991b1b;
        }

        .key-list {
            max-height: 200px;
            overflow-y: auto;
            margin: 10px 0;
            background: #111;
            border: 1px solid #333;
            border-radius: 6px;
        }

        .key-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid #333;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .key-item:last-child {
            border-bottom: none;
        }

        .key-item:hover {
            background: #252525;
        }

        .key-item.active {
            background: #2a3a2a;
            border-left: 3px solid #4ade80;
        }
        
        /* Styl pro demo kl√≠ƒç (defaultn√≠) */
        .key-item.demo-active {
            background: #2a2a3a;
            border-left: 3px solid #a78bfa;
        }

        .key-name {
            font-weight: bold;
            font-size: 14px;
            color: #fff;
        }

        .key-val {
            font-size: 11px;
            color: #777;
            font-family: monospace;
        }

        .key-delete {
            padding: 4px 8px;
            background: #991b1b;
            color: white;
            border-radius: 4px;
            font-size: 11px;
            border: none;
            cursor: pointer;
        }
        
        .key-save {
            padding: 4px 8px;
            background: #3a7bc8;
            color: white;
            border-radius: 4px;
            font-size: 11px;
            border: none;
            cursor: pointer;
        }

        /* --- INFO PANELY NAHO≈òE --- */
        .coords {
            position: absolute;
            top: 10px;      /* Naho≈ôe */
            left: 10px;     /* Vlevo */
            bottom: auto;
            
            background: rgba(26, 26, 26, 0.8);
            backdrop-filter: blur(4px);
            padding: 8px 12px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border: 1px solid #444;
            pointer-events: none; /* Aby ≈°lo klikat skrz */
        }

        .snap-info {
            position: absolute;
            top: 45px;      /* Pod sou≈ôadnicemi */
            left: 10px;
            bottom: auto;
            right: auto;
            transform: none;
            
            background: rgba(26, 26, 26, 0.9);
            padding: 8px 12px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: normal;
            
            color: #ffd700;
            border: 1px solid #ffd700;
            
            display: none;
            z-index: 200;
            pointer-events: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }

        .snap-info.show {
            display: block;
        }

        .mode-info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(74, 158, 255, 0.9);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 500;
            color: white;
            display: none;
            z-index: 90;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            pointer-events: none;
        }

        .mode-info.show {
            display: block;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 0;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin: 0;
        }
        
        /* --- DIALOG KRU≈ΩNICE STYL --- */
        .circle-input-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }
        .circle-input-row label {
            width: 80px;
            font-size: 13px;
            color: #ccc;
        }
        .circle-input-row input {
            flex: 1;
            background: #111;
            border: 1px solid #444;
            color: white;
            padding: 8px;
            border-radius: 4px;
        }
    </style>
    <!-- Import Map for Google GenAI -->
    <script type="importmap">
{
  "imports": {
    "@google/genai": "https://esm.sh/@google/genai@^1.33.0"
  }
}
</script>
</head>
<body>
    <div class="canvas-area">
        <!-- Ovl√°d√°n√≠ pl√°tna vpravo naho≈ôe -->
        <div class="canvas-controls">
            <!-- Tlaƒç√≠tko nastaven√≠ odstranƒõno z hlavn√≠ho pohledu a p≈ôesunuto do AI panelu -->
            <button class="canvas-btn" onclick="togglePan()" id="btnPanCanvas" title="Posun (Klikni pro zapnut√≠/vypnut√≠)">
                <span>‚úã</span>
                <div>Posun</div>
            </button>
            <button class="canvas-btn" onclick="resetView()" title="Vycentrovat pohled">
                <span>‚åñ</span>
                <div>Centr</div>
            </button>
        </div>

        <!-- Submenu se vykresluj√≠ zde (nad toolbarem) -->
        
        <!-- === AI PANEL (NOV√ù CHAT) === -->
        <div class="tool-submenu" id="toolsAi" style="display: none; justify-content: center; width: 100%;">
            <!-- position: relative pro kontejner, aby bylo tlaƒç√≠tko absolutnƒõ k nƒõmu -->
            <div id="aiPanelContainer" style="position: relative; background: rgba(26, 26, 26, 0.95); padding: 15px; border-radius: 12px; border: 1px solid #555; width: 95%; max-width: 500px; box-shadow: 0 4px 25px rgba(0,0,0,0.6);">
                
                <!-- HEADER ROW (Title + Settings) -->
                <div id="aiHeaderRow" style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                    <div>
                        <h3 style="color: #a78bfa; margin: 0 0 5px 0; font-weight: bold; display: flex; align-items: center; gap: 8px;">
                            ‚ú® Gemini Chat
                        </h3>
                    </div>
                    
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <!-- P≈ôep√≠naƒç modelu - CLEANED UP FOR STABILITY -->
                        <select id="aiModelSelect" style="background: #111; color: #888; border: 1px solid #444; padding: 4px 8px; border-radius: 4px; font-size: 11px; cursor: pointer; outline: none;">
                            <option value="gemini-2.5-flash" selected>‚ö° Gemini 2.5 Flash (Rychl√Ω)</option>
                            <option value="gemini-3-pro-preview">üß™ Gemini 3 Pro (Nejchyt≈ôej≈°√≠)</option>
                            <option value="gemini-2.0-flash-exp">‚ö° Gemini 2.0 Flash (Exp)</option>
                        </select>
                        
                        <!-- Debug Metrics Button -->
                        <button onclick="showAIMetrics()" title="Zobrazit AI statistiky" style="background: transparent; border: none; cursor: pointer; color: #888; transition: color 0.2s; padding: 4px;">
                            <span style="font-size: 16px;">üìä</span>
                        </button>
                        
                        <!-- Settings Button -->
                        <button onclick="openSettings()" title="Nastaven√≠ API kl√≠ƒçe" style="background: transparent; border: none; cursor: pointer; color: #888; transition: color 0.2s; padding: 4px;">
                            <span style="font-size: 18px;">‚öôÔ∏è</span>
                        </button>
                    </div>
                </div>

                <!-- Historie chatu -->
                <div id="aiChatHistory" class="chat-container">
                    <div style="color: #666; font-size: 11px; text-align: center; margin-top: auto;">
                        Zaƒç√°tek konverzace. Zeptejte se na cokoliv nebo popi≈°te tvar.
                    </div>
                    
                    <!-- Informace o povolen√≠ pro mobil -->
                    <div id="permissionInfo" style="margin: 15px auto; padding: 10px; background: #1a2332; border: 1px solid #2563eb; border-radius: 8px; max-width: 90%; font-size: 10px; color: #93c5fd;">
                        <div style="margin-bottom: 6px; font-weight: bold; color: #60a5fa; font-size: 11px;">‚ÑπÔ∏è Pro plnou funkƒçnost na mobilu:</div>
                        <div style="margin-bottom: 4px;">üì∑ <strong>Kamera</strong> - pro focen√≠ n√°ƒçrt≈Ø</div>
                        <div>üé§ <strong>Mikrofon</strong> - pro hlasov√© zad√°v√°n√≠</div>
                        <div style="margin-top: 6px; font-size: 9px; opacity: 0.7;">Povolen√≠ se vy≈æ√°daj√≠ p≈ôi prvn√≠m pou≈æit√≠.</div>
                        <button onclick="document.getElementById('permissionInfo').style.display='none'" style="margin-top: 8px; padding: 4px 8px; background: #1e40af; border: none; border-radius: 4px; color: white; font-size: 10px; cursor: pointer;">
                            Rozum√≠m
                        </button>
                    </div>
                </div>
                
                <!-- Selection & Tools Toolbar (MOVED TOOLS HERE) -->
                <div style="display: flex; gap: 6px; margin-bottom: 8px; align-items: center; flex-wrap: wrap;">
                     <button id="btnAiSelect" onclick="window.toggleAiSelect()" style="flex: 0 0 70px; padding: 8px 4px; background: #333; border: 1px solid #444; border-radius: 6px; color: #ccc; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 4px; font-size: 11px; transition: all 0.2s;" title="P≈ôepnout re≈æim v√Ωbƒõru">
                        <span style="font-size: 14px;">üëÜ</span> V√Ωbƒõr
                    </button>
                    
                    <button onclick="window.openQuickInput()" style="flex: 1; padding: 8px 4px; background: #333; border: 1px solid #444; border-radius: 6px; color: white; cursor: pointer; font-size: 11px; display: flex; align-items: center; justify-content: center; gap: 4px; min-width: 90px;" title="Rychl√© zad√°n√≠ (Kl√°vesnice)">
                        <span style="font-size: 16px;">‚å®Ô∏è</span> Kl√°vesnice
                    </button>
                    
                    <button onclick="window.aiUndo()" style="flex: 0 0 36px; padding: 8px 0; background: #333; border: 1px solid #444; border-radius: 6px; color: white; cursor: pointer; font-size: 16px;" title="Zpƒõt (Undo posledn√≠ AI akce)">
                        ‚Ü∂
                    </button>
                    
                    <button onclick="window.aiRedo()" style="flex: 0 0 36px; padding: 8px 0; background: #333; border: 1px solid #444; border-radius: 6px; color: white; cursor: pointer; font-size: 16px;" title="Dop≈ôedu (Redo)">
                        ‚Ü∑
                    </button>
                    
                    <!-- MOVED CAMERA -->
                    <button onclick="document.getElementById('aiImageInput').click()" title="Nahr√°t obr√°zek / Vyfotit (vy≈æaduje povolen√≠ kamery na mobilu)" style="flex: 0 0 36px; padding: 8px 0; background: #333; color: white; border: 1px solid #444; border-radius: 6px; font-size: 16px; cursor: pointer;">
                        üì∑
                    </button>
                    <input type="file" id="aiImageInput" accept="image/*" capture="environment" style="display: none;" onchange="window.handleImageSelect(this)">
                    
                    <!-- MOVED VOICE -->
                    <button onclick="window.toggleVoice()" id="btnVoice" title="Hlasov√© zad√°n√≠ (vy≈æaduje povolen√≠ mikrofonu)" style="flex: 0 0 36px; padding: 8px 0; background: #333; color: white; border: 1px solid #444; border-radius: 6px; font-size: 16px; cursor: pointer; transition: all 0.2s;">
                        üé§
                    </button>
                    
                    <button onclick="window.clearSelection()" id="btnClearSelection" style="flex: 0 0 36px; padding: 8px 0; background: #991b1b; border: 1px solid #991b1b; border-radius: 6px; color: white; cursor: pointer; font-size: 14px; display: none;" title="Zru≈°it v√Ωbƒõr">
                        ‚úï
                    </button>
                </div>
                
                <!-- Selection List (Horizontal Chips) -->
                <div id="aiSelectionList" class="selection-list" style="display: none;">
                    <!-- Chips inserted via JS -->
                </div>
                
                <!-- Input z√≥na (SIMPLIFIED) -->
                <div id="aiInputZone">
                    <!-- NEW THINKING CHECKBOX (DEEP THINK) -->
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 11px; color: #a78bfa; cursor: pointer; user-select: none;">
                            <input type="checkbox" id="useThinking" style="width: 14px; height: 14px; accent-color: #7c3aed;"> 
                            <span>üß† Deep Think <span style="opacity: 0.7;">(Gemini 3 Pro)</span></span>
                        </label>
                        <span id="aiFileName" style="font-size: 10px; color: #888; max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"></span>
                    </div>

                    <!-- Nahr√°v√°n√≠ obr√°zku (mini preview) -->
                    <div id="aiImagePreview" style="display: none; margin-bottom: 6px; position: relative; background: #111; padding: 4px; border-radius: 4px; width: fit-content;">
                        <img id="aiPreviewImg" style="max-height: 60px; max-width: 100%; border-radius: 2px; display: block;">
                        <button onclick="window.clearImage()" style="position: absolute; top: -5px; right: -5px; background: #ef4444; color: white; border: 1px solid #991b1b; border-radius: 50%; width: 18px; height: 18px; font-size: 10px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-weight: bold;">‚úï</button>
                    </div>

                    <div style="display: flex; gap: 8px; align-items: flex-end;">
                        <!-- Buttons removed from here, expanded text area -->
                        <div style="flex: 1; position: relative;">
                            <textarea id="aiPrompt" rows="1" placeholder="Zpr√°va pro Gemini..." onkeydown="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); window.callGemini(); }" style="resize: none; width: 100%; padding: 10px; background: #0a0a0a; border: 1px solid #444; border-radius: 6px; color: #fff; font-family: inherit; max-height: 80px; overflow-y: auto;"></textarea>
                        </div>
                        
                        <button onclick="window.callGemini()" id="btnGenerate" style="padding: 10px; background: #7c3aed; color: white; border: none; border-radius: 6px; font-weight: bold; cursor: pointer;">
                            ‚û§
                        </button>
                    </div>
                    
                    <div id="aiStatus" style="margin-top: 8px; font-size: 10px; color: #555; text-align: center; display: flex; justify-content: space-between;">
                        <span id="keyIndicator">API Kl√≠ƒç: ≈Ω√°dn√Ω</span>
                    </div>
                </div>

            </div>
        </div>

        <!-- Kreslen√≠ panel -->
        <div class="tool-submenu" id="toolsDrawing" style="display: none;">
            <div style="background: rgba(26, 26, 26, 0.95); padding: 12px; border-radius: 8px; border: 1px solid #444; max-width: 500px; box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
                <div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: center;">
                    <!-- V√Ωbƒõr removed from here -->

                    <!-- Z√°kladn√≠ n√°stroje -->
                    <button class="tool-btn" onclick="setMode('line')" id="btnLine" title="Nakreslit ƒç√°ru" style="margin: 0;">
                        <span style="font-size: 20px;">üìè</span>
                        <div style="font-size: 10px; margin-top: 2px;">ƒå√°ra</div>
                    </button>
                    <button class="tool-btn" onclick="setMode('circle')" id="btnCircle" title="Nakreslit kru≈ænici" style="margin: 0;">
                        <span style="font-size: 20px;">‚≠ï</span>
                        <div style="font-size: 10px; margin-top: 2px;">Kru≈ænice</div>
                    </button>
                    <button class="tool-btn" onclick="setMode('point')" id="btnPoint" title="Vytvo≈ôit bod" style="margin: 0;">
                        <span style="font-size: 20px;">üìç</span>
                        <div style="font-size: 10px; margin-top: 2px;">Bod</div>
                    </button>
                    
                    <!-- Konstrukce -->
                    <button class="tool-btn" onclick="setMode('tangent')" id="btnTangent" title="Teƒçna ke kru≈ænici" style="margin: 0;">
                        <span style="font-size: 20px;">‚üÇ</span>
                        <div style="font-size: 10px; margin-top: 2px;">Teƒçna</div>
                    </button>
                    <button class="tool-btn" onclick="setMode('perpendicular')" id="btnPerpendicular" title="Kolmice" style="margin: 0;">
                        <span style="font-size: 20px;">‚î¥</span>
                        <div style="font-size: 10px; margin-top: 2px;">Kolmice</div>
                    </button>
                    <button class="tool-btn" onclick="setMode('parallel')" id="btnParallel" title="Rovnobƒõ≈æka" style="margin: 0;">
                        <span style="font-size: 20px;">‚à•</span>
                        <div style="font-size: 10px; margin-top: 2px;">Rovnobƒõ≈æka</div>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- √öpravy n√°stroje -->
        <div class="tool-submenu" id="toolsEdit" style="display: none;">
            <div style="background: rgba(26, 26, 26, 0.95); padding: 12px; border-radius: 8px; border: 1px solid #444; max-width: 500px; box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
                <div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: center;">
                    <!-- Editace -->
                    <button class="tool-btn" onclick="setMode('trim')" id="btnTrim" title="O≈ôezat ƒç√°ru" style="margin: 0;">
                        <span style="font-size: 20px;">‚úÇÔ∏è</span>
                        <div style="font-size: 10px; margin-top: 2px;">O≈ô√≠znut√≠</div>
                    </button>
                    <button class="tool-btn" onclick="setMode('extend')" id="btnExtend" title="Prot√°hnout ƒç√°ru do pr≈Øseƒç√≠ku" style="margin: 0;">
                        <span style="font-size: 20px;">‚ÜîÔ∏è</span>
                        <div style="font-size: 10px; margin-top: 2px;">Prota≈æen√≠</div>
                    </button>
                    <button class="tool-btn" onclick="setMode('offset')" id="btnOffset" title="Odsadit objekt" style="margin: 0;">
                        <span style="font-size: 20px;">‚áÑ</span>
                        <div style="font-size: 10px; margin-top: 2px;">Odsazen√≠</div>
                    </button>
                    <button class="tool-btn" onclick="setMode('mirror')" id="btnMirror" title="Zrcadlit objekt" style="margin: 0;">
                        <span style="font-size: 20px;">ü™û</span>
                        <div style="font-size: 10px; margin-top: 2px;">Zrcadlit</div>
                    </button>
                    <button class="tool-btn" onclick="setMode('erase')" id="btnErase" title="Smazat objekt" style="margin: 0;">
                        <span style="font-size: 20px;">üóëÔ∏è</span>
                        <div style="font-size: 10px; margin-top: 2px;">Guma</div>
                    </button>
                    <button class="tool-btn" onclick="calculateIntersections()" id="btnIntersect" title="Spoƒç√≠tat v≈°echny pr≈Øseƒç√≠ky" style="margin: 0;">
                        <span style="font-size: 20px;">‚äó</span>
                        <div style="font-size: 10px; margin-top: 2px;">Pr≈Øseƒç√≠ky</div>
                    </button>
                    <button class="tool-btn" onclick="setMode('measure')" id="btnMeasure" title="Zmƒõ≈ôit rozmƒõry objektu" style="margin: 0;">
                        <span style="font-size: 20px;">üìè</span>
                        <div style="font-size: 10px; margin-top: 2px;">Mƒõ≈ôen√≠</div>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Sou≈ôadnice panel -->
        <div class="tool-submenu coords-panel" id="toolsCoords" style="display: none;">
            <div style="background: rgba(26, 26, 26, 0.95); padding: 12px; border-radius: 8px; border: 1px solid #444; width: 100%; max-width: 400px; box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
                
                <!-- Bod -->
                <div style="margin-bottom: 8px;">
                    <div onclick="toggleCoordSection('coordBod')" style="cursor: pointer; padding: 10px; background: #2a2a2a; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                        <strong style="color: #6ab0ff; font-size: 13px;">üìç Bod</strong>
                        <span id="coordBodToggle" style="color: #888;">‚ñº</span>
                    </div>
                    <div id="coordBod" style="display: none; padding: 10px; background: #1a1a1a; border-radius: 6px; margin-top: 4px;">
                        <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                            <input type="number" id="quickPointZ" placeholder="Z" step="0.01" style="flex: 1; padding: 8px; background: #0a0a0a; border: 1px solid #444; color: white; border-radius: 4px; font-size: 14px;">
                            <input type="number" id="quickPointX" placeholder="X" step="0.01" style="flex: 1; padding: 8px; background: #0a0a0a; border: 1px solid #444; color: white; border-radius: 4px; font-size: 14px;">
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button onclick="setPointFromCursor()" style="padding: 10px; background: #4a4a4a; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; flex: 1;">üìç Z kurzoru</button>
                            <button onclick="quickAddPoint()" style="padding: 10px; background: #3a7bc8; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; flex: 1;">+ P≈ôidat</button>
                        </div>
                    </div>
                </div>
                
                <!-- ƒå√°ra -->
                <div style="margin-bottom: 8px;">
                    <div onclick="toggleCoordSection('coordLine')" style="cursor: pointer; padding: 10px; background: #2a2a2a; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                        <strong style="color: #6ab0ff; font-size: 13px;">üìè ƒå√°ra</strong>
                        <span id="coordLineToggle" style="color: #888;">‚ñº</span>
                    </div>
                    <div id="coordLine" style="display: none; padding: 10px; background: #1a1a1a; border-radius: 6px; margin-top: 4px;">
                        <div style="font-size: 12px; color: #888; margin-bottom: 4px;">Bod 1:</div>
                        <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                            <input type="number" id="lineZ1" placeholder="Z1" step="0.01" style="flex: 1; padding: 8px; background: #0a0a0a; border: 1px solid #444; color: white; border-radius: 4px;">
                            <input type="number" id="lineX1" placeholder="X1" step="0.01" style="flex: 1; padding: 8px; background: #0a0a0a; border: 1px solid #444; color: white; border-radius: 4px;">
                            <button onclick="setLineStart()" style="padding: 8px 12px; background: #4a4a4a; color: white; border: none; border-radius: 4px; cursor: pointer;">üìç</button>
                        </div>
                        <div style="font-size: 12px; color: #888; margin-bottom: 4px;">Bod 2:</div>
                        <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                            <input type="number" id="lineZ2" placeholder="Z2" step="0.01" style="flex: 1; padding: 8px; background: #0a0a0a; border: 1px solid #444; color: white; border-radius: 4px;">
                            <input type="number" id="lineX2" placeholder="X2" step="0.01" style="flex: 1; padding: 8px; background: #0a0a0a; border: 1px solid #444; color: white; border-radius: 4px;">
                            <button onclick="setLineEnd()" style="padding: 8px 12px; background: #4a4a4a; color: white; border: none; border-radius: 4px; cursor: pointer;">üìç</button>
                        </div>
                        <button onclick="addLineByCoords()" style="padding: 10px; background: #3a7bc8; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; width: 100%;">+ Nakreslit</button>
                    </div>
                </div>
                
                <!-- Kru≈ænice -->
                <div style="margin-bottom: 8px;">
                    <div onclick="toggleCoordSection('coordCircle')" style="cursor: pointer; padding: 10px; background: #2a2a2a; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                        <strong style="color: #6ab0ff; font-size: 13px;">‚≠ï Kru≈ænice</strong>
                        <span id="coordCircleToggle" style="color: #888;">‚ñº</span>
                    </div>
                    <div id="coordCircle" style="display: none; padding: 10px; background: #1a1a1a; border-radius: 6px; margin-top: 4px;">
                        <div style="font-size: 12px; color: #888; margin-bottom: 4px;">St≈ôed:</div>
                        <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                            <input type="number" id="quickCircleZ" placeholder="Z" step="0.01" style="flex: 1; padding: 8px; background: #0a0a0a; border: 1px solid #444; color: white; border-radius: 4px;">
                            <input type="number" id="quickCircleX" placeholder="X" step="0.01" style="flex: 1; padding: 8px; background: #0a0a0a; border: 1px solid #444; color: white; border-radius: 4px;">
                            <button onclick="setCircleCenter()" style="padding: 8px 12px; background: #4a4a4a; color: white; border: none; border-radius: 4px; cursor: pointer;">üìç</button>
                        </div>
                        <div style="font-size: 12px; color: #888; margin-bottom: 4px;">Polomƒõr:</div>
                        <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                            <input type="number" id="quickCircleR" placeholder="R" step="0.01" style="width: 100%; padding: 8px; background: #0a0a0a; border: 1px solid #444; color: white; border-radius: 4px;">
                        </div>
                        <button onclick="quickAddCircle()" style="padding: 10px; background: #3a7bc8; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; width: 100%;">+ Nakreslit</button>
                    </div>
                </div>
                
                <!-- Pol√°rn√≠ sou≈ôadnice -->
                <div style="margin-bottom: 8px;">
                    <div onclick="toggleCoordSection('coordPolar')" style="cursor: pointer; padding: 10px; background: #2a2a2a; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                        <strong style="color: #6ab0ff; font-size: 13px;">üìê Pol√°rn√≠</strong>
                        <span id="coordPolarToggle" style="color: #888;">‚ñº</span>
                    </div>
                    <div id="coordPolar" style="display: none; padding: 10px; background: #1a1a1a; border-radius: 6px; margin-top: 4px;">
                        <div style="font-size: 12px; color: #888; margin-bottom: 4px;">Poƒç√°teƒçn√≠ bod:</div>
                        <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                            <input type="number" id="polarStartZ" placeholder="Z" step="0.01" style="flex: 1; padding: 8px; background: #0a0a0a; border: 1px solid #444; color: white; border-radius: 4px;">
                            <input type="number" id="polarStartX" placeholder="X" step="0.01" style="flex: 1; padding: 8px; background: #0a0a0a; border: 1px solid #444; color: white; border-radius: 4px;">
                        </div>
                        <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                            <div style="flex: 1;">
                                <div style="font-size: 12px; color: #888; margin-bottom: 2px;">Vzd√°lenost:</div>
                                <input type="number" id="polarDist" placeholder="mm" step="0.1" style="width: 100%; padding: 8px; background: #0a0a0a; border: 1px solid #444; color: white; border-radius: 4px;">
                            </div>
                            <div style="flex: 1;">
                                <div style="font-size: 12px; color: #888; margin-bottom: 2px;">√öhel:</div>
                                <input type="number" id="polarAngle" placeholder="¬∞" step="1" style="width: 100%; padding: 8px; background: #0a0a0a; border: 1px solid #444; color: white; border-radius: 4px;">
                            </div>
                        </div>
                        <div style="font-size: 11px; color: #666; margin-bottom: 8px;">0¬∞ = vpravo, 90¬∞ = nahoru</div>
                        <div style="display: flex; gap: 8px;">
                            <button onclick="addLinePolar()" style="padding: 10px; background: #3a7bc8; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; flex: 1;">+ ƒå√°ra</button>
                            <button onclick="addPointPolar()" style="padding: 10px; background: #3a7bc8; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; flex: 1;">+ Bod</button>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>
        
        <!-- Ostatn√≠ n√°stroje -->
        <div class="tool-submenu" id="toolsOther" style="display: none;">
            <div style="background: rgba(26, 26, 26, 0.95); padding: 12px; border-radius: 8px; border: 1px solid #444; max-width: 500px; box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
                
                <!-- Akce -->
                <div style="margin-bottom: 8px;">
                    <div style="padding: 8px 10px; background: #2a2a2a; border-radius: 6px;">
                        <strong style="color: #6ab0ff; font-size: 13px;">‚ö° Akce</strong>
                    </div>
                    <div style="display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap;">
                        <button class="tool-btn" onclick="undo()" title="Vr√°tit zpƒõt posledn√≠ akci" style="margin: 0; flex: 1; min-width: 80px;">
                            <span style="font-size: 24px;">‚Ü∂</span>
                            <div style="font-size: 11px; margin-top: 2px;">Zpƒõt</div>
                        </button>
                        <button class="tool-btn" onclick="clearAll()" title="Vymazat v≈°e" style="margin: 0; flex: 1; min-width: 80px;">
                            <span style="font-size: 24px;">üóëÔ∏è</span>
                            <div style="font-size: 11px; margin-top: 2px;">Vymazat</div>
                        </button>
                        <button class="tool-btn" onclick="exportPNG()" title="Exportovat jako PNG" style="margin: 0; flex: 1; min-width: 80px;">
                            <span style="font-size: 24px;">üíæ</span>
                            <div style="font-size: 11px; margin-top: 2px;">Export PNG</div>
                        </button>
                    </div>
                    <div style="display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap;">
                        <button class="tool-btn" onclick="saveProject()" title="Ulo≈æit projekt jako soubor" style="margin: 0; flex: 1; min-width: 120px;">
                            <span style="font-size: 24px;">üíæ</span>
                            <div style="font-size: 11px; margin-top: 2px;">Ulo≈æit projekt</div>
                        </button>
                        <button class="tool-btn" onclick="document.getElementById('loadProjectInput').click()" title="Naƒç√≠st projekt ze souboru" style="margin: 0; flex: 1; min-width: 120px;">
                            <span style="font-size: 24px;">üìÇ</span>
                            <div style="font-size: 11px; margin-top: 2px;">Naƒç√≠st projekt</div>
                        </button>
                        <input type="file" id="loadProjectInput" accept=".json" style="display: none;" onchange="loadProject(this)">
                    </div>
                </div>
                
                <!-- Kreslic√≠ pom≈Øcky -->
                <div style="margin-bottom: 8px;">
                    <div onclick="toggleCoordSection('otherHelpers')" style="cursor: pointer; padding: 10px; background: #2a2a2a; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                        <strong style="color: #6ab0ff; font-size: 13px;">üìç P≈ôichycen√≠</strong>
                        <span id="otherHelpersToggle" style="color: #888;">‚ñº</span>
                    </div>
                    <div id="otherHelpers" style="display: none; padding: 10px; background: #1a1a1a; border-radius: 6px; margin-top: 4px;">
                        <div style="margin-bottom: 10px;">
                            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; font-size: 13px;">
                                <input type="checkbox" id="snapGrid" onchange="updateSnap()" style="width: 18px; height: 18px;">
                                <span>P≈ôichycen√≠ k m≈ô√≠≈æce</span>
                            </label>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; font-size: 13px;">
                                <input type="checkbox" id="snapPoints" checked onchange="updateSnap()" style="width: 18px; height: 18px;">
                                <span>P≈ôichycen√≠ k bod≈Øm</span>
                            </label>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; font-size: 13px;">
                                <input type="checkbox" id="orthoMode" checked onchange="updateSnap()" style="width: 18px; height: 18px;">
                                <span>Ortogon√°ln√≠ p≈ôichycen√≠ (‚Üî‚Üï)</span>
                            </label>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; font-size: 13px;">
                                <input type="checkbox" id="showPoints" checked onchange="draw()" style="width: 18px; height: 18px;">
                                <span>Zobrazit body</span>
                            </label>
                        </div>
                        <div>
                            <label style="font-size: 12px; color: #888; display: block; margin-bottom: 4px;">Vzd√°lenost p≈ôichycen√≠ (px):</label>
                            <input type="number" id="snapDistance" value="15" min="5" max="50" step="5" style="width: 100%; padding: 8px; background: #0a0a0a; border: 1px solid #444; color: white; border-radius: 4px; font-size: 14px;">
                        </div>
                    </div>
                </div>
                
                <!-- Zobrazen√≠ -->
                <div style="margin-bottom: 8px;">
                    <div onclick="toggleCoordSection('otherDisplay')" style="cursor: pointer; padding: 10px; background: #2a2a2a; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                        <strong style="color: #6ab0ff; font-size: 13px;">üé® Zobrazen√≠</strong>
                        <span id="otherDisplayToggle" style="color: #888;">‚ñº</span>
                    </div>
                    <div id="otherDisplay" style="display: none; padding: 10px; background: #1a1a1a; border-radius: 6px; margin-top: 4px;">
                        <!-- M≈ô√≠≈æka -->
                        <div style="margin-bottom: 12px;">
                            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; font-size: 13px; margin-bottom: 6px;">
                                <input type="checkbox" id="showGrid" checked onchange="draw()" style="width: 18px; height: 18px;">
                                <span>M≈ô√≠≈æka</span>
                            </label>
                            <label style="font-size: 12px; color: #888; display: block; margin-bottom: 4px;">Rozestup (mm):</label>
                            <input type="number" id="gridSpacing" value="10" min="0.01" max="100" step="0.01" onchange="updateGridSpacing()" style="width: 100%; padding: 8px; background: #0a0a0a; border: 1px solid #444; color: white; border-radius: 4px; font-size: 14px; margin-bottom: 6px;">
                            <div style="display: flex; gap: 6px;">
                                <button onclick="setGridSpacing(0.1)" style="flex: 1; padding: 6px; background: #3a3a3a; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">0.1mm</button>
                                <button onclick="setGridSpacing(1)" style="flex: 1; padding: 6px; background: #3a3a3a; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">1mm</button>
                                <button onclick="setGridSpacing(5)" style="flex: 1; padding: 6px; background: #3a3a3a; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">5mm</button>
                                <button onclick="setGridSpacing(10)" style="flex: 1; padding: 6px; background: #3a3a3a; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">10mm</button>
                            </div>
                        </div>
                        
                        <!-- Osy -->
                        <div style="margin-bottom: 12px;">
                            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; font-size: 13px; margin-bottom: 6px;">
                                <input type="checkbox" id="showAxes" checked onchange="draw()" style="width: 18px; height: 18px;">
                                <span>Osy</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; font-size: 13px; margin-bottom: 6px;">
                                <input type="checkbox" id="showAxisLabels" checked onchange="draw()" style="width: 18px; height: 18px;">
                                <span>Popisky os</span>
                            </label>
                            <label style="font-size: 12px; color: #888; display: block; margin-bottom: 4px;">Orientace:</label>
                            <select id="axisMode" onchange="changeAxisMode()" style="width: 100%; padding: 8px; background: #0a0a0a; border: 1px solid #444; color: white; border-radius: 4px; font-size: 14px; margin-bottom: 6px;">
                                <option value="lathe" selected>Soustruh (Z‚Üí, X‚Üë)</option>
                                <option value="carousel">Karusel (X‚Üí, Y‚Üë)</option>
                            </select>
                            
                            <!-- Re≈æim mƒõ≈ôen√≠ X -->
                            <label style="font-size: 12px; color: #888; display: block; margin-bottom: 4px;">Mƒõ≈ôen√≠ X:</label>
                            <select id="xMeasureSelect" onchange="changeXMeasure()" style="width: 100%; padding: 8px; background: #0a0a0a; border: 1px solid #444; color: white; border-radius: 4px; font-size: 14px;">
                                <option value="diameter" selected>Pr≈Ømƒõr (‚åÄ)</option>
                                <option value="radius">Polomƒõr (R)</option>
                            </select>
                        </div>
                        
                        <!-- Ostatn√≠ -->
                        <div style="margin-bottom: 8px;">
                            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; font-size: 13px; margin-bottom: 6px;">
                                <input type="checkbox" id="showDims" checked onchange="draw()" style="width: 18px; height: 18px;">
                                <span>K√≥ty</span>
                            </label>
                            <label style="font-size: 12px; color: #888; display: block; margin-bottom: 4px;">Mƒõ≈ô√≠tko:</label>
                            <select id="scaleSelect" onchange="changeScale()" style="width: 100%; padding: 8px; background: #0a0a0a; border: 1px solid #444; color: white; border-radius: 4px; font-size: 14px;">
                                <option value="0.5">1:2</option>
                                <option value="1" selected>1:1</option>
                                <option value="2">2:1</option>
                                <option value="5">5:1</option>
                            </select>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>

        <!-- Toolbar dole -->
        <div class="toolbar">
            <button class="tool-btn" onclick="showControllerModal()" id="btnController" title="Ovladaƒç pro rychl√© kreslen√≠ √∫seƒçek">
                <span style="font-size: 24px;">üéÆ</span>
                <div style="font-size: 11px; margin-top: 4px;">Ovladaƒç</div>
            </button>
            <button class="tool-btn" onclick="showToolCategory('drawing')" id="btnCatDrawing" title="N√°stroje pro kreslen√≠ a konstrukce">
                <span style="font-size: 24px;">‚úèÔ∏è</span>
                <div style="font-size: 11px; margin-top: 4px;">Kreslen√≠</div>
            </button>
            <button class="tool-btn" onclick="showToolCategory('edit')" id="btnCatEdit" title="N√°stroje pro √∫pravu objekt≈Ø">
                <span style="font-size: 24px;">üîß</span>
                <div style="font-size: 11px; margin-top: 4px;">√öpravy</div>
            </button>
            <button class="tool-btn" onclick="showToolCategory('coords')" id="btnCatCoords" title="P≈ôesn√© zad√°n√≠ sou≈ôadnic">
                <span style="font-size: 24px;">üìê</span>
                <div style="font-size: 11px; margin-top: 4px;">Sou≈ôadnice</div>
            </button>
            <button class="tool-btn" onclick="showToolCategory('other')" id="btnCatOther" title="Ostatn√≠ n√°stroje">
                <span style="font-size: 24px;">‚öôÔ∏è</span>
                <div style="font-size: 11px; margin-top: 4px;">Ostatn√≠</div>
            </button>
            
             <!-- AI Tlaƒç√≠tko (P≈ôid√°no) -->
            <div style="width: 1px; height: 40px; background: #333; margin: 0 5px;"></div>
            
            <button class="tool-btn ai-btn" onclick="showToolCategory('ai')" id="btnCatAi" title="AI Asistent">
                <span style="font-size: 24px;">‚ú®</span>
                <div style="font-size: 11px; margin-top: 4px;">AI</div>
            </button>
        </div>

        <canvas id="canvas"></canvas>
        
        <!-- Touch cursor - k≈ô√≠≈æek pro p≈ôesn√© zamƒõ≈ôen√≠ na mobilu -->
        <div class="touch-cursor" id="touchCursor">
            <div class="touch-cursor-center"></div>
        </div>
        
        <div class="coords" id="coords">Z: 0.00 | X: 0.00 mm</div>
        <div class="snap-info" id="snapInfo"></div>
        <div class="mode-info" id="modeInfo"></div>
    </div>
    
    <!-- MOD√ÅLN√ç OKNO NASTAVEN√ç (NOV√â) -->
    <div id="settingsModal" class="modal-overlay">
        <div class="modal-window">
            <h2 style="margin-bottom: 15px; color: #6ab0ff; font-size: 18px;">‚öôÔ∏è Nastaven√≠ API Kl√≠ƒç≈Ø</h2>
            
            <p style="font-size: 13px; color: #aaa; margin-bottom: 10px;">
                Pro pou≈æit√≠ AI funkc√≠ (Gemini) je pot≈ôeba vlo≈æit API kl√≠ƒç. Kl√≠ƒçe jsou ulo≈æeny pouze ve va≈°em prohl√≠≈æeƒçi.
                <a href="https://aistudio.google.com/app/apikey" target="_blank" style="color: #6ab0ff;">Z√≠skat kl√≠ƒç zde</a>.
            </p>

            <!-- Seznam kl√≠ƒç≈Ø -->
            <div style="font-size: 12px; color: #888;">Ulo≈æen√© kl√≠ƒçe:</div>
            <div id="keyList" class="key-list">
                <!-- Zde se dynamicky vygeneruj√≠ kl√≠ƒçe -->
                <div style="padding: 10px; color: #555; font-style: italic; text-align: center;">≈Ω√°dn√© kl√≠ƒçe</div>
            </div>

            <!-- P≈ôid√°n√≠ nov√©ho kl√≠ƒçe -->
            <div style="background: #222; padding: 12px; border-radius: 6px; margin-top: 15px;">
                <div style="margin-bottom: 8px;">
                    <label style="font-size: 11px; display: block; margin-bottom: 2px;">N√°zev (nap≈ô. Pracovn√≠):</label>
                    <input type="text" id="newKeyName" placeholder="M≈Øj kl√≠ƒç" style="width: 100%; background: #111; border: 1px solid #444; color: white; padding: 6px; border-radius: 4px;">
                </div>
                <div style="margin-bottom: 8px;">
                    <label style="font-size: 11px; display: block; margin-bottom: 2px;">API Key (zaƒç√≠n√° AIza...):</label>
                    <input type="password" id="newKeyValue" placeholder="AIza..." style="width: 100%; background: #111; border: 1px solid #444; color: white; padding: 6px; border-radius: 4px;">
                </div>
                <button onclick="addApiKey()" style="width: 100%; padding: 8px; background: #3a7bc8; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">+ P≈ôidat a pou≈æ√≠t</button>
            </div>

            <div style="margin-top: 15px; text-align: right;">
                <button onclick="closeSettings()" style="padding: 8px 16px; background: #444; color: white; border: none; border-radius: 4px; cursor: pointer;">Zav≈ô√≠t</button>
            </div>
        </div>
    </div>
    
    <!-- MOD√ÅLN√ç OKNO KRU≈ΩNICE (NOV√â) -->
    <div id="circleModal" class="modal-overlay">
        <div class="modal-window">
            <h2 style="margin-bottom: 15px; color: #6ab0ff; font-size: 18px;">‚≠ï Zad√°n√≠ kru≈ænice</h2>
            
            <div class="circle-input-row">
                <label>Polomƒõr (R):</label>
                <input type="number" id="circleInputR" step="0.01" oninput="updateCircleInputs('R')" onkeydown="if(event.key==='Enter') confirmCircle()">
            </div>
            
            <div class="circle-input-row">
                <label>Pr≈Ømƒõr (D):</label>
                <input type="number" id="circleInputD" step="0.01" oninput="updateCircleInputs('D')" onkeydown="if(event.key==='Enter') confirmCircle()">
            </div>

            <div style="margin-top: 15px; display: flex; gap: 10px; justify-content: flex-end;">
                 <button onclick="closeCircleModal()" style="padding: 8px 16px; background: #444; color: white; border: none; border-radius: 4px; cursor: pointer;">Zru≈°it</button>
                 <button onclick="confirmCircle()" style="padding: 8px 16px; background: #3a7bc8; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">Vytvo≈ôit</button>
            </div>
        </div>
    </div>
    
    <!-- MOD√ÅLN√ç OKNO RYCHL√â ZAD√ÅN√ç (NOV√â) -->
    <div id="quickInputModal" class="modal-overlay">
        <div class="modal-window" style="max-width: 550px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
                <h2 style="color: #6ab0ff; font-size: 18px; margin:0;">‚å®Ô∏è Rychl√© zad√°n√≠ (CNC)</h2>
                <button onclick="window.closeQuickInput()" style="background:transparent; border:none; color:#888; font-size:20px; cursor:pointer;">&times;</button>
            </div>
            
            <!-- TEXT DISPLAY -->
            <textarea id="quickInputDisplay" class="quick-input-display" placeholder="Zde se zobrazuje zad√°n√≠..." readonly></textarea>

            <!-- KEYPAD GRID -->
            <div class="keypad-grid">
                <!-- G-Codes Row (6 tlaƒç√≠tek) -->
                <button class="keypad-btn cnc-code" onclick="window.insertToken('G90 ')">G90<span>Abs</span></button>
                <button class="keypad-btn cnc-code" onclick="window.insertToken('G91 ')">G91<span>P≈ô√≠r</span></button>
                <button class="keypad-btn cnc-code" onclick="window.insertToken('G0 ')">G0<span>Bod</span></button>
                <button class="keypad-btn cnc-code" onclick="window.insertToken('G1 ')">G1<span>P≈ô√≠mka</span></button>
                <button class="keypad-btn cnc-code" onclick="window.insertToken('G2 ')">G2<span>CW</span></button>
                <button class="keypad-btn cnc-code" onclick="window.insertToken('G3 ')">G3<span>CCW</span></button>

                <!-- Row 1: X, Z, 7, 8, 9, ; -->
                <button class="keypad-btn action" onclick="window.insertToken('X')">X<span>Osa</span></button>
                <button class="keypad-btn action" onclick="window.insertToken('Z')">Z<span>Osa</span></button>
                <button class="keypad-btn" onclick="window.insertToken('7')">7</button>
                <button class="keypad-btn" onclick="window.insertToken('8')">8</button>
                <button class="keypad-btn" onclick="window.insertToken('9')">9</button>
                <button class="keypad-btn action" onclick="window.insertToken(';')">;<span>Oddƒõlovaƒç</span></button>
                
                <!-- Row 2: R, D, 4, 5, 6, Space -->
                <button class="keypad-btn action" onclick="window.insertToken('R')">R<span>Polomƒõr</span></button>
                <button class="keypad-btn action" onclick="window.insertToken('D')">D<span>Pr≈Ømƒõr</span></button>
                <button class="keypad-btn" onclick="window.insertToken('4')">4</button>
                <button class="keypad-btn" onclick="window.insertToken('5')">5</button>
                <button class="keypad-btn" onclick="window.insertToken('6')">6</button>
                <button class="keypad-btn" onclick="window.insertToken(' ')">Mezera</button>
                
                <!-- Row 3: L, A, 1, 2, 3, ? -->
                <button class="keypad-btn action" onclick="window.insertToken('L')">L<span>D√©lka</span></button>
                <button class="keypad-btn action" onclick="window.insertToken('A')">A<span>√öhel</span></button>
                <button class="keypad-btn" onclick="window.insertToken('1')">1</button>
                <button class="keypad-btn" onclick="window.insertToken('2')">2</button>
                <button class="keypad-btn" onclick="window.insertToken('3')">3</button>
                <button class="keypad-btn help" onclick="window.showQuickInputHelp()" title="Zobrazit n√°povƒõdu">?<span>N√°povƒõda</span></button>
                
                <!-- Row 4: RP, AP, -, 0, ., ‚å´ -->
                <button class="keypad-btn action" onclick="window.insertToken('RP')">RP<span>Pol. polomƒõr</span></button>
                <button class="keypad-btn action" onclick="window.insertToken('AP')">AP<span>Pol. √∫hel</span></button>
                <button class="keypad-btn" onclick="window.insertToken('-')">-</button>
                <button class="keypad-btn" onclick="window.insertToken('0')">0</button>
                <button class="keypad-btn" onclick="window.insertToken('.')">.</button>
                <button class="keypad-btn backspace" onclick="window.backspaceToken()">‚å´</button>
                
                <!-- Row 5: Smƒõry, Sra≈æen√≠, Zaoblen√≠, V√Ωbƒõr, Vlo≈æit (6 sloupc≈Ø) -->
                <button class="keypad-btn action" onclick="window.showDirectionModal()" style="background: #2d5a8f;">üß≠<span>Smƒõry</span></button>
                <button class="keypad-btn action" onclick="window.insertToken('Sra≈æ ')">Sra≈æ<span>Sra≈æen√≠</span></button>
                <button class="keypad-btn action" onclick="window.insertToken('Zaob ')">Zaob<span>Zaoblen√≠</span></button>
                <button class="keypad-btn action" onclick="window.insertToken('V√Ωbƒõr ')">V√Ωbƒõr<span>Vybran√©</span></button>
                <button class="keypad-btn confirm" onclick="window.confirmQuickInput()" style="grid-column: span 2;">Vlo≈æit do chatu</button>
            </div>
        </div>
    </div>

    <!-- HELP MODAL - N√°povƒõda pro rychl√© zad√°n√≠ -->
    <div id="quickInputHelpModal" class="modal-overlay">
        <div class="modal-window" style="max-width: 650px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                <h2 style="color: #6ab0ff; font-size: 18px; margin:0;">‚ùì N√°povƒõda - Rychl√© zad√°n√≠ (CNC/G-k√≥d styl)</h2>
                <button onclick="window.closeQuickInputHelp()" style="background:transparent; border:none; color:#888; font-size:20px; cursor:pointer;">&times;</button>
            </div>
            
            <div style="max-height: 500px; overflow-y: auto; color: #e0e0e0; font-size: 13px; line-height: 1.6;">
                <h3 style="color: #90cdf4; margin-top: 0;">üéØ Z√°kladn√≠ pou≈æit√≠</h3>
                <p>Mezery mezi parametry <strong>nejsou povinn√©</strong>. M≈Ø≈æe≈° ps√°t jak <code>G0 X50 Z100</code> tak <code>G0X50Z100</code>.</p>
                
                <h3 style="color: #90cdf4; margin-top: 15px;">üìç G-k√≥dy (p≈ô√≠kazy)</h3>
                <ul style="margin-left: 20px;">
                    <li><strong>G0</strong> - Vytvo≈ôen√≠ bodu (rapid move)</li>
                    <li><strong>G1</strong> - P≈ô√≠mka (line√°rn√≠ pohyb)</li>
                    <li><strong>G2</strong> - Oblouk ve smƒõru hodinov√Ωch ruƒçiƒçek (CW)</li>
                    <li><strong>G3</strong> - Oblouk proti smƒõru hodinov√Ωch ruƒçiƒçek (CCW)</li>
                    <li><strong>G90</strong> - Absolutn√≠ sou≈ôadnice</li>
                    <li><strong>G91</strong> - P≈ô√≠r≈Østkov√© sou≈ôadnice</li>
                </ul>
                
                <h3 style="color: #90cdf4; margin-top: 15px;">üìê Parametry pozice</h3>
                <ul style="margin-left: 20px;">
                    <li><strong>X</strong> - Sou≈ôadnice osy X (radi√°ln√≠ pro soustruh)</li>
                    <li><strong>Z</strong> - Sou≈ôadnice osy Z (pod√©ln√° pro soustruh)</li>
                    <li><strong>R</strong> - Polomƒõr (pro oblouky nebo kru≈ænice)</li>
                    <li><strong>D</strong> - Pr≈Ømƒõr</li>
                </ul>
                
                <h3 style="color: #90cdf4; margin-top: 15px;">üîÑ Pol√°rn√≠ sou≈ôadnice</h3>
                <ul style="margin-left: 20px;">
                    <li><strong>RP</strong> - Pol√°rn√≠ polomƒõr (vzd√°lenost od bodu)</li>
                    <li><strong>AP</strong> - Pol√°rn√≠ √∫hel (√∫hel ve stupn√≠ch)</li>
                    <li><strong>L</strong> - D√©lka (alternativa k RP)</li>
                    <li><strong>A</strong> - √öhel ve stupn√≠ch (alternativa k AP)</li>
                </ul>
                
                <h3 style="color: #90cdf4; margin-top: 15px;">‚úÇÔ∏è √öpravy hran</h3>
                <ul style="margin-left: 20px;">
                    <li><strong>Sra≈æ</strong> - Sra≈æen√≠ hrany (f√°ze)</li>
                    <li><strong>Zaob</strong> - Zaoblen√≠ hrany (r√°diusov√©)</li>
                </ul>
                
                <h3 style="color: #90cdf4; margin-top: 15px;">‚ûó Oddƒõlovaƒç</h3>
                <ul style="margin-left: 20px;">
                    <li><strong>;</strong> (st≈ôedn√≠k) - Oddƒõluje v√≠ce p≈ô√≠kaz≈Ø v jednom zad√°n√≠</li>
                </ul>
                
                <h3 style="color: #90cdf4; margin-top: 15px;">üí° P≈ô√≠klady pou≈æit√≠</h3>
                <div style="background: #1a1a1a; padding: 12px; border-radius: 6px; margin-top: 8px; font-family: 'Courier New', monospace; font-size: 12px;">
                    <p><strong>Vytvo≈ô bod na pozici:</strong></p>
                    <code style="color: #90ee90;">G0 X50 Z100</code> nebo <code style="color: #90ee90;">G0X50Z100</code>
                    
                    <p style="margin-top: 10px;"><strong>Nakresli ƒç√°ru od aktu√°ln√≠ pozice:</strong></p>
                    <code style="color: #90ee90;">G1 X100 Z50</code>
                    
                    <p style="margin-top: 10px;"><strong>Pol√°rn√≠ sou≈ôadnice (√∫seƒçka o d√©lce 100mm pod √∫hlem 90¬∞):</strong></p>
                    <code style="color: #90ee90;">G1 RP100 AP90</code> nebo <code style="color: #90ee90;">G1 L100 A90</code>
                    
                    <p style="margin-top: 10px;"><strong>V√≠ce p≈ô√≠kaz≈Ø najednou:</strong></p>
                    <code style="color: #90ee90;">G0 X50 Z100; G1 RP100 AP90; G1 X0 Z0</code>
                    <p style="font-size: 11px; color: #888; margin-top: 4px;">
                        ‚Üí Vytvo≈ô√≠ bod na [50, 100], pak ƒç√°ru pol√°rnƒõ, pak ƒç√°ru zpƒõt na [0, 0]
                    </p>
                    
                    <p style="margin-top: 10px;"><strong>Kru≈ænice s polomƒõrem:</strong></p>
                    <code style="color: #90ee90;">G0 X50 Z50; kru≈ænice R20</code>
                </div>
                
                <p style="margin-top: 15px; padding: 10px; background: #2d3748; border-left: 3px solid #90cdf4; border-radius: 4px; font-size: 12px;">
                    <strong>üí° Tip:</strong> AI Gemini rozum√≠ tƒõmto zkratk√°m a automaticky je p≈ôevede na p≈ô√≠slu≈°n√© tvary na pl√°tnƒõ!
                </p>
            </div>
            
            <div style="margin-top: 15px; text-align: center;">
                <button onclick="window.closeQuickInputHelp()" style="padding: 10px 20px; background: #3a7bc8; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px;">
                    Zav≈ô√≠t
                </button>
            </div>
        </div>
    </div>

    <!-- CONTROLLER MODAL - Ovladaƒç pro rychl√© kreslen√≠ -->
    <div id="controllerModal" class="modal-overlay">
        <div class="modal-window" style="max-width: 700px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                <h2 style="color: #6ab0ff; font-size: 18px; margin:0;">üéÆ Ovladaƒç - Rychl√© kreslen√≠ √∫seƒçek</h2>
                <button onclick="closeControllerModal()" style="background:transparent; border:none; color:#888; font-size:20px; cursor:pointer;">&times;</button>
            </div>
            
            <!-- Input Display & Mode Selector -->
            <div style="margin-bottom: 12px;">
                <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 8px;">
                    <!-- G90/G91 Toggle -->
                    <button id="btnG90" onclick="setControllerMode('G90')" style="padding: 8px 12px; background: #3a7bc8; border: 1px solid #5a9be8; border-radius: 6px; color: white; cursor: pointer; font-size: 12px; font-weight: bold;">
                        G90<br><span style="font-size: 9px;">Absolutn√≠</span>
                    </button>
                    <button id="btnG91" onclick="setControllerMode('G91')" style="padding: 8px 12px; background: #2a2a2a; border: 1px solid #444; border-radius: 6px; color: #888; cursor: pointer; font-size: 12px;">
                        G91<br><span style="font-size: 9px;">P≈ô√≠r≈Østkov√©</span>
                    </button>
                    
                    <!-- Input Display -->
                    <input 
                        type="text" 
                        id="controllerInput" 
                        readonly 
                        placeholder="Zad√°n√≠..." 
                        style="flex: 1; padding: 10px; background: #000; border: 1px solid #444; border-radius: 6px; color: #0f0; font-family: 'Courier New', monospace; font-size: 16px; font-weight: bold;"
                    >
                </div>
                
                <!-- Status Info -->
                <div style="display: flex; gap: 10px; font-size: 11px; color: #888;">
                    <div>
                        <strong style="color: #6ab0ff;">Re≈æim:</strong> 
                        <span id="controllerModeDisplay">G90 (Absolutn√≠)</span>
                    </div>
                    <div>
                        <strong style="color: #6ab0ff;">Posledn√≠ bod:</strong> 
                        <span id="controllerLastPointInline">‚Äî</span>
                    </div>
                </div>
            </div>
            
            <!-- Controller Layout - JEN KL√ÅVESNICE -->
            <div style="background: #1a1a1a; padding: 12px; border-radius: 10px; border: 1px solid #444;">
                <h4 style="color: #90cdf4; margin: 0 0 8px 0; text-align: center; font-size: 12px;">‚å®Ô∏è CNC Zad√°n√≠</h4>
                
                <!-- G-Codes Row -->
                <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 3px; margin-bottom: 3px;">
                    <button class="mini-key-action" onclick="insertControllerToken('G90 ')" style="background: #1e3a5f;">G90<span style="font-size:7px;display:block;">Abs</span></button>
                    <button class="mini-key-action" onclick="insertControllerToken('G91 ')" style="background: #1e3a5f;">G91<span style="font-size:7px;display:block;">P≈ô√≠r</span></button>
                    <button class="mini-key-action" onclick="insertControllerToken('G0 ')" style="background: #1e3a5f;">G0<span style="font-size:7px;display:block;">Bod</span></button>
                    <button class="mini-key-action" onclick="insertControllerToken('G1 ')" style="background: #1e3a5f;">G1<span style="font-size:7px;display:block;">ƒå√°ra</span></button>
                    <button class="mini-key-action" onclick="insertControllerToken('G2 ')" style="background: #1e3a5f;">G2<span style="font-size:7px;display:block;">CW</span></button>
                    <button class="mini-key-action" onclick="insertControllerToken('G3 ')" style="background: #1e3a5f;">G3<span style="font-size:7px;display:block;">CCW</span></button>
                </div>
                
                <!-- Row 1: X, Z, 7, 8, 9, ; -->
                <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 3px; margin-bottom: 3px;">
                    <button class="mini-key-action" onclick="insertControllerToken('X')">X<span style="font-size:7px;display:block;">Osa</span></button>
                    <button class="mini-key-action" onclick="insertControllerToken('Z')">Z<span style="font-size:7px;display:block;">Osa</span></button>
                    <button class="mini-key" onclick="insertControllerToken('7')">7</button>
                    <button class="mini-key" onclick="insertControllerToken('8')">8</button>
                    <button class="mini-key" onclick="insertControllerToken('9')">9</button>
                    <button class="mini-key-action" onclick="insertControllerToken(';')">;<span style="font-size:7px;display:block;">Odd</span></button>
                </div>
                
                <!-- Row 2: R, D, 4, 5, 6, Space -->
                <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 3px; margin-bottom: 3px;">
                    <button class="mini-key-action" onclick="insertControllerToken('R')">R<span style="font-size:7px;display:block;">Polomƒõr</span></button>
                    <button class="mini-key-action" onclick="insertControllerToken('D')">D<span style="font-size:7px;display:block;">Pr≈Ømƒõr</span></button>
                    <button class="mini-key" onclick="insertControllerToken('4')">4</button>
                    <button class="mini-key" onclick="insertControllerToken('5')">5</button>
                    <button class="mini-key" onclick="insertControllerToken('6')">6</button>
                    <button class="mini-key-action" onclick="insertControllerToken(' ')">‚ê£<span style="font-size:7px;display:block;">Mezera</span></button>
                </div>
                
                <!-- Row 3: L, A, 1, 2, 3, Backspace -->
                <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 3px; margin-bottom: 3px;">
                    <button class="mini-key-action" onclick="insertControllerToken('L')">L<span style="font-size:7px;display:block;">D√©lka</span></button>
                    <button class="mini-key-action" onclick="insertControllerToken('A')">A<span style="font-size:7px;display:block;">√öhel</span></button>
                    <button class="mini-key" onclick="insertControllerToken('1')">1</button>
                    <button class="mini-key" onclick="insertControllerToken('2')">2</button>
                    <button class="mini-key" onclick="insertControllerToken('3')">3</button>
                    <button class="mini-key-back" onclick="backspaceControllerToken()">‚å´</button>
                </div>
                
                <!-- Row 4: RP, AP, -, 0, . -->
                <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 3px; margin-bottom: 3px;">
                    <button class="mini-key-action" onclick="insertControllerToken('RP')">RP<span style="font-size:7px;display:block;">Pol R</span></button>
                    <button class="mini-key-action" onclick="insertControllerToken('AP')">AP<span style="font-size:7px;display:block;">Pol A</span></button>
                    <button class="mini-key" onclick="insertControllerToken('-')">-</button>
                    <button class="mini-key" onclick="insertControllerToken('0')">0</button>
                    <button class="mini-key" onclick="insertControllerToken('.')">.</button>
                    <button class="mini-key-action" onclick="insertControllerToken('I')">I<span style="font-size:7px;display:block;">Oblouk</span></button>
                </div>
                
                <!-- Row 5: Smƒõry, Sra≈æen√≠, Zaoblen√≠, Potvrdit -->
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 3px;">
                    <button class="mini-key-action" onclick="window.showDirectionModal()" style="background: #2d5a8f;">üß≠<span style="font-size:7px;display:block;">Smƒõry</span></button>
                    <button class="mini-key-action" onclick="insertControllerToken('Sra≈æ ')">Sra≈æ<span style="font-size:7px;display:block;">Sra≈æen√≠</span></button>
                    <button class="mini-key-action" onclick="insertControllerToken('Zaob ')">Zaob<span style="font-size:7px;display:block;">Zaoblen√≠</span></button>
                </div>
                <div style="margin-top: 6px;">
                    <button onclick="confirmControllerInput()" style="width: 100%; padding: 10px; background: #22c55e; border: none; border-radius: 6px; color: white; cursor: pointer; font-size: 14px; font-weight: bold;">
                        ‚úì Potvrdit
                    </button>
                </div>
            </div>
            
            <!-- Help Text -->
            <div style="margin-top: 12px; padding: 10px; background: #1a1a1a; border-radius: 6px; border-left: 3px solid #6ab0ff; font-size: 11px; color: #aaa;">
                <strong style="color: #6ab0ff;">üí° Tip:</strong> 
                Pou≈æij <strong>G-k√≥dy</strong>: <code style="color: #90ee90;">G0 X50 Z100</code> (bod), 
                <code style="color: #90ee90;">G1 X100</code> (ƒç√°ra), 
                <code style="color: #90ee90;">G2 R20</code> (oblouk), nebo klikni <strong>üß≠ Smƒõry</strong> pro rychl√© kreslen√≠
            </div>
        </div>
    </div>

    <!-- DIRECTION MODAL - Skryt√© smƒõrov√© ≈°ipky -->
    <div id="directionModal" class="modal-overlay">
        <div class="modal-window" style="max-width: 350px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                <h2 style="color: #6ab0ff; font-size: 18px; margin:0;">üß≠ Smƒõrov√© kreslen√≠</h2>
                <button onclick="window.closeDirectionModal()" style="background:transparent; border:none; color:#888; font-size:20px; cursor:pointer;">&times;</button>
            </div>
            
            <p style="color: #aaa; font-size: 12px; margin-bottom: 15px;">Klikni na ≈°ipku, automaticky se vlo≈æ√≠ p≈ô√≠kaz do zad√°n√≠:</p>
            
            <!-- Direction Pad (8-way) -->
            <div style="display: grid; grid-template-columns: repeat(3, 80px); grid-template-rows: repeat(3, 80px); gap: 5px; justify-content: center;">
                <!-- Row 1: ‚Üñ ‚Üë ‚Üó -->
                <button class="controller-btn" onclick="window.insertDirectionCommand('NW')" title="≈†ikmo vlevo nahoru (‚Üñ)">
                    <span style="font-size: 32px;">‚Üñ</span>
                </button>
                <button class="controller-btn" onclick="window.insertDirectionCommand('N')" title="Nahoru (‚Üë)">
                    <span style="font-size: 32px;">‚Üë</span>
                </button>
                <button class="controller-btn" onclick="window.insertDirectionCommand('NE')" title="≈†ikmo vpravo nahoru (‚Üó)">
                    <span style="font-size: 32px;">‚Üó</span>
                </button>
                
                <!-- Row 2: ‚Üê ¬∑ ‚Üí -->
                <button class="controller-btn" onclick="window.insertDirectionCommand('W')" title="Doleva (‚Üê)">
                    <span style="font-size: 32px;">‚Üê</span>
                </button>
                <div style="display: flex; align-items: center; justify-content: center; background: #1a1a1a; border-radius: 8px; color: #666; font-size: 36px;">
                    ‚óè
                </div>
                <button class="controller-btn" onclick="window.insertDirectionCommand('E')" title="Doprava (‚Üí)">
                    <span style="font-size: 32px;">‚Üí</span>
                </button>
                
                <!-- Row 3: ‚Üô ‚Üì ‚Üò -->
                <button class="controller-btn" onclick="window.insertDirectionCommand('SW')" title="≈†ikmo vlevo dol≈Ø (‚Üô)">
                    <span style="font-size: 32px;">‚Üô</span>
                </button>
                <button class="controller-btn" onclick="window.insertDirectionCommand('S')" title="Dol≈Ø (‚Üì)">
                    <span style="font-size: 32px;">‚Üì</span>
                </button>
                <button class="controller-btn" onclick="window.insertDirectionCommand('SE')" title="≈†ikmo vpravo dol≈Ø (‚Üò)">
                    <span style="font-size: 32px;">‚Üò</span>
                </button>
            </div>
            
            <div style="margin-top: 15px; text-align: center;">
                <button onclick="window.closeDirectionModal()" style="padding: 8px 16px; background: #3a7bc8; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px;">
                    Zav≈ô√≠t
                </button>
            </div>
        </div>
    </div>

    <!-- AI LOGIC MODULE -->
    <script type="module">
        import { GoogleGenAI, Type } from "@google/genai";

        // Global variables for AI (Initialized dynamically inside callGemini)
        
        // Chat History for Context
        let chatSessionHistory = [];
        let shapesHistory = []; // To track shapes added per AI turn for Undo
        
        // Image Handling Vars
        let currentImageBase64 = null;
        let currentImageMimeType = null;
        
        // Expose functions to window for HTML event handlers
        window.handleImageSelect = (input) => {
            const file = input.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const result = e.target.result;
                    currentImageBase64 = result.split(',')[1];
                    currentImageMimeType = file.type;
                    document.getElementById('aiPreviewImg').src = result;
                    document.getElementById('aiImagePreview').style.display = 'block';
                    const fileNameEl = document.getElementById('aiFileName');
                    if (fileNameEl) fileNameEl.textContent = file.name;
                } catch (error) {
                    console.error('Chyba p≈ôi naƒç√≠t√°n√≠ obr√°zku:', error);
                    alert('‚ö†Ô∏è Nepoda≈ôilo se naƒç√≠st obr√°zek.\n\nZkuste jin√Ω soubor nebo form√°t.');
                }
            };
            
            reader.onerror = () => {
                alert('‚ö†Ô∏è Nepoda≈ôilo se p≈ôeƒç√≠st soubor.\n\nZkontrolujte opr√°vnƒõn√≠ a zkuste to znovu.');
            };
            
            reader.readAsDataURL(file);
        };

        window.clearImage = () => {
            currentImageBase64 = null;
            currentImageMimeType = null;
            document.getElementById('aiImageInput').value = '';
            document.getElementById('aiImagePreview').style.display = 'none';
            const fileNameEl = document.getElementById('aiFileName');
            if (fileNameEl) fileNameEl.textContent = '';
        };

        function addMessageToChat(role, text, shapesCount = 0) {
            const container = document.getElementById('aiChatHistory');
            const div = document.createElement('div');
            div.className = `chat-msg ${role}`;
            
            let content = text.replace(/\n/g, '<br>');
            
            // Pokud model vygeneroval tvary, p≈ôid√°me ≈°t√≠tek
            if (role === 'model' && shapesCount > 0) {
                content = `<span class="shape-tag">‚úèÔ∏è +${shapesCount} tvar≈Ø</span><br>` + content;
            }
            
            div.innerHTML = content;
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }
        
        // AI UNDO LOGIC
        window.aiUndo = function() {
            const container = document.getElementById('aiChatHistory');
            // Must have at least 2 messages (user + model) to undo a turn
            // The first child is the "Start conversation" text, so check > 3 children usually
            // But let's check chatSessionHistory length
            
            if (chatSessionHistory.length < 2) {
                alert("Nen√≠ co vr√°tit.");
                return;
            }
            
            // 1. Remove last User + Model interaction from history
            chatSessionHistory.pop(); // Remove Model
            chatSessionHistory.pop(); // Remove User
            
            // 2. Remove messages from UI (last 2 elements)
            // Be careful if there is a loading bubble or others. 
            // We assume standard flow: user msg -> model msg
            const msgs = container.querySelectorAll('.chat-msg');
            if (msgs.length >= 2) {
                container.removeChild(msgs[msgs.length-1]); // Model
                container.removeChild(msgs[msgs.length-2]); // User
            }
            
            // 3. Revert Geometry if the last turn added shapes
            // Simple approach: standard global undo if available, but ideally we track what AI added
            // For now, let's trigger the global undo ONCE if the last model message had shapes.
            // A better way: maintain specific undo history for AI.
            // Let's assume the user uses global undo for geometry primarily. 
            // But the request was "step back in what AI did".
            // Implementation: We will trigger standard undo if shapes were added in last step.
            // Simplified: Just undo once.
            window.undo();
        }
        
        window.aiRedo = function() {
            // Redo pou≈æ√≠v√° glob√°ln√≠ redo funkci pokud existuje
            // V souƒçasn√© implementaci nem√°me redo stack, ale m≈Ø≈æeme ho p≈ôidat
            // Prozat√≠m jen zavol√° standardn√≠ redo pokud bude implementov√°no
            if (window.redo && typeof window.redo === 'function') {
                window.redo();
            } else {
                alert("Funkce Dop≈ôedu nen√≠ zat√≠m implementov√°na.");
            }
        }

        window.callGemini = async () => {
            // 1. Z√≠skat aktivn√≠ API kl√≠ƒç
            const apiKey = window.getCurrentApiKey();
            
            if (!apiKey) {
                alert("Pro pou≈æit√≠ AI mus√≠te nejprve nastavit API kl√≠ƒç v nastaven√≠ (‚öôÔ∏è).");
                window.openSettings();
                return;
            }

            const promptInput = document.getElementById('aiPrompt');
            const prompt = promptInput.value.trim();
            const btn = document.getElementById('btnGenerate');
            const status = document.getElementById('aiStatus');
            const useThinking = document.getElementById('useThinking')?.checked; // NEW THINKING CHECK
            
            if (!prompt && !currentImageBase64) {
                 return; // Empty
            }
            
            // Add User Message
            const userMsg = prompt || (currentImageBase64 ? "[Obr√°zek]" : "...");
            addMessageToChat('user', userMsg);
            
            promptInput.value = ''; // Clear input
            
            // UI Loading state
            const originalBtn = btn.innerHTML;
            btn.disabled = true;
            btn.innerHTML = '<div class="loading-spinner"></div>';
            
            // Add temporary loading bubble
            const container = document.getElementById('aiChatHistory');
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'chat-msg model loading-bubble';
            loadingDiv.innerHTML = '<div class="loading-dots"><div></div><div></div><div></div></div>';
            container.appendChild(loadingDiv);
            container.scrollTop = container.scrollHeight;

            try {
                // Initialize AI with user key
                const ai = new GoogleGenAI({ apiKey: apiKey });

                // Get shapes and selected items from window scope
                const currentShapes = window.shapes || [];
                const currentSelections = window.selectedItems || [];
                const axisMode = window.axisMode || 'lathe';

                const axisLabel = axisMode === 'lathe' 
                    ? 'Z axis is Horizontal (Length/Longitudinal), X axis is Vertical (Diameter/Radius).' 
                    : 'X axis is Horizontal, Y axis is Vertical.';
                
                // System Instruction (Dynamic context)
                // --- UPDATE: PASS SHAPE GEOMETRY AND SELECTED ITEMS WITH LABELS ---
                // Omezit context jen na posledn√≠ch 20 shapes + selected items
                const recentShapes = currentShapes.slice(-20);
                
                // Spoƒç√≠tat pr≈Øseƒç√≠ky pro kontext
                const contextIntersections = [];
                for (let i = Math.max(0, currentShapes.length - 20); i < currentShapes.length; i++) {
                    for (let j = i + 1; j < currentShapes.length; j++) {
                        const s1 = currentShapes[i];
                        const s2 = currentShapes[j];
                        let pts = [];
                        
                        if (s1.type === 'line' && s2.type === 'circle') {
                            pts = intersectLineCircle(s1, s2);
                        } else if (s1.type === 'circle' && s2.type === 'line') {
                            pts = intersectLineCircle(s2, s1);
                        } else if (s1.type === 'circle' && s2.type === 'circle') {
                            pts = intersectCircleCircle(s1, s2);
                        } else if (s1.type === 'line' && s2.type === 'line') {
                            const pt = lineIntersection(s1, s2);
                            if (pt) pts = [pt];
                        }
                        
                        pts.forEach(pt => {
                            contextIntersections.push({
                                shape1_idx: i,
                                shape2_idx: j,
                                x: parseFloat(pt.x.toFixed(2)),
                                y: parseFloat(pt.y.toFixed(2))
                            });
                        });
                    }
                }
                
                const shapesContext = recentShapes.length > 0
                    ? `Shapes on canvas (last ${recentShapes.length}): ${JSON.stringify(recentShapes)}
                    
Intersections found: ${contextIntersections.length > 0 ? JSON.stringify(contextIntersections) : 'None'}

NOTE: When user asks about intersections, use the data above. Intersection x,y are in JSON coords (x=Z, y=X).`
                    : 'No shapes yet.';
                    
                // Format selections with labels
                const selectionContext = currentSelections.length > 0
                    ? `SELECTED: ${JSON.stringify(currentSelections.map(s => ({label: s.label, type: s.type, x: s.x || s.ref.x1, y: s.y || s.ref.y1})))}`
                    : ``;

                // OPTIMIZED AI SYSTEM PROMPT - Enhanced with CNC/G-code support
                const systemPrompt = `CAD Assistant for CNC Lathe/Mill operations (Czech language).

COORDINATE SYSTEM:
Z-axis (horizontal/‚Üí) = JSON 'x' property
X-axis (vertical/‚Üë) = JSON 'y' property
Origin: (0,0) center
Report coords as: "Z=[x] X=[y]"

ANGLES (Standard Unit Circle):
0¬∞=RIGHT(+Z), 90¬∞=UP(+X), 180¬∞=LEFT(-Z), 270¬∞=DOWN(-X)

INPUT FORMATS:
1. Natural language: "kru≈ænice Z100 X50 R30"
2. CNC/G-code style: "X80Z56R52" or "X50Z56AP0RP120"

CNC SYNTAX PARSING:
- XvalZval = position (X=diameter/radius, Z=length)
- Rval = radius for circle
- APval = angle in polar (0¬∞=right, 90¬∞=up, 180¬∞=left, 270¬∞=down)
- RPval = polar radius/length (distance from start point)

Examples:
"X80Z56R52" ‚Üí Circle at (Z=56,X=80) with radius 52
"X50Z56AP0RP120" ‚Üí Line from (Z=56,X=50) at angle 0¬∞ length 120mm
  ‚Üí End point: Z=56+120*cos(0¬∞)=176, X=50+120*sin(0¬∞)=50
  ‚Üí {"type":"line","x1":56,"y1":50,"x2":176,"y2":50}

"X80Z56R52;X50Z56AP0RP120" ‚Üí Circle + Line:
  - Circle: center (56,80), R=52
  - Line: from (56,50) angle 0¬∞ length 120 ‚Üí to (176,50)

AVAILABLE TOOLS & OPERATIONS:
‚úèÔ∏è DRAWING: line, circle, point
üîß CONSTRUCTION: tangent, perpendicular, parallel
‚úÇÔ∏è EDITING: trim, extend, offset, mirror, erase
üìê ANALYSIS: measure, intersections, distance

RESPONSE FORMAT (strict JSON only):
{"response_text":"Brief Czech confirmation <50 chars","shapes":[...]}

SHAPE TYPES:
Line: {"type":"line","x1":z1,"y1":x1,"x2":z2,"y2":x2}
Circle: {"type":"circle","cx":z,"cy":x,"r":radius}
Point: {"type":"point","x":z,"y":x}

POLAR CALCULATION (Œ± in degrees):
x_end = cx + length*cos(Œ±*œÄ/180)
y_end = cy + length*sin(Œ±*œÄ/180)

CRITICAL RULES:
1. DRAW commands ‚Üí add shapes[] (never empty)
2. CALCULATE/MEASURE commands ‚Üí empty shapes[], answer in response_text
3. Parse CNC syntax: AP=angle, RP=polar_length
4. For polar coords: calculate endpoint using angle and length
5. NEVER hallucinate coords - use provided data or ask
6. Support Czech terms: √∫seƒçka=line, kru≈ænice=circle, st≈ôed=center

EXAMPLES:
Natural: {"response_text":"Kru≈ænice R50","shapes":[{"type":"circle","cx":100,"cy":100,"r":50}]}
CNC: {"response_text":"Kru≈ænice + √∫seƒçka 0¬∞ 120mm","shapes":[{"type":"circle","cx":56,"cy":80,"r":52},{"type":"line","x1":56,"y1":50,"x2":176,"y2":50}]}

${axisLabel}
${shapesContext}
${selectionContext}`;


                // OPTIMIZED: Smart history management - compress old messages
                function compressHistory(history, maxMessages = 12) {
                    if (history.length <= maxMessages) return history;
                    
                    // Keep last 6 messages (3 exchanges) in full detail
                    const recentMessages = history.slice(-6);
                    const oldMessages = history.slice(0, -6);
                    
                    // Count shapes created in old messages for context
                    let shapeCount = 0;
                    oldMessages.forEach(msg => {
                        if (msg.role === 'model' && msg.parts[0]?.text) {
                            try {
                                const json = JSON.parse(msg.parts[0].text);
                                if (json.shapes) shapeCount += json.shapes.length;
                            } catch(e) {}
                        }
                    });
                    
                    // Create compressed summary
                    const summary = {
                        role: 'user',
                        parts: [{
                            text: `[Previous: ${oldMessages.length/2} exchanges, ${shapeCount} shapes created]`
                        }]
                    };
                    
                    return [summary, ...recentMessages];
                }
                
                let contents = compressHistory(chatSessionHistory, 12);
                
                // Add new message to history
                const newParts = [];
                if (prompt) newParts.push({ text: `User Command: ${prompt}` });
                if (currentImageBase64) {
                     newParts.push({ inlineData: { mimeType: currentImageMimeType, data: currentImageBase64 } });
                }
                
                // Get selected model
                const modelSelect = document.getElementById('aiModelSelect');
                let selectedModel = modelSelect ? modelSelect.value : "gemini-2.5-flash";

                // CONFIG SETUP
                const config = {
                    systemInstruction: systemPrompt,
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: Type.OBJECT,
                        properties: {
                            response_text: { type: Type.STRING },
                            shapes: {
                                type: Type.ARRAY,
                                items: {
                                    type: Type.OBJECT,
                                    properties: {
                                        type: { type: Type.STRING, enum: ["line", "circle"] },
                                        x1: { type: Type.NUMBER },
                                        y1: { type: Type.NUMBER },
                                        x2: { type: Type.NUMBER },
                                        y2: { type: Type.NUMBER },
                                        cx: { type: Type.NUMBER },
                                        cy: { type: Type.NUMBER },
                                        r: { type: Type.NUMBER }
                                    },
                                    required: ["type"]
                                }
                            }
                        }
                    }
                };

                // THINKING MODE OVERRIDE
                if (useThinking) {
                    selectedModel = "gemini-3-pro-preview";
                    config.thinkingConfig = { thinkingBudget: 32768 };
                    // FIX: Remove JSON enforcement for Thinking models to avoid 500 errors
                    delete config.responseMimeType;
                    delete config.responseSchema;
                }

                // OPTIMIZED: Use retry logic with exponential backoff
                const response = await retryWithBackoff(async () => {
                    return await ai.models.generateContent({
                        model: selectedModel,
                        contents: [...contents, { role: 'user', parts: newParts }],
                        config: config
                    });
                }, 3);
                
                // Remove loading bubble
                container.removeChild(loadingDiv);
                
                if (response.text) {
                    let result;
                    
                    // Aggressive JSON cleaning
                    let cleanedText = response.text;
                    
                    // Remove markdown code blocks
                    cleanedText = cleanedText.replace(/```json\s*/gi, '').replace(/```\s*/g, '');
                    
                    // Remove any text before first { and after last }
                    const firstBrace = cleanedText.indexOf('{');
                    const lastBrace = cleanedText.lastIndexOf('}');
                    if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
                        cleanedText = cleanedText.substring(firstBrace, lastBrace + 1);
                    }
                    
                    // Trim whitespace
                    cleanedText = cleanedText.trim();
                    
                    // Log for debugging
                    console.log('AI Response (first 200 chars):', response.text.substring(0, 200));
                    console.log('Cleaned JSON:', cleanedText.substring(0, 200));
                    
                    // Fix incomplete JSON (missing closing brackets)
                    let fixedJson = cleanedText;
                    
                    // Count opening and closing brackets
                    const openBraces = (fixedJson.match(/\{/g) || []).length;
                    const closeBraces = (fixedJson.match(/\}/g) || []).length;
                    const openBrackets = (fixedJson.match(/\[/g) || []).length;
                    const closeBrackets = (fixedJson.match(/\]/g) || []).length;
                    
                    // Add missing closing brackets
                    if (openBrackets > closeBrackets) {
                        fixedJson += ']'.repeat(openBrackets - closeBrackets);
                    }
                    if (openBraces > closeBraces) {
                        fixedJson += '}'.repeat(openBraces - closeBraces);
                    }
                    
                    // Remove incomplete number at the end (like "100.0000000000000185676...")
                    fixedJson = fixedJson.replace(/(\d+\.\d{10,})\d*$/, '$1');
                    fixedJson = fixedJson.replace(/,\s*([}\]])/, '$1'); // Remove trailing commas
                    
                    console.log('Fixed JSON:', fixedJson.substring(0, 200));
                    
                    try {
                        // Try to parse the fixed JSON response
                        result = JSON.parse(fixedJson);
                    } catch (parseError) {
                        console.error('JSON Parse Error:', parseError);
                        console.error('Full fixed response:', fixedJson);
                        
                        // Last resort: try to extract valid JSON with regex
                        const jsonMatch = fixedJson.match(/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/);
                        if (jsonMatch) {
                            try {
                                result = JSON.parse(jsonMatch[0]);
                                console.log('‚úÖ Recovered JSON from response');
                            } catch (e) {
                                console.error('‚ùå Recovery failed:', e);
                                addMessageToChat('model', `‚ùå AI nevr√°tila validn√≠ JSON.\n\nüîç Debug:\n${fixedJson.substring(0, 100)}...\n\nüí° Zkuste:\n‚Ä¢ Gemini 2.5 Flash m√° limit 20/den - p≈ôidejte dal≈°√≠ kl√≠ƒç\n‚Ä¢ Zjednodu≈°it dotaz\n‚Ä¢ Obnovit str√°nku`);
                                return;
                            }
                        } else {
                            addMessageToChat('model', `‚ùå AI nevr√°tila JSON form√°t.\n\nüí° Zkuste Gemini 1.5 Flash - ten m√° nejlep≈°√≠ JSON podporu.`);
                            return;
                        }
                    }
                    
                    const replyText = result.response_text || "Hotovo.";
                    const newShapes = result.shapes || [];
                    
                    // Debug: Show what AI returned
                    console.log('üìä AI Response:', {
                        response_text: replyText,
                        shapes_count: newShapes.length,
                        shapes: newShapes
                    });
                    
                    // If AI returned empty shapes, show debug info
                    if (newShapes.length === 0) {
                        console.warn('‚ö†Ô∏è AI vr√°tila pr√°zdn√© shapes array!');
                        console.log('Full JSON:', result);
                    }
                    
                    // OPTIMIZED: Add shapes to canvas with validation
                    if (Array.isArray(newShapes) && newShapes.length > 0) {
                        let addedCount = 0;
                        newShapes.forEach(s => {
                            try {
                                if (s.type === 'line' && 
                                    typeof s.x1 === 'number' && typeof s.y1 === 'number' &&
                                    typeof s.x2 === 'number' && typeof s.y2 === 'number') {
                                    window.shapes.push({
                                        type: 'line',
                                        x1: s.x1, y1: s.y1,
                                        x2: s.x2, y2: s.y2
                                    });
                                    addedCount++;
                                } else if (s.type === 'circle' && 
                                          typeof s.cx === 'number' && typeof s.cy === 'number' &&
                                          typeof s.r === 'number' && s.r > 0) {
                                    window.shapes.push({
                                        type: 'circle',
                                        cx: s.cx, cy: s.cy,
                                        r: s.r
                                    });
                                    addedCount++;
                                } else if (s.type === 'point' &&
                                          typeof s.x === 'number' && typeof s.y === 'number') {
                                    // Add construction point
                                    window.points.push({
                                        x: s.x,
                                        y: s.y
                                    });
                                    addedCount++;
                                } else {
                                    console.warn('‚ö†Ô∏è Invalid shape skipped:', s);
                                }
                            } catch (e) {
                                console.error('Error adding shape:', e, s);
                            }
                        });
                        
                        console.log(`‚úÖ Added ${addedCount}/${newShapes.length} shapes`);
                        
                        if (window.updateSnapPoints) window.updateSnapPoints();
                        if (window.draw) window.draw();
                    }
                    
                    // 2. Add message to chat UI
                    addMessageToChat('model', replyText, newShapes.length);
                    
                    // 3. Update History
                    chatSessionHistory.push({ role: 'user', parts: newParts });
                    chatSessionHistory.push({ role: 'model', parts: [{ text: response.text }] }); 
                    
                    window.clearImage(); 
                }

            } catch (err) {
                console.error(err);
                if (container.contains(loadingDiv)) container.removeChild(loadingDiv);
                
                // Odstranit posledn√≠ user zpr√°vu z UI (ta co zp≈Øsobila chybu)
                const msgs = container.querySelectorAll('.chat-msg.user');
                if (msgs.length > 0) {
                    const lastUserMsg = msgs[msgs.length - 1];
                    container.removeChild(lastUserMsg);
                }
                
                // Vr√°tit prompt zpƒõt do inputu pro opakov√°n√≠
                promptInput.value = prompt;
                
                // Zobrazit chybovou zpr√°vu
                const errorText = err.message || String(err);
                let userFriendlyError = '';
                
                if (errorText.includes('429') || errorText.includes('quota') || errorText.includes('RESOURCE_EXHAUSTED')) {
                    // Pokusit se p≈ôepnout na dal≈°√≠ API kl√≠ƒç
                    const switched = window.switchToNextApiKey();
                    
                    if (switched) {
                        userFriendlyError = '‚ö†Ô∏è P≈ôekroƒçen limit API vol√°n√≠.\n\nüîÑ Automaticky p≈ôepnuto na dal≈°√≠ API kl√≠ƒç.\n\nüí° Kliknƒõte Enter pro odesl√°n√≠ s nov√Ωm kl√≠ƒçem.';
                    } else {
                        userFriendlyError = '‚ö†Ô∏è P≈ôekroƒçen limit API vol√°n√≠.\n\n‚ùå Nem√°te dal≈°√≠ API kl√≠ƒçe.\n\nüí° Zkuste:\n‚Ä¢ P≈ôidat dal≈°√≠ API kl√≠ƒç v nastaven√≠ (‚öôÔ∏è)\n‚Ä¢ Poƒçkat p√°r minut\n‚Ä¢ P≈ôepnout na jin√Ω model\n‚Ä¢ Zkontrolovat limity: https://ai.dev/usage';
                    }
                } else if (errorText.includes('404') || errorText.includes('not found')) {
                    userFriendlyError = '‚ö†Ô∏è Model nenalezen.\n\nüí° Zkuste:\n‚Ä¢ P≈ôepnout na Gemini 2.5 Flash\n‚Ä¢ Ovƒõ≈ôit platnost API kl√≠ƒçe v nastaven√≠';
                } else if (errorText.includes('403') || errorText.includes('PERMISSION_DENIED')) {
                    userFriendlyError = '‚ö†Ô∏è API kl√≠ƒç byl zam√≠tnut.\n\nüí° Zkuste:\n‚Ä¢ Vytvo≈ôit nov√Ω API kl√≠ƒç v Google AI Studio\n‚Ä¢ Ovƒõ≈ôit ≈æe kl√≠ƒç nen√≠ expired';
                } else {
                    userFriendlyError = `‚ùå Chyba: ${errorText}`;
                }
                
                addMessageToChat('model', userFriendlyError + '\n\n‚úèÔ∏è V√°≈° dotaz byl vr√°cen do pole - m≈Ø≈æete ho upravit a poslat znovu.');
                
            } finally {
                btn.disabled = false;
                btn.innerHTML = originalBtn;
                document.getElementById('aiPrompt').focus();
            }
        };
    </script>

    <!-- ORIGINAL LOGIC + KEY MANAGER -->
    <script>
        // === GLOBAL VARIABLES (Moved to top to prevent ReferenceError) ===
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let shapes = [];
        let points = []; // Konstrukƒçn√≠ body (manu√°ln√≠)
        let cachedSnapPoints = []; // Cache pro v≈°echny zaj√≠mav√© body (konce, pr≈Øseƒç√≠ky)
        let selectedItems = []; // Seznam vybran√Ωch objekt≈Ø pro AI (shapes nebo points)
        let currentCategory = null; // Fix for ReferenceError
        
        let mode = 'pan';
        let drawing = false;
        let startPt = null;
        let tempShape = null;
        let selectedShape = null;
        
        let panX = 0;
        let panY = 0;
        let zoom = 2;
        let gridSize = 10;
        let axisMode = 'lathe'; // 'lathe' nebo 'carousel'
        let xMeasureMode = 'diameter'; // 'diameter' or 'radius'
        
        let snapToGrid = false;
        let snapToPoints = true;
        let snapDistance = 15;
        let orthoMode = true; // Ortogon√°ln√≠ p≈ôichycen√≠ (vodorovn√©/svisl√©)
        
        let lastTouch = null;
        let lastDist = 0;
        let cursorPos = {x: 0, y: 0}; // Aktu√°ln√≠ poloha kurzoru
        let pendingCircleCenter = null;
        let offsetDistance = 5; // V√Ωchoz√≠ vzd√°lenost offsetu v mm
        
        // Touch cursor promƒõnn√©
        let touchCursorTimeout = null;
        let touchCursorActive = false;
        let touchCursorOffset = 60; // Offset nad prstem v pixelech
        const touchCursorDelay = 300; // Prodleva p≈ôed zobrazen√≠m (ms)
        
        // AI Performance metrics
        let aiMetrics = {
            totalRequests: 0,
            successfulRequests: 0,
            failedRequests: 0,
            totalTokens: 0,
            avgLatency: 0
        };
        
        // Retry helper with exponential backoff
        async function retryWithBackoff(apiCall, maxRetries = 3) {
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    const startTime = Date.now();
                    const result = await apiCall();
                    const latency = Date.now() - startTime;
                    
                    // Update metrics
                    aiMetrics.totalRequests++;
                    aiMetrics.successfulRequests++;
                    aiMetrics.avgLatency = (aiMetrics.avgLatency * (aiMetrics.successfulRequests - 1) + latency) / aiMetrics.successfulRequests;
                    
                    return result;
                } catch (err) {
                    const isRateLimit = err.message?.includes('429') || 
                                       err.message?.includes('quota') || 
                                       err.message?.includes('RESOURCE_EXHAUSTED');
                    
                    if (isRateLimit && attempt < maxRetries - 1) {
                        const delay = Math.pow(2, attempt) * 1000; // 1s, 2s, 4s
                        console.log(`‚è≥ Rate limit hit, retrying in ${delay/1000}s...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }
                    
                    // Update failed metrics
                    aiMetrics.totalRequests++;
                    aiMetrics.failedRequests++;
                    throw err;
                }
            }
        }
    
        // === API KEY MANAGER START ===
        const API_STORAGE_KEY = 'soustruznik_api_keys';
        
        // Use environment variable as default
        const DEFAULT_API_KEY = "AIza..."; // Placeholder if not provided
        
        function getStoredKeys() {
            try {
                return JSON.parse(localStorage.getItem(API_STORAGE_KEY) || '[]');
            } catch (e) { return []; }
        }

        function saveStoredKeys(keys) {
            localStorage.setItem(API_STORAGE_KEY, JSON.stringify(keys));
            renderKeyList();
            updateKeyIndicator();
        }

        // Exposed for Module Script
        window.getCurrentApiKey = function() {
            const keys = getStoredKeys();
            const active = keys.find(k => k.active);
            
            // Pokud m√°me aktivn√≠ kl√≠ƒç v √∫lo≈æi≈°ti, pou≈æijeme ho
            if (active) return active.key;
            
            // Pokud nem√°me ≈æ√°dn√© kl√≠ƒçe, pou≈æijeme defaultn√≠ (demo) kl√≠ƒç
            if (keys.length === 0 && typeof process !== 'undefined' && process.env && process.env.API_KEY) return process.env.API_KEY;
            
            return null;
        };
        
        // Automatick√© p≈ôepnut√≠ na dal≈°√≠ API kl√≠ƒç p≈ôi quota exceeded
        window.switchToNextApiKey = function() {
            const keys = getStoredKeys();
            if (keys.length <= 1) {
                return false; // Nen√≠ kam p≈ôepnout
            }
            
            const currentActiveIndex = keys.findIndex(k => k.active);
            
            // Naj√≠t dal≈°√≠ kl√≠ƒç (cyklicky)
            const nextIndex = (currentActiveIndex + 1) % keys.length;
            
            // Deaktivovat v≈°echny
            keys.forEach(k => k.active = false);
            
            // Aktivovat dal≈°√≠
            keys[nextIndex].active = true;
            
            saveStoredKeys(keys);
            
            console.log(`üîÑ P≈ôepnuto na kl√≠ƒç: ${keys[nextIndex].name || `Kl√≠ƒç ${nextIndex + 1}`}`);
            
            return true; // √öspƒõ≈°nƒõ p≈ôepnuto
        };

        // Show AI performance metrics
        window.showAIMetrics = function() {
            const successRate = aiMetrics.totalRequests > 0 
                ? (aiMetrics.successfulRequests / aiMetrics.totalRequests * 100).toFixed(1)
                : 0;
            
            const metricsText = `üìä AI Performance Metrics

üìà Requests:
  ‚Ä¢ Total: ${aiMetrics.totalRequests}
  ‚Ä¢ Successful: ${aiMetrics.successfulRequests}
  ‚Ä¢ Failed: ${aiMetrics.failedRequests}
  ‚Ä¢ Success Rate: ${successRate}%

‚è±Ô∏è Performance:
  ‚Ä¢ Avg Latency: ${aiMetrics.avgLatency.toFixed(0)}ms
  
üí° Tips:
  ‚Ä¢ Success rate >90% = Good
  ‚Ä¢ Latency <2000ms = Good
  ‚Ä¢ Use Gemini 2.5 Flash for speed
  ‚Ä¢ Use Gemini 3 Pro for complex tasks`;
            
            alert(metricsText);
        };

        window.openSettings = function() {
            document.getElementById('settingsModal').style.display = 'flex';
            renderKeyList();
        };

        window.closeSettings = function() {
            document.getElementById('settingsModal').style.display = 'none';
        };
        
        // QUICK INPUT LOGIC
        window.openQuickInput = function() {
            const modal = document.getElementById('quickInputModal');
            const mainInput = document.getElementById('aiPrompt');
            const display = document.getElementById('quickInputDisplay');
            
            // Sync current prompt to display
            if (display && mainInput) {
                display.value = mainInput.value;
            }
            
            modal.style.display = 'flex';
        };
        
        window.closeQuickInput = function() {
            document.getElementById('quickInputModal').style.display = 'none';
            // Return focus to input
            const input = document.getElementById('aiPrompt');
            if(input) input.focus();
        };
        
        window.confirmQuickInput = function() {
            const mainInput = document.getElementById('aiPrompt');
            const display = document.getElementById('quickInputDisplay');
            
            if (mainInput && display) {
                mainInput.value = display.value;
            }
            window.closeQuickInput();
        };
        
        window.insertToken = function(text) {
            const input = document.getElementById('quickInputDisplay');
            if (!input) return;
            
            // Insert at cursor position
            const start = input.selectionStart;
            const end = input.selectionEnd;
            const val = input.value;
            
            input.value = val.substring(0, start) + text + val.substring(end);
            
            // Move cursor after insertion
            input.selectionStart = input.selectionEnd = start + text.length;
            input.focus();
        };
        
        window.backspaceToken = function() {
            const input = document.getElementById('quickInputDisplay');
            if (!input) return;
            
            const start = input.selectionStart;
            const end = input.selectionEnd;
            const val = input.value;
            
            if (start === end && start > 0) {
                // Delete previous char
                input.value = val.substring(0, start - 1) + val.substring(end);
                input.selectionStart = input.selectionEnd = start - 1;
            } else if (start !== end) {
                // Delete selection
                input.value = val.substring(0, start) + val.substring(end);
                input.selectionStart = input.selectionEnd = start;
            }
            input.focus();
        };
        
        window.showQuickInputHelp = function() {
            const helpModal = document.getElementById('quickInputHelpModal');
            if (helpModal) helpModal.style.display = 'flex';
        };
        
        window.closeQuickInputHelp = function() {
            const helpModal = document.getElementById('quickInputHelpModal');
            if (helpModal) helpModal.style.display = 'none';
        };
        
        // --- CONTROLLER MODAL LOGIC ---
        let controllerInputBuffer = '';
        let controllerMode = 'G90'; // 'G90' = absolutn√≠, 'G91' = p≈ô√≠r≈Østkov√©
        let pendingDirection = null; // Smƒõr ƒçekaj√≠c√≠ na potvrzen√≠
        
        function showControllerModal() {
            const modal = document.getElementById('controllerModal');
            if (modal) modal.style.display = 'flex';
            updateControllerLastPoint();
            updateControllerInputDisplay();
        }
        
        function closeControllerModal() {
            const modal = document.getElementById('controllerModal');
            if (modal) modal.style.display = 'none';
            controllerInputBuffer = '';
            pendingDirection = null;
            updateControllerInputDisplay();
        }
        
        function setControllerMode(mode) {
            controllerMode = mode;
            
            // Update button styles
            const btnG90 = document.getElementById('btnG90');
            const btnG91 = document.getElementById('btnG91');
            
            if (mode === 'G90') {
                btnG90.style.background = '#3a7bc8';
                btnG90.style.borderColor = '#5a9be8';
                btnG90.style.color = 'white';
                btnG91.style.background = '#2a2a2a';
                btnG91.style.borderColor = '#444';
                btnG91.style.color = '#888';
            } else {
                btnG91.style.background = '#3a7bc8';
                btnG91.style.borderColor = '#5a9be8';
                btnG91.style.color = 'white';
                btnG90.style.background = '#2a2a2a';
                btnG90.style.borderColor = '#444';
                btnG90.style.color = '#888';
            }
            
            // Update display
            const modeDisplay = document.getElementById('controllerModeDisplay');
            if (modeDisplay) {
                modeDisplay.textContent = mode === 'G90' ? 'G90 (Absolutn√≠)' : 'G91 (P≈ô√≠r≈Østkov√©)';
            }
        }
        
        function updateControllerLastPoint() {
            // Naj√≠t posledn√≠ bod
            let lastPoint = null;
            
            if (shapes.length > 0) {
                const lastShape = shapes[shapes.length - 1];
                if (lastShape.type === 'line') {
                    lastPoint = {x: lastShape.x2, y: lastShape.y2};
                } else if (lastShape.type === 'circle') {
                    lastPoint = {x: lastShape.cx, y: lastShape.cy};
                }
            }
            
            if (!lastPoint && points.length > 0) {
                const p = points[points.length - 1];
                lastPoint = {x: p.x, y: p.y};
            }
            
            const inlineDisplay = document.getElementById('controllerLastPointInline');
            if (inlineDisplay) {
                if (lastPoint) {
                    const displayY = (xMeasureMode === 'diameter') ? lastPoint.y * 2 : lastPoint.y;
                    inlineDisplay.textContent = `Z${lastPoint.x.toFixed(2)} X${displayY.toFixed(2)}`;
                } else {
                    inlineDisplay.textContent = '‚Äî';
                }
            }
        }
        
        function updateControllerInputDisplay() {
            const input = document.getElementById('controllerInput');
            if (input) {
                input.value = controllerInputBuffer;
            }
        }
        
        function insertControllerToken(text) {
            controllerInputBuffer += text;
            updateControllerInputDisplay();
        }
        
        function backspaceControllerToken() {
            if (controllerInputBuffer.length > 0) {
                controllerInputBuffer = controllerInputBuffer.slice(0, -1);
                updateControllerInputDisplay();
            }
        }
        
        function confirmControllerInput() {
            const input = controllerInputBuffer.trim();
            
            if (!input) {
                alert('Zadej p≈ô√≠kaz (nap≈ô. G0 X50 Z100 nebo G1 X100)');
                return;
            }
            
            // Zkusit zpracovat jako G-k√≥d p≈ô√≠kaz
            const parsed = parseGCode(input, controllerMode);
            
            if (parsed) {
                // Reset
                controllerInputBuffer = '';
                pendingDirection = null;
                updateControllerInputDisplay();
                updateControllerLastPoint();
            } else {
                // Pokud nen√≠ G-k√≥d a m√°me pendingDirection, pou≈æ√≠t smƒõrov√Ω re≈æim
                if (pendingDirection) {
                    executeDirectionDraw(pendingDirection, input);
                    controllerInputBuffer = '';
                    pendingDirection = null;
                    updateControllerInputDisplay();
                } else {
                    alert('Neplatn√Ω p≈ô√≠kaz! Pou≈æij G-k√≥d (G0, G1, G2, G3) nebo klikni na ≈°ipku a zadej parametry.');
                }
            }
        }
        
        // Parsov√°n√≠ G-k√≥du (podobn√© jako v AI)
        function parseGCode(input, mode) {
            input = input.toUpperCase().trim();
            
            // Naj√≠t posledn√≠ bod
            let lastPoint = null;
            if (shapes.length > 0) {
                const lastShape = shapes[shapes.length - 1];
                if (lastShape.type === 'line') {
                    lastPoint = {x: lastShape.x2, y: lastShape.y2};
                } else if (lastShape.type === 'circle') {
                    lastPoint = {x: lastShape.cx, y: lastShape.cy};
                }
            }
            if (!lastPoint && points.length > 0) {
                const p = points[points.length - 1];
                lastPoint = {x: p.x, y: p.y};
            }
            if (!lastPoint) {
                lastPoint = {x: 0, y: 0}; // Default
            }
            
            // Rozdƒõlit na p≈ô√≠kazy (st≈ôedn√≠k)
            const commands = input.split(';').map(c => c.trim()).filter(c => c);
            
            for (const cmd of commands) {
                // Detekce G-k√≥du
                const gMatch = cmd.match(/^G(\d+)/);
                if (!gMatch) continue;
                
                const gCode = parseInt(gMatch[1]);
                
                // Parse parametr≈Ø
                const xMatch = cmd.match(/X(-?\d+\.?\d*)/);
                const zMatch = cmd.match(/Z(-?\d+\.?\d*)/);
                const rMatch = cmd.match(/R(-?\d+\.?\d*)/);
                const dMatch = cmd.match(/D(-?\d+\.?\d*)/);
                const lMatch = cmd.match(/L(-?\d+\.?\d*)/);
                const aMatch = cmd.match(/A(-?\d+\.?\d*)/);
                const rpMatch = cmd.match(/RP(-?\d+\.?\d*)/);
                const apMatch = cmd.match(/AP(-?\d+\.?\d*)/);
                const iMatch = cmd.match(/I(-?\d+\.?\d*)/);
                const jMatch = cmd.match(/J(-?\d+\.?\d*)/);
                
                if (gCode === 0) {
                    // G0 - Vytvo≈ôen√≠ bodu
                    let x = lastPoint.x;
                    let y = lastPoint.y;
                    
                    if (mode === 'G91') {
                        x += zMatch ? parseFloat(zMatch[1]) : 0;
                        y += xMatch ? parseFloat(xMatch[1]) : 0;
                    } else {
                        x = zMatch ? parseFloat(zMatch[1]) : x;
                        y = xMatch ? parseFloat(xMatch[1]) : y;
                    }
                    
                    points.push({x, y});
                    lastPoint = {x, y};
                    updateSnapPoints();
                    draw();
                    
                } else if (gCode === 1) {
                    // G1 - P≈ô√≠mka
                    let x = lastPoint.x;
                    let y = lastPoint.y;
                    
                    // Pol√°rn√≠ sou≈ôadnice
                    const length = lMatch ? parseFloat(lMatch[1]) : (rpMatch ? parseFloat(rpMatch[1]) : null);
                    const angle = apMatch ? parseFloat(apMatch[1]) : (aMatch ? parseFloat(aMatch[1]) : null);
                    
                    if (length !== null && angle !== null) {
                        const rad = angle * Math.PI / 180;
                        x = lastPoint.x + length * Math.cos(rad);
                        y = lastPoint.y + length * Math.sin(rad);
                    } else {
                        if (mode === 'G91') {
                            x += zMatch ? parseFloat(zMatch[1]) : 0;
                            y += xMatch ? parseFloat(xMatch[1]) : 0;
                        } else {
                            x = zMatch ? parseFloat(zMatch[1]) : x;
                            y = xMatch ? parseFloat(xMatch[1]) : y;
                        }
                    }
                    
                    shapes.push({
                        type: 'line',
                        x1: lastPoint.x,
                        y1: lastPoint.y,
                        x2: x,
                        y2: y
                    });
                    
                    lastPoint = {x, y};
                    updateSnapPoints();
                    draw();
                    
                } else if (gCode === 2 || gCode === 3) {
                    // G2/G3 - Oblouky (zjednodu≈°en√° verze - kru≈ænice)
                    const r = rMatch ? parseFloat(rMatch[1]) : (dMatch ? parseFloat(dMatch[1]) / 2 : null);
                    
                    if (r) {
                        shapes.push({
                            type: 'circle',
                            cx: lastPoint.x,
                            cy: lastPoint.y,
                            r: r
                        });
                        
                        updateSnapPoints();
                        draw();
                    }
                }
            }
            
            return commands.length > 0;
        }
        
        window.showDirectionModal = function() {
            const modal = document.getElementById('directionModal');
            if (modal) modal.style.display = 'flex';
        }
        
        window.closeDirectionModal = function() {
            const modal = document.getElementById('directionModal');
            if (modal) modal.style.display = 'none';
        }
        
        window.insertDirectionCommand = function(direction) {
            // Smƒõrov√© √∫hly
            const directionAngles = {
                'E': 0,      // ‚Üí
                'NE': 45,    // ‚Üó
                'N': 90,     // ‚Üë
                'NW': 135,   // ‚Üñ
                'W': 180,    // ‚Üê
                'SW': 225,   // ‚Üô
                'S': 270,    // ‚Üì
                'SE': 315    // ‚Üò
            };
            
            const angle = directionAngles[direction];
            
            // Vlo≈æit p≈ô√≠kaz podle aktu√°ln√≠ho re≈æimu
            if (controllerMode === 'G91') {
                // P≈ô√≠r≈Østkov√Ω re≈æim: G1 G91 AP90 L
                controllerInputBuffer = `G1 G91 AP${angle} L`;
            } else {
                // Absolutn√≠ re≈æim: G1 AP90 L (m√©nƒõ ƒçasto pou≈æ√≠van√©, ale OK)
                controllerInputBuffer = `G1 AP${angle} L`;
            }
            
            updateControllerInputDisplay();
            window.closeDirectionModal();
            
            // Focus na input
            const input = document.getElementById('controllerInput');
            if (input) input.focus();
        }
        
        function drawDirection(direction) {
            // Naj√≠t startovn√≠ bod
            let startPoint = null;
            
            if (shapes.length > 0) {
                const lastShape = shapes[shapes.length - 1];
                if (lastShape.type === 'line') {
                    startPoint = {x: lastShape.x2, y: lastShape.y2};
                } else if (lastShape.type === 'circle') {
                    startPoint = {x: lastShape.cx, y: lastShape.cy};
                }
            }
            
            if (!startPoint && points.length > 0) {
                const p = points[points.length - 1];
                startPoint = {x: p.x, y: p.y};
            }
            
            if (!startPoint) {
                alert('Nen√≠ definov√°n ≈æ√°dn√Ω bod! Nejprve vytvo≈ô bod pomoc√≠ G0 nebo nakresli prvn√≠ √∫seƒçku.');
                return;
            }
            
            // Ulo≈æit ƒçekaj√≠c√≠ smƒõr
            pendingDirection = direction;
            
            // Focus na input
            const input = document.getElementById('controllerInput');
            if (input) input.focus();
        }
        
        function executeDirectionDraw(direction, input) {
            // Naj√≠t startovn√≠ bod
            let startPoint = null;
            
            if (shapes.length > 0) {
                const lastShape = shapes[shapes.length - 1];
                if (lastShape.type === 'line') {
                    startPoint = {x: lastShape.x2, y: lastShape.y2};
                } else if (lastShape.type === 'circle') {
                    startPoint = {x: lastShape.cx, y: lastShape.cy};
                }
            }
            
            if (!startPoint && points.length > 0) {
                const p = points[points.length - 1];
                startPoint = {x: p.x, y: p.y};
            }
            
            if (!startPoint) {
                alert('Nen√≠ definov√°n ≈æ√°dn√Ω bod!');
                return;
            }
            
            // Parsovat vstup
            const endPoint = parseControllerInput(input, startPoint, direction, controllerMode);
            
            if (endPoint) {
                // Vytvo≈ôit √∫seƒçku
                shapes.push({
                    type: 'line',
                    x1: startPoint.x,
                    y1: startPoint.y,
                    x2: endPoint.x,
                    y2: endPoint.y
                });
                
                updateSnapPoints();
                draw();
                updateControllerLastPoint();
            }
        }
        
        function parseControllerInput(input, startPoint, direction, mode) {
            input = input.trim().toUpperCase();
            
            // Smƒõrov√© √∫hly pro jednotliv√© smƒõry
            const directionAngles = {
                'E': 0,      // ‚Üí
                'NE': 45,    // ‚Üó
                'N': 90,     // ‚Üë
                'NW': 135,   // ‚Üñ
                'W': 180,    // ‚Üê
                'SW': 225,   // ‚Üô
                'S': 270,    // ‚Üì
                'SE': 315    // ‚Üò
            };
            
            // Pokud je to jen ƒç√≠slo - d√©lka ve smƒõru
            if (/^-?\d+\.?\d*$/.test(input)) {
                const length = parseFloat(input);
                const angle = directionAngles[direction];
                const rad = angle * Math.PI / 180;
                
                return {
                    x: startPoint.x + length * Math.cos(rad),
                    y: startPoint.y + length * Math.sin(rad)
                };
            }
            
            // Parsovat X a Z sou≈ôadnice
            const xMatch = input.match(/X(-?\d+\.?\d*)/);
            const zMatch = input.match(/Z(-?\d+\.?\d*)/);
            
            if (xMatch || zMatch) {
                if (mode === 'G91') {
                    // P≈ô√≠r≈Østkov√© sou≈ôadnice
                    return {
                        x: startPoint.x + (zMatch ? parseFloat(zMatch[1]) : 0),
                        y: startPoint.y + (xMatch ? parseFloat(xMatch[1]) : 0)
                    };
                } else {
                    // Absolutn√≠ sou≈ôadnice (G90)
                    return {
                        x: zMatch ? parseFloat(zMatch[1]) : startPoint.x,
                        y: xMatch ? parseFloat(xMatch[1]) : startPoint.y
                    };
                }
            }
            
            // Parsovat L/RP (d√©lka) a A/AP (√∫hel) - POL√ÅRN√ç SOU≈òADNICE
            const lMatch = input.match(/L(-?\d+\.?\d*)/);
            const rpMatch = input.match(/RP(-?\d+\.?\d*)/);
            const aMatch = input.match(/A(-?\d+\.?\d*)/);
            const apMatch = input.match(/AP(-?\d+\.?\d*)/);
            
            const length = lMatch ? parseFloat(lMatch[1]) : (rpMatch ? parseFloat(rpMatch[1]) : null);
            const angle = apMatch ? parseFloat(apMatch[1]) : (aMatch ? parseFloat(aMatch[1]) : null);
            
            if (length !== null) {
                const finalAngle = angle !== null ? angle : directionAngles[direction];
                const rad = finalAngle * Math.PI / 180;
                
                return {
                    x: startPoint.x + length * Math.cos(rad),
                    y: startPoint.y + length * Math.sin(rad)
                };
            }
            
            alert('Neplatn√Ω vstup! Pou≈æij:\n‚Ä¢ D√©lku: 50\n‚Ä¢ Sou≈ôadnice: X100 Z50\n‚Ä¢ Pol√°rn√≠: L50 AP45 nebo RP50 AP45');
            return null;
        }
        
        // --- VOICE INPUT LOGIC ---
        let recognition = null;
        let isRecording = false;

        if ('webkitSpeechRecognition' in window) {
            // @ts-ignore
            recognition = new webkitSpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'cs-CZ';

            recognition.onstart = function() {
                isRecording = true;
                const btn = document.getElementById('btnVoice');
                if (btn) btn.classList.add('recording-pulse');
            };

            recognition.onend = function() {
                isRecording = false;
                const btn = document.getElementById('btnVoice');
                if (btn) btn.classList.remove('recording-pulse');
            };

            recognition.onresult = function(event) {
                const text = event.results[0][0].transcript;
                const input = document.getElementById('aiPrompt');
                if (input) {
                    // Append text with space
                    input.value += (input.value.length > 0 ? ' ' : '') + text;
                    input.focus();
                }
            };
            
            recognition.onerror = function(event) {
                console.error("Speech error", event.error);
                isRecording = false;
                const btn = document.getElementById('btnVoice');
                if (btn) btn.classList.remove('recording-pulse');
                
                // Informovat u≈æivatele o probl√©mu s povolen√≠m
                if (event.error === 'not-allowed' || event.error === 'permission-denied') {
                    alert('‚ö†Ô∏è P≈ô√≠stup k mikrofonu byl zam√≠tnut.\n\nPovolte p≈ô√≠stup k mikrofonu v nastaven√≠ prohl√≠≈æeƒçe a zkuste to znovu.');
                } else if (event.error === 'no-speech') {
                    // Tich√Ω error - u≈æivatel nemluvil
                } else {
                    alert('Chyba hlasov√©ho rozpozn√°v√°n√≠: ' + event.error);
                }
            };
        }

        window.toggleVoice = function() {
            if (!recognition) {
                alert("V√°≈° prohl√≠≈æeƒç nepodporuje hlasov√© zad√°v√°n√≠.");
                return;
            }
            
            if (isRecording) {
                recognition.stop();
            } else {
                recognition.start();
            }
        };
        
        // Zav≈ôen√≠ mod√°lu kliknut√≠m mimo
        document.getElementById('settingsModal').addEventListener('click', (e) => {
            if (e.target.id === 'settingsModal') window.closeSettings();
        });
        
        document.getElementById('quickInputModal').addEventListener('click', (e) => {
            if (e.target.id === 'quickInputModal') window.closeQuickInput();
        });

        window.addApiKey = function() {
            const nameInput = document.getElementById('newKeyName');
            const keyInput = document.getElementById('newKeyValue');
            const name = nameInput.value.trim() || 'Nov√Ω kl√≠ƒç';
            const key = keyInput.value.trim();

            if (!key) {
                alert('Zadejte pros√≠m API kl√≠ƒç.');
                return;
            }

            const keys = getStoredKeys();
            
            // Deaktivovat ostatn√≠
            keys.forEach(k => k.active = false);

            keys.push({
                name: name,
                key: key,
                active: true,
                created: Date.now()
            });

            saveStoredKeys(keys);
            nameInput.value = '';
            keyInput.value = '';
        };

        window.saveDefaultKey = function() {
            // Usually not used in this environment unless user clicks it
            alert("Funkce nen√≠ dostupn√°.");
        };

        window.deleteKey = function(index) {
            if(!confirm('Opravdu smazat tento kl√≠ƒç?')) return;
            const keys = getStoredKeys();
            keys.splice(index, 1);
            
            // Pokud jsme smazali aktivn√≠ a m√°me jin√©, aktivuj prvn√≠
            if (keys.length > 0 && !keys.some(k => k.active)) {
                keys[0].active = true;
            }
            
            saveStoredKeys(keys);
        };

        window.selectKey = function(index) {
            const keys = getStoredKeys();
            keys.forEach((k, i) => k.active = (i === index));
            saveStoredKeys(keys);
        };

        function renderKeyList() {
            const list = document.getElementById('keyList');
            const keys = getStoredKeys();
            
            list.innerHTML = '';
            
            // Pokud nem√°me ≈æ√°dn√© ulo≈æen√© kl√≠ƒçe, zobraz√≠me mo≈ænost ulo≈æit defaultn√≠
            if (keys.length === 0) {
                 const div = document.createElement('div');
                div.className = 'key-item demo-active'; // Speci√°ln√≠ styl pro demo
                
                div.innerHTML = `
                    <div>
                        <div class="key-name">Demo Kl√≠ƒç <span style="color:#a78bfa; font-size:10px; margin-left:5px;">(Syst√©mov√Ω)</span></div>
                        <div class="key-val">Automaticky pou≈æit</div>
                    </div>
                `;
                list.appendChild(div);
                return;
            }

            // Renderov√°n√≠ ulo≈æen√Ωch kl√≠ƒç≈Ø
            keys.forEach((k, i) => {
                const div = document.createElement('div');
                div.className = `key-item ${k.active ? 'active' : ''}`;
                div.onclick = (e) => {
                     // Prevence spu≈°tƒõn√≠ p≈ôi kliku na delete button
                    if(e.target.tagName !== 'BUTTON') window.selectKey(i);
                };
                
                // Maskov√°n√≠ kl√≠ƒçe (uk√°zat jen zaƒç√°tek a konec)
                const maskedKey = k.key.length > 10 
                    ? k.key.substring(0, 6) + '...' + k.key.substring(k.key.length - 4) 
                    : '***';

                div.innerHTML = `
                    <div>
                        <div class="key-name">${k.name} ${k.active ? '<span style="color:#4ade80; font-size:10px; margin-left:5px;">(Aktivn√≠)</span>' : ''}</div>
                        <div class="key-val">${maskedKey}</div>
                    </div>
                    <button class="key-delete" onclick="window.deleteKey(${i})">Smazat</button>
                `;
                list.appendChild(div);
            });
        }
        
        function updateKeyIndicator() {
            const keys = getStoredKeys();
            const active = keys.find(k => k.active);
            const el = document.getElementById('keyIndicator');
            
            if (el) {
                if (active) {
                    el.innerHTML = `Kl√≠ƒç: <span style="color:#4ade80">${active.name}</span>`;
                } else if (keys.length === 0) {
                    // Pou≈æ√≠v√°me default
                    el.innerHTML = `Kl√≠ƒç: <span style="color:#a78bfa">Demo (P≈ôednastaven√Ω)</span>`;
                } else {
                    el.innerHTML = `Kl√≠ƒç: <span style="color:#ef4444">≈Ω√°dn√Ω</span>`;
                }
            }
        }
        
        // === API KEY MANAGER END ===
        
        // --- LOGIKA PRO MOD√ÅLN√ç OKNO KRU≈ΩNICE ---

        window.openCircleModal = function(center, initialRadius) {
            pendingCircleCenter = center;
            // Pokud je zapnut√Ω pr≈Ømƒõr, initialRadius je vizu√°lnƒõ polomƒõr, ale u≈æivatel chce vidƒõt pr≈Ømƒõr
            // Pokud je pr≈Ømƒõrov√Ω re≈æim, zobraz√≠me pr≈Ømƒõr jako default (2*r)
            // Ale pozor, kru≈ænice se zad√°v√° polomƒõrem.
            // V dialogu m√°me input R a input D.
            document.getElementById('circleInputR').value = initialRadius.toFixed(2);
            document.getElementById('circleInputD').value = (initialRadius * 2).toFixed(2);
            document.getElementById('circleModal').style.display = 'flex';
            setTimeout(() => document.getElementById('circleInputR').focus(), 100);
        }

        window.closeCircleModal = function() {
            document.getElementById('circleModal').style.display = 'none';
            pendingCircleCenter = null;
            tempShape = null; // Zru≈°it preview
            draw();
        }

        window.confirmCircle = function() {
            const r = parseFloat(document.getElementById('circleInputR').value);
            if (pendingCircleCenter && !isNaN(r) && r > 0) {
                shapes.push({
                    type: 'circle',
                    cx: pendingCircleCenter.x,
                    cy: pendingCircleCenter.y,
                    r: r
                });
                updateSnapPoints();
            }
            closeCircleModal();
        }

        window.updateCircleInputs = function(source) {
            const inputR = document.getElementById('circleInputR');
            const inputD = document.getElementById('circleInputD');
            
            if (source === 'R') {
                const r = parseFloat(inputR.value);
                if (!isNaN(r)) inputD.value = (r * 2).toFixed(2);
            } else {
                const d = parseFloat(inputD.value);
                if (!isNaN(d)) inputR.value = (d / 2).toFixed(2);
            }
        }

        // Zav≈ôen√≠ mod√°lu kliknut√≠m mimo
        document.getElementById('circleModal').addEventListener('click', (e) => {
            if (e.target.id === 'circleModal') window.closeCircleModal();
        });
        
        function init() {
            if (!canvas.parentElement) return;
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            panX = canvas.width / 2;
            panY = canvas.height / 2;
            updateSnapPoints(); // Inicializovat body
            draw();
            
            // EXPOSE GLOBALS FOR AI MODULE
            window.shapes = shapes;
            window.selectedItems = selectedItems; // Expose selections
            window.draw = draw;
            window.updateSnapPoints = updateSnapPoints;
            window.axisMode = axisMode;
            
            // Init Key Manager UI
            updateKeyIndicator();
        }
        
        function worldToScreen(wx, wy) {
            return {
                x: wx * zoom + panX,
                y: panY - wy * zoom
            };
        }
        
        function screenToWorld(sx, sy) {
            return {
                x: (sx - panX) / zoom,
                y: (panY - sy) / zoom
            };
        }
        
        // --- MATH FUNKCE PRO PR≈ÆSEƒå√çKY ---
        
        function intersectLineCircle(line, circle) {
            const dx = line.x2 - line.x1;
            const dy = line.y2 - line.y1;
            const fx = line.x1 - circle.cx;
            const fy = line.y1 - circle.cy;
            
            const a = dx * dx + dy * dy;
            const b = 2 * (fx * dx + fy * dy);
            const c = (fx * fx + fy * fy) - circle.r * circle.r;
            
            const discriminant = b * b - 4 * a * c;
            if (discriminant < 0) return [];
            
            const t1 = (-b - Math.sqrt(discriminant)) / (2 * a);
            const t2 = (-b + Math.sqrt(discriminant)) / (2 * a);
            
            const pts = [];
            if (t1 >= 0 && t1 <= 1) {
                pts.push({x: line.x1 + t1 * dx, y: line.y1 + t1 * dy});
            }
            if (t2 >= 0 && t2 <= 1) {
                pts.push({x: line.x1 + t2 * dx, y: line.y1 + t2 * dy});
            }
            return pts;
        }

        function intersectCircleCircle(c1, c2) {
            const dx = c2.cx - c1.cx;
            const dy = c2.cy - c1.cy;
            const d = Math.sqrt(dx * dx + dy * dy);
            
            if (d > c1.r + c2.r || d < Math.abs(c1.r - c2.r) || d === 0) return [];
            
            const a = (c1.r * c1.r - c2.r * c2.r + d * d) / (2 * d);
            const h = Math.sqrt(Math.max(0, c1.r * c1.r - a * a));
            
            const x2 = c1.cx + a * (dx / d);
            const y2 = c1.cy + a * (dy / d);
            
            return [
                {
                    x: x2 + h * (dy / d),
                    y: y2 - h * (dx / d)
                },
                {
                    x: x2 - h * (dy / d),
                    y: y2 + h * (dx / d)
                }
            ];
        }

        // --- AKTUALIZACE BOD≈Æ ---
        
        function updateSnapPoints() {
            cachedSnapPoints = [];
            
            // 1. Manu√°ln√≠ body
            points.forEach(p => {
                cachedSnapPoints.push({x: p.x, y: p.y, type: 'point', ref: p});
            });
            
            // 2. Koncov√© body a st≈ôedy z tvar≈Ø
            shapes.forEach(s => {
                if (s.type === 'line') {
                    cachedSnapPoints.push({x: s.x1, y: s.y1, type: 'endpoint'});
                    cachedSnapPoints.push({x: s.x2, y: s.y2, type: 'endpoint'});
                } else if (s.type === 'circle') {
                    cachedSnapPoints.push({x: s.cx, y: s.cy, type: 'center'});
                }
            });
            
            // 3. Pr≈Øseƒç√≠ky
            for (let i = 0; i < shapes.length; i++) {
                for (let j = i + 1; j < shapes.length; j++) {
                    const s1 = shapes[i];
                    const s2 = shapes[j];
                    let intersects = [];
                    
                    if (s1.type === 'line' && s2.type === 'line') {
                        const pt = lineIntersection(s1, s2);
                        if (pt) intersects.push(pt);
                    } else if (s1.type === 'line' && s2.type === 'circle') {
                        intersects = intersectLineCircle(s1, s2);
                    } else if (s1.type === 'circle' && s2.type === 'line') {
                        intersects = intersectLineCircle(s2, s1);
                    } else if (s1.type === 'circle' && s2.type === 'circle') {
                        intersects = intersectCircleCircle(s1, s2);
                    }
                    
                    intersects.forEach(pt => {
                        cachedSnapPoints.push({x: pt.x, y: pt.y, type: 'intersection'});
                    });
                }
            }
        }
        
        // P≈ôichycen√≠ bodu
        function snapPoint(pt) {
            let snapped = {...pt};
            let snapInfo = null;
            
            // 1. Zkontrolovat V≈†ECHNY zaj√≠mav√© body (manu√°ln√≠, konce, pr≈Øseƒç√≠ky)
            let bestDist = snapDistance; // Max vzd√°lenost
            
            for (let p of cachedSnapPoints) {
                const screenP = worldToScreen(p.x, p.y);
                const screenPt = worldToScreen(pt.x, pt.y);
                const dist = Math.sqrt((screenP.x - screenPt.x) ** 2 + (screenP.y - screenPt.y) ** 2);
                
                if (dist < bestDist) {
                    bestDist = dist;
                    snapped = {x: p.x, y: p.y};
                    snapInfo = {type: p.type, x: p.x, y: p.y};
                }
            }
            
            // Pokud jsme nena≈°li bod, zkus√≠me m≈ô√≠≈æku
            if (!snapInfo && snapToGrid) {
                const gx = Math.round(pt.x / gridSize) * gridSize;
                const gy = Math.round(pt.y / gridSize) * gridSize;
                const screenG = worldToScreen(gx, gy);
                const screenPt = worldToScreen(pt.x, pt.y);
                const dist = Math.sqrt((screenG.x - screenPt.x) ** 2 + (screenG.y - screenPt.y) ** 2);
                
                if (dist < snapDistance) {
                    snapped.x = gx;
                    snapped.y = gy;
                    snapInfo = {type: 'grid', x: gx, y: gy};
                }
            }
            
            return {point: snapped, snapInfo};
        }
        
        function updateSnap() {
            snapToGrid = document.getElementById('snapGrid').checked;
            snapToPoints = document.getElementById('snapPoints').checked;
            const orthoCheckbox = document.getElementById('orthoMode');
            if (orthoCheckbox) orthoMode = orthoCheckbox.checked;
            snapDistance = parseFloat(document.getElementById('snapDistance').value);
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (document.getElementById('showGrid').checked) {
                drawGrid();
            }
            
            if (document.getElementById('showAxes').checked) {
                drawAxes();
            }
            
            shapes.forEach(s => drawShape(s));
            if (tempShape) {
                // Speci√°ln√≠ barva pro ortogon√°ln√≠ ƒç√°ry
                if (tempShape.ortho) {
                    ctx.save();
                    ctx.strokeStyle = '#00ff00'; // Zelen√° pro ortho
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]); // ƒå√°rkovan√°
                    drawShape(tempShape);
                    ctx.restore();
                } else {
                    drawShape(tempShape);
                }
            }
            
            // Draw Selected Items (Highlight + Labels)
            if (selectedItems.length > 0) {
                selectedItems.forEach(item => {
                    let centerX, centerY;
                    
                    if (item.category === 'shape') {
                        // Kreslen√≠ vybran√©ho tvaru (zv√Ωraznƒõn√≠)
                        const s = item.ref;
                        ctx.strokeStyle = '#ff66ff'; // Magenta highlight
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                         if (s.type === 'line') {
                            const p1 = worldToScreen(s.x1, s.y1);
                            const p2 = worldToScreen(s.x2, s.y2);
                            ctx.moveTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                            centerX = (p1.x + p2.x) / 2;
                            centerY = (p1.y + p2.y) / 2;
                        } else if (s.type === 'circle') {
                            const c = worldToScreen(s.cx, s.cy);
                            ctx.arc(c.x, c.y, s.r * zoom, 0, Math.PI * 2);
                            centerX = c.x + (s.r * zoom);
                            centerY = c.y;
                        }
                        ctx.stroke();
                    } else if (item.category === 'point') {
                        // Kreslen√≠ vybran√©ho bodu
                        const sp = worldToScreen(item.x, item.y);
                        ctx.fillStyle = '#ff66ff';
                        ctx.beginPath();
                        ctx.arc(sp.x, sp.y, 6, 0, Math.PI * 2); // Vƒõt≈°√≠ teƒçka
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        centerX = sp.x;
                        centerY = sp.y;
                    }
                    
                    // Draw Label (A, B, C...)
                    if (item.label && centerX !== undefined) {
                        ctx.fillStyle = '#ff66ff';
                        ctx.fillRect(centerX + 8, centerY - 15, 16, 16);
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 11px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(item.label, centerX + 16, centerY - 7);
                    }
                });
            }

            // Kreslen√≠ prvn√≠ho bodu (pokud je nastaven startPt a nekresl√≠me ta≈æen√≠m)
            if (startPt && (mode === 'line' || mode === 'circle')) {
                const sp = worldToScreen(startPt.x, startPt.y);
                ctx.beginPath();
                ctx.arc(sp.x, sp.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#00ff00'; // Zelen√Ω bod pro zaƒç√°tek
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Kreslen√≠ v≈°ech bod≈Ø (manu√°ln√≠ i automatick√©)
            if (document.getElementById('showPoints').checked) {
                cachedSnapPoints.forEach(p => {
                    const sp = worldToScreen(p.x, p.y);
                    ctx.beginPath();
                    
                    if (p.type === 'point') {
                        // Manu√°ln√≠ bod - ƒåerven√Ω, trochu vƒõt≈°√≠
                        ctx.fillStyle = '#ff4444';
                        ctx.arc(sp.x, sp.y, 4, 0, Math.PI * 2);
                    } else if (p.type === 'intersection') {
                        // Pr≈Øseƒç√≠k - B√≠l√Ω
                        ctx.fillStyle = '#ffffff';
                        ctx.arc(sp.x, sp.y, 3, 0, Math.PI * 2);
                    } else {
                        // Konec ƒç√°ry / st≈ôed - Svƒõtle modr√Ω/≈°ed√Ω
                        ctx.fillStyle = '#a0a0a0';
                        ctx.arc(sp.x, sp.y, 3, 0, Math.PI * 2);
                    }
                    ctx.fill();
                });
            }
            
            // Zv√Ωraznƒõn√≠ p≈ôichycen√©ho bodu (viditeln√© i bez zobrazen√Ωch bod≈Ø)
            if (mode !== 'pan') {
                // Zjistit, zda je kurzor p≈ôichycen√Ω
                const snapResult = snapPoint(cursorPos);
                if (snapResult.snapInfo) {
                    const sp = worldToScreen(snapResult.point.x, snapResult.point.y);
                    
                    // Velk√Ω ≈ælut√Ω krou≈æek kolem p≈ôichycen√©ho bodu
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(sp.x, sp.y, 10, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Vnit≈ôn√≠ men≈°√≠ krou≈æek
                    ctx.strokeStyle = '#ff8800';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(sp.x, sp.y, 6, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }
        
        function drawGrid() {
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            
            const tl = screenToWorld(0, 0);
            const br = screenToWorld(canvas.width, canvas.height);
            
            // Vypoƒç√≠tat kolik pixel≈Ø na obrazovce zab√≠r√° jeden d√≠lek m≈ô√≠≈æky
            const gridPixels = gridSize * zoom;
            
            // Pokud je m≈ô√≠≈æka p≈ô√≠li≈° hust√° (< 3px na ƒç√°ru), zvƒõt≈°it rozestup
            let displayGrid = gridSize;
            let skipFactor = 1;
            
            if (gridPixels < 3) {
                skipFactor = Math.ceil(3 / gridPixels);
                displayGrid = gridSize * skipFactor;
            }
            
            // Sekund√°rn√≠ jemnƒõj≈°√≠ m≈ô√≠≈æka (svƒõtlej≈°√≠), pokud je skipFactor > 1
            if (skipFactor > 1 && gridPixels * 5 >= 3) {
                ctx.strokeStyle = '#141414';
                const fineGrid = gridSize * Math.min(5, skipFactor);
                const sx = Math.floor(Math.min(tl.x, br.x) / fineGrid) * fineGrid;
                const ex = Math.ceil(Math.max(tl.x, br.x) / fineGrid) * fineGrid;
                const sy = Math.floor(Math.min(tl.y, br.y) / fineGrid) * fineGrid;
                const ey = Math.ceil(Math.max(tl.y, br.y) / fineGrid) * fineGrid;
                
                for (let x = sx; x <= ex; x += fineGrid) {
                    const p = worldToScreen(x, 0);
                    ctx.beginPath();
                    ctx.moveTo(p.x, 0);
                    ctx.lineTo(p.x, canvas.height);
                    ctx.stroke();
                }
                
                for (let y = sy; y <= ey; y += fineGrid) {
                    const p = worldToScreen(0, y);
                    ctx.beginPath();
                    ctx.moveTo(0, p.y);
                    ctx.lineTo(canvas.width, p.y);
                    ctx.stroke();
                }
            }
            
            // Hlavn√≠ m≈ô√≠≈æka
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            
            const sx = Math.floor(Math.min(tl.x, br.x) / displayGrid) * displayGrid;
            const ex = Math.ceil(Math.max(tl.x, br.x) / displayGrid) * displayGrid;
            const sy = Math.floor(Math.min(tl.y, br.y) / displayGrid) * displayGrid;
            const ey = Math.ceil(Math.max(tl.y, br.y) / displayGrid) * displayGrid;
            
            for (let x = sx; x <= ex; x += displayGrid) {
                const p = worldToScreen(x, 0);
                ctx.beginPath();
                ctx.moveTo(p.x, 0);
                ctx.lineTo(p.x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = sy; y <= ey; y += displayGrid) {
                const p = worldToScreen(0, y);
                ctx.beginPath();
                ctx.moveTo(0, p.y);
                ctx.lineTo(canvas.width, p.y);
                ctx.stroke();
            }
            
            // Zobrazit rozmƒõr m≈ô√≠≈æky a zoom v rohu
            ctx.fillStyle = '#4a4a4a';
            ctx.font = '11px Arial';
            const gridLabel = gridSize >= 1 ? `${gridSize}mm` : `${gridSize.toFixed(2)}mm`;
            const displayLabel = skipFactor > 1 ? 
                `M≈ô√≠≈æka: ${gridLabel} (zobrazeno ka≈æd√Ω ${skipFactor}.)` : 
                `M≈ô√≠≈æka: ${gridLabel}`;
            ctx.fillText(displayLabel, 10, canvas.height - 40);
            ctx.fillText(`Zoom: ${(zoom / 2 * 100).toFixed(0)}%`, 10, canvas.height - 25);
        }
        
        function drawAxes() {
            ctx.strokeStyle = '#3a3a3a';
            ctx.lineWidth = 2;
            
            const ox = worldToScreen(0, 0);
            
            // Vodorovn√° osa (osa Z) - ƒåERCHOVAN√Å
            if (ox.y >= 0 && ox.y <= canvas.height) {
                ctx.setLineDash([15, 5, 3, 5]); // Dlouh√°, mezera, teƒçka, mezera
                ctx.beginPath();
                ctx.moveTo(0, ox.y);
                ctx.lineTo(canvas.width, ox.y);
                ctx.stroke();
                ctx.setLineDash([]); // Reset pro zbytek
                
                // ≈†ipka doprava
                ctx.beginPath();
                ctx.moveTo(canvas.width - 15, ox.y - 5);
                ctx.lineTo(canvas.width - 5, ox.y);
                ctx.lineTo(canvas.width - 15, ox.y + 5);
                ctx.stroke();
            }
            
            // Svisl√° osa (osa X) - PLN√Å
            if (ox.x >= 0 && ox.x <= canvas.width) {
                ctx.beginPath();
                ctx.moveTo(ox.x, 0);
                ctx.lineTo(ox.x, canvas.height);
                ctx.stroke();
                
                // ≈†ipka nahoru
                ctx.beginPath();
                ctx.moveTo(ox.x - 5, 15);
                ctx.lineTo(ox.x, 5);
                ctx.lineTo(ox.x + 5, 15);
                ctx.stroke();
            }
            
            // Popisky os
            if (document.getElementById('showAxisLabels').checked) {
                ctx.fillStyle = '#6ab0ff';
                ctx.font = 'bold 14px Arial';
                
                if (axisMode === 'lathe') {
                    // Soustruh: Z vodorovnƒõ, X svisle
                    if (ox.y >= 0 && ox.y <= canvas.height) {
                        ctx.fillText('Z', canvas.width - 25, ox.y - 10);
                        ctx.fillStyle = '#888';
                        ctx.font = '11px Arial';
                        ctx.fillText('(d√©lka)', canvas.width - 60, ox.y - 10);
                    }
                    if (ox.x >= 0 && ox.x <= canvas.width) {
                        ctx.fillStyle = '#6ab0ff';
                        ctx.font = 'bold 14px Arial';
                        ctx.fillText('X', ox.x + 10, 20);
                        ctx.fillStyle = '#888';
                        ctx.font = '11px Arial';
                        // Zmƒõna popisu podle re≈æimu
                        const label = xMeasureMode === 'diameter' ? '(pr≈Ømƒõr ‚åÄ)' : '(polomƒõr R)';
                        ctx.fillText(label, ox.x + 10, 35);
                    }
                } else {
                    // Karusel: X vodorovnƒõ, Y svisle
                    if (ox.y >= 0 && ox.y <= canvas.height) {
                        ctx.fillText('X', canvas.width - 25, ox.y - 10);
                    }
                    if (ox.x >= 0 && ox.x <= canvas.width) {
                        ctx.fillText('Y', ox.x + 10, 20);
                    }
                }
                
                // Oznaƒçen√≠ poƒç√°tku sou≈ôadnic
                if (ox.x >= 0 && ox.x <= canvas.width && ox.y >= 0 && ox.y <= canvas.height) {
                    ctx.strokeStyle = '#6ab0ff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(ox.x, ox.y, 5, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#6ab0ff';
                    ctx.font = '12px Arial';
                    ctx.fillText('0', ox.x + 10, ox.y + 15);
                }
            }
        }
        
        function drawShape(s) {
            let strokeColor = '#4a9eff';
            // Pokud je objekt vybr√°n pro zrcadlen√≠, zv√Ωrazn√≠me ho
            if (selectedShape === s) {
                strokeColor = '#facc15'; // Zlat√° barva pro v√Ωbƒõr
            }

            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;
            
            if (s.type === 'line') {
                const p1 = worldToScreen(s.x1, s.y1);
                const p2 = worldToScreen(s.x2, s.y2);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            }
            
            if (s.type === 'circle') {
                const c = worldToScreen(s.cx, s.cy);
                ctx.beginPath();
                ctx.arc(c.x, c.y, s.r * zoom, 0, Math.PI * 2);
                ctx.stroke();
                
                if (document.getElementById('showDims').checked) {
                    ctx.fillStyle = strokeColor;
                    ctx.font = '12px Arial';
                    // Zobrazit jako pr≈Ømƒõr nebo polomƒõr
                    if (xMeasureMode === 'diameter') {
                        ctx.fillText(`‚åÄ${(s.r * 2).toFixed(1)}`, c.x + s.r * zoom + 5, c.y);
                    } else {
                        ctx.fillText(`R${s.r.toFixed(1)}`, c.x + s.r * zoom + 5, c.y);
                    }
                }
            }
        }
        
        function drawDim(p1, p2, text) {
            const mx = (p1.x + p2.x) / 2;
            const my = (p1.y + p2.y) / 2;
            
            ctx.strokeStyle = '#ffa64d';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            
            ctx.fillStyle = '#ffa64d';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(text, mx, my - 8);
        }
        
        // Kreslen√≠ sou≈ôadnicemi
        function setPointFromCursor() {
            // Z√≠skat Y (X v soustruhu)
            let yVal = cursorPos.y;
            // Pokud je re≈æim pr≈Ømƒõr, vyn√°sobit 2 pro zobrazen√≠
            if (xMeasureMode === 'diameter') yVal *= 2;
            
            document.getElementById('quickPointZ').value = cursorPos.x.toFixed(2);
            document.getElementById('quickPointX').value = yVal.toFixed(2);
        }
        
        function setLineStart() {
            let yVal = cursorPos.y;
            if (xMeasureMode === 'diameter') yVal *= 2;
            
            document.getElementById('lineZ1').value = cursorPos.x.toFixed(2);
            document.getElementById('lineX1').value = yVal.toFixed(2);
        }
        
        function setLineEnd() {
            let yVal = cursorPos.y;
            if (xMeasureMode === 'diameter') yVal *= 2;
            
            document.getElementById('lineZ2').value = cursorPos.x.toFixed(2);
            document.getElementById('lineX2').value = yVal.toFixed(2);
        }
        
        function setCircleCenter() {
            let yVal = cursorPos.y;
            if (xMeasureMode === 'diameter') yVal *= 2;
            
            document.getElementById('quickCircleZ').value = cursorPos.x.toFixed(2);
            document.getElementById('quickCircleX').value = yVal.toFixed(2);
        }
        
        function changeXMeasure() {
            xMeasureMode = document.getElementById('xMeasureSelect').value;
            draw();
        }
        
        function addLineByCoords() {
            const z1 = parseFloat(document.getElementById('lineZ1').value);
            let x1 = parseFloat(document.getElementById('lineX1').value);
            const z2 = parseFloat(document.getElementById('lineZ2').value);
            let x2 = parseFloat(document.getElementById('lineX2').value);
            
            // Konverze zpƒõt na polomƒõr pokud je zad√°no v pr≈Ømƒõru
            if (xMeasureMode === 'diameter') {
                x1 /= 2;
                x2 /= 2;
            }
            
            shapes.push({
                type: 'line',
                x1: z1,
                y1: x1,
                x2: z2,
                y2: x2
            });
            updateSnapPoints();
            draw();
        }
        
        // Pol√°rn√≠ sou≈ôadnice
        function addLinePolar() {
            const z0 = parseFloat(document.getElementById('polarStartZ').value);
            let x0 = parseFloat(document.getElementById('polarStartX').value);
            
            // Konverze start bodu
            if (xMeasureMode === 'diameter') x0 /= 2;
            
            const dist = parseFloat(document.getElementById('polarDist').value);
            const angle = parseFloat(document.getElementById('polarAngle').value) * Math.PI / 180;
            
            const z1 = z0 + dist * Math.cos(angle);
            const x1 = x0 + dist * Math.sin(angle);
            
            shapes.push({
                type: 'line',
                x1: z0,
                y1: x0,
                x2: z1,
                y2: x1
            });
            
            // Aktualizovat poƒç√°teƒçn√≠ bod pro dal≈°√≠ kreslen√≠ (zobrazit v aktu√°ln√≠m re≈æimu)
            let displayX1 = x1;
            if (xMeasureMode === 'diameter') displayX1 *= 2;
            
            document.getElementById('polarStartZ').value = z1.toFixed(2);
            document.getElementById('polarStartX').value = displayX1.toFixed(2);
            
            updateSnapPoints();
            draw();
        }
        
        function addPointPolar() {
            const z0 = parseFloat(document.getElementById('polarStartZ').value);
            let x0 = parseFloat(document.getElementById('polarStartX').value);
            
            if (xMeasureMode === 'diameter') x0 /= 2;
            
            const dist = parseFloat(document.getElementById('polarDist').value);
            const angle = parseFloat(document.getElementById('polarAngle').value) * Math.PI / 180;
            
            const z1 = z0 + dist * Math.cos(angle);
            const x1 = x0 + dist * Math.sin(angle);
            
            points.push({x: z1, y: x1});
            
            let displayX1 = x1;
            if (xMeasureMode === 'diameter') displayX1 *= 2;
            
            document.getElementById('polarStartZ').value = z1.toFixed(2);
            document.getElementById('polarStartX').value = displayX1.toFixed(2);
            
            updateSnapPoints();
            draw();
        }
        
        function quickAddPoint() {
            const z = parseFloat(document.getElementById('quickPointZ').value);
            let x = parseFloat(document.getElementById('quickPointX').value);
            if (isNaN(z) || isNaN(x)) {
                alert('Zadej platn√© sou≈ôadnice');
                return;
            }
            
            if (xMeasureMode === 'diameter') x /= 2;
            
            points.push({x: z, y: x});
            document.getElementById('quickPointZ').value = '';
            document.getElementById('quickPointX').value = '';
            updateSnapPoints();
            draw();
        }
        
        function quickAddCircle() {
            const z = parseFloat(document.getElementById('quickCircleZ').value);
            let x = parseFloat(document.getElementById('quickCircleX').value);
            const r = parseFloat(document.getElementById('quickCircleR').value);
            
            if (isNaN(z) || isNaN(x) || isNaN(r)) {
                alert('Zadej platn√© sou≈ôadnice a polomƒõr');
                return;
            }
            
            if (xMeasureMode === 'diameter') x /= 2;
            
            shapes.push({type: 'circle', cx: z, cy: x, r: r});
            document.getElementById('quickCircleZ').value = '';
            document.getElementById('quickCircleX').value = '';
            document.getElementById('quickCircleR').value = '';
            updateSnapPoints();
            draw();
        }
        
        // Funkce pro hled√°n√≠ pr≈Øseƒç√≠k≈Ø dvou ƒçar
        function lineIntersection(line1, line2) {
            const x1 = line1.x1, y1 = line1.y1, x2 = line1.x2, y2 = line1.y2;
            const x3 = line2.x1, y3 = line2.y1, x4 = line2.x2, y4 = line2.y2;
            
            const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (Math.abs(denom) < 0.0001) return null;
            
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
            
            if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                return {
                    x: x1 + t * (x2 - x1),
                    y: y1 + t * (y2 - y1)
                };
            }
            return null;
        }
        
        // Funkce pro teƒçnu z bodu ke kru≈ænici
        function tangentFromPoint(circle, point) {
            const dx = point.x - circle.cx;
            const dy = point.y - circle.cy;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < circle.r) return null; // Bod uvnit≈ô kru≈ænice
            
            const angle = Math.atan2(dy, dx);
            const tangentAngle = Math.asin(circle.r / dist);
            
            const tangents = [];
            for (let sign of [-1, 1]) {
                const a = angle + sign * tangentAngle;
                const touchX = circle.cx + circle.r * Math.cos(a + sign * Math.PI / 2);
                const touchY = circle.cy + circle.r * Math.sin(a + sign * Math.PI / 2);
                tangents.push({
                    x1: point.x,
                    y1: point.y,
                    x2: touchX,
                    y2: touchY
                });
            }
            return tangents;
        }
        
        // Funkce pro kolmici
        function perpendicular(line, point) {
            const dx = line.x2 - line.x1;
            const dy = line.y2 - line.y1;
            const len = Math.sqrt(dx * dx + dy * dy);
            
            // Smƒõrov√Ω vektor kolmice
            const px = -dy / len * 50; // D√©lka kolmice 50mm
            const py = dx / len * 50;
            
            return {
                type: 'line',
                x1: point.x - px,
                y1: point.y - py,
                x2: point.x + px,
                y2: point.y + py
            };
        }
        
        // Funkce pro rovnobƒõ≈æku
        function parallel(line, distance) {
            const dx = line.x2 - line.x1;
            const dy = line.y2 - line.y1;
            const len = Math.sqrt(dx * dx + dy * dy);
            
            const offsetX = -dy / len * distance;
            const offsetY = dx / len * distance;
            
            return {
                type: 'line',
                x1: line.x1 + offsetX,
                y1: line.y1 + offsetY,
                x2: line.x2 + offsetX,
                y2: line.y2 + offsetY
            };
        }
        
        // O≈ô√≠znut√≠ ƒç√°ry
        function trimLine(line, cutPoint) {
            const dx = line.x2 - line.x1;
            const dy = line.y2 - line.y1;
            const len = Math.sqrt(dx * dx + dy * dy);
            
            // Fix: Use cutPoint instead of w, and line instead of s
            const t = ((cutPoint.x - line.x1) * dx + (cutPoint.y - line.y1) * dy) / (len * len);
            
            if (t < 0.5) {
                return {type: 'line', x1: cutPoint.x, y1: cutPoint.y, x2: line.x2, y2: line.y2};
            } else {
                return {type: 'line', x1: line.x1, y1: line.y1, x2: cutPoint.x, y2: cutPoint.y};
            }
        }
        
        // --- V√Ωpoƒçet zrcadlov√©ho bodu ---
        function getMirrorPoint(p, line) {
            // Line: A*x + B*y + C = 0
            // A = y1 - y2
            // B = x2 - x1
            // C = -A*x1 - B*y1
            const A = line.y1 - line.y2;
            const B = line.x2 - line.x1;
            const C = -A * line.x1 - B * line.y1;
            
            const m = A*A + B*B;
            if (m === 0) return {x: p.x, y: p.y};
            
            const f = -2 * (A * p.x + B * p.y + C) / m;
            return {
                x: p.x + f * A,
                y: p.y + f * B
            };
        }

        // --- NOV√Å FUNKCE PRO TOGGLE PAN ---
        function togglePan() {
            if (mode === 'pan') {
                mode = null; // Vypnout m√≥d
                const btn = document.getElementById('btnPanCanvas');
                if (btn) btn.classList.remove('active');
                
                const info = document.getElementById('modeInfo');
                if (info) info.classList.remove('show');
            } else {
                setMode('pan');
            }
        }
        
        function setMode(m) {
            mode = m;
            // Neodstra≈àovat active z tlaƒç√≠tek kategori√≠ (zaƒç√≠naj√≠ btnCat)
            document.querySelectorAll('.tool-btn').forEach(b => {
                if (!b.id.startsWith('btnCat')) b.classList.remove('active');
            });
            // Odstranit active i z nov√©ho tlaƒç√≠tka na pl√°tnƒõ, pokud p≈ôep√≠n√°m jinam
            const btnPan = document.getElementById('btnPanCanvas');
            if(btnPan) btnPan.classList.remove('active');

            const btnMap = {
                'pan': 'btnPanCanvas',
                'line': 'btnLine',
                'circle': 'btnCircle',
                'point': 'btnPoint',
                'trim': 'btnTrim',
                'extend': 'btnExtend',
                'tangent': 'btnTangent',
                'perpendicular': 'btnPerpendicular',
                'parallel': 'btnParallel',
                'offset': 'btnOffset',
                'mirror': 'btnMirror',
                'erase': 'btnErase',
                'measure': 'btnMeasure',
                'select': 'btnAiSelect', 
                'ai': 'btnCatAi'
            };
            
            if (btnMap[m] && document.getElementById(btnMap[m])) {
                document.getElementById(btnMap[m]).classList.add('active');
            }
            
            // Highlight tlaƒç√≠tka uvnit≈ô AI panelu (ruƒçn√≠ stylov√°n√≠)
            const btnAiSelect = document.getElementById('btnAiSelect');
            if (btnAiSelect) {
                if (m === 'select') {
                    btnAiSelect.style.background = '#7c3aed';
                    btnAiSelect.style.borderColor = '#8b5cf6';
                    btnAiSelect.style.color = '#fff';
                } else {
                    btnAiSelect.style.background = '#333';
                    btnAiSelect.style.borderColor = '#444';
                    btnAiSelect.style.color = '#ccc';
                }
            }
            
            // Zobrazit n√°povƒõdu pro aktu√°ln√≠ m√≥d
            const modeInfo = document.getElementById('modeInfo');
            const infoTexts = {
                'select': 'üëÜ Klikni na objekty pro v√Ωbƒõr (Shift pro v√≠cen√°sobn√Ω v√Ωbƒõr)',
                'point': 'üìç Klikni pro vytvo≈ôen√≠ bodu',
                'line': 'üìè Klikni pro 1. bod, pak klikni pro 2. bod',
                'circle': '‚≠ï Klikni st≈ôed, klikni obvod (pak zadej polomƒõr)',
                'tangent': '‚üÇ Klikni bod, pak kru≈ænici',
                'perpendicular': '‚î¥ Klikni bod, pak ƒç√°ru',
                'parallel': '‚à• Klikni bod, pak ƒç√°ru',
                'trim': '‚úÇÔ∏è Klikni na ƒç√°ru pro o≈ô√≠znut√≠',
                'extend': '‚ÜîÔ∏è Klikni na ƒç√°ru pro prota≈æen√≠ do pr≈Øseƒç√≠ku',
                'offset': '‚áÑ Klikni na ƒç√°ru pro odsazen√≠',
                'mirror': 'ü™û Klikni na objekt (zdroj), pak na ƒç√°ru (osa)',
                'erase': 'üóëÔ∏è Klikni na objekt pro smaz√°n√≠',
                'measure': 'üìè Klikni na objekt pro zobrazen√≠ rozmƒõr≈Ø',
                'pan': '‚úã T√°hni pro posun pohledu',
                'ai': '‚ú® Napi≈° p≈ô√≠kaz pro Gemini AI'
            };
            
            if (modeInfo) {
                if (infoTexts[m]) {
                    modeInfo.textContent = infoTexts[m];
                    modeInfo.classList.add('show');
                    // N√°povƒõda zmiz√≠ po 5s, pokud to nen√≠ pan nebo select
                    if (m !== 'pan' && m !== 'select') {
                        setTimeout(() => { 
                            if(modeInfo) modeInfo.classList.remove('show');
                        }, 5000);
                    }
                } else {
                    modeInfo.classList.remove('show');
                }
            }
            
            // Pokud jdu z select m√≥du pryƒç, NEMA≈ΩU v√Ωbƒõr, aby ho AI vidƒõlo
            // Reset kreslic√≠ho stavu
            selectedShape = null;
            startPt = null;
            drawing = false;
            tempShape = null;
            draw();
        }
        
        window.toggleAiSelect = function() {
            const isSelecting = mode === 'select';
            
            if (isSelecting) {
                // Konƒç√≠me v√Ωbƒõr, vrac√≠me se do AI chatu
                setMode('pan'); 
                window.toggleAiPanel(true);
            } else {
                // Zaƒç√≠n√°me v√Ωbƒõr, minimalizujeme panel
                setMode('select');
                window.toggleAiPanel(false);
            }
        }
        
        window.toggleAiPanel = function(showFull) {
            const flexStyle = showFull ? 'flex' : 'none';
            const blockStyle = showFull ? 'block' : 'none';
            
            const header = document.getElementById('aiHeaderRow');
            const history = document.getElementById('aiChatHistory');
            const input = document.getElementById('aiInputZone');
            const list = document.getElementById('aiSelectionList');
            
            if (header) header.style.display = flexStyle;
            if (history) history.style.display = flexStyle;
            if (input) input.style.display = blockStyle;
            // List is special: only show if we have items
            if (list) list.style.display = (showFull && selectedItems.length > 0) ? 'flex' : 'none';
        }

        window.clearSelection = function() {
            selectedItems = [];
            updateSelectionUI();
            draw();
            // Pokud jsme byli v re≈æimu v√Ωbƒõru, vr√°t√≠me pln√Ω panel, ale z≈Østaneme v re≈æimu (nebo ne? UX volba)
            // Zde radƒõji nech√°me u≈æivatele v re≈æimu v√Ωbƒõru, dokud neklikne znovu na tlaƒç√≠tko
        }

        function updateSelectionUI() {
            const selInfo = document.getElementById('aiSelectionInfo');
            const btnClear = document.getElementById('btnClearSelection');
            const list = document.getElementById('aiSelectionList');
            const count = selectedItems.length;
            
            if (selInfo) {
                selInfo.textContent = `${count} vybr√°no`;
                selInfo.style.display = count > 0 ? 'inline' : 'none';
            }
            if (btnClear) {
                btnClear.style.display = count > 0 ? 'block' : 'none';
            }
            
            // Update Chips List
            if (list) {
                list.innerHTML = '';
                if (count > 0 && mode !== 'select') { // Show list when NOT in selection mode (i.e. back in chat)
                    list.style.display = 'flex';
                    selectedItems.forEach(item => {
                        const chip = document.createElement('div');
                        chip.className = 'selection-chip';
                        chip.innerHTML = `<span class="letter-badge">${item.label}</span> ${item.category === 'point' ? 'Bod' : 'Tvar'}`;
                        list.appendChild(chip);
                    });
                } else {
                    list.style.display = 'none';
                }
            }
        }
        
        function changeScale() {
            const s = parseFloat(document.getElementById('scaleSelect').value);
            zoom = 2 * s;
            draw();
        }
        
        function changeAxisMode() {
            axisMode = document.getElementById('axisMode').value;
            window.axisMode = axisMode; // Sync for AI
            updateCoordinateLabels();
            draw();
        }
        
        function updateCoordinateLabels() {
            // Aktualizovat popisky podle re≈æimu
            const labels = axisMode === 'lathe' ? 
                {axis1: 'Z', axis2: 'X'} : 
                {axis1: 'X', axis2: 'Y'};
        }
        
        function updateGridSpacing() {
            gridSize = parseFloat(document.getElementById('gridSpacing').value);
            draw();
        }
        
        function setGridSpacing(size) {
            gridSize = size;
            document.getElementById('gridSpacing').value = size;
            draw();
        }
        
        // P≈ôep√≠n√°n√≠ rozbalovac√≠ch sekc√≠ v menu
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId + 'Section');
            const toggle = document.getElementById(sectionId + 'Toggle');
            
            if (section && toggle) {
                if (section.style.display === 'none') {
                    section.style.display = 'block';
                    toggle.textContent = '‚ñ≤';
                } else {
                    section.style.display = 'none';
                    toggle.textContent = '‚ñº';
                }
            }
        }
        
        // P≈ôep√≠n√°n√≠ sekc√≠ v panelu sou≈ôadnic
        function toggleCoordSection(sectionId) {
            const section = document.getElementById(sectionId);
            const toggle = document.getElementById(sectionId + 'Toggle');
            
            if (section && toggle) {
                if (section.style.display === 'none') {
                    section.style.display = 'block';
                    toggle.textContent = '‚ñ≤';
                } else {
                    section.style.display = 'none';
                    toggle.textContent = '‚ñº';
                }
            }
        }
        
        // P≈ôep√≠n√°n√≠ kategori√≠ n√°stroj≈Ø
        function showToolCategory(category) {
            const menuId = 'tools' + category.charAt(0).toUpperCase() + category.slice(1);
            const menuEl = document.getElementById(menuId);
            const btnId = 'btnCat' + category.charAt(0).toUpperCase() + category.slice(1);
            const btnEl = document.getElementById(btnId);
            
            // Pokud klikneme na ji≈æ aktivn√≠ kategorii, zav≈ôeme ji (toggle)
            if (currentCategory === category && menuEl.style.display !== 'none') {
                menuEl.style.display = 'none';
                if (btnEl) btnEl.classList.remove('active');
                currentCategory = null;
                if (category === 'ai') setMode('pan'); // Reset mode if closing AI
                return;
            }

            // Skr√Ωt v≈°echny submenu
            document.querySelectorAll('.tool-submenu').forEach(menu => {
                menu.style.display = 'none';
            });
            
            // Deaktivovat v≈°echna tlaƒç√≠tka
            document.querySelectorAll('.toolbar .tool-btn').forEach(btn => {
                if (btn.id && btn.id.startsWith('btnCat')) {
                    btn.classList.remove('active');
                }
            });
            
            // Zobrazit vybran√©
            if (menuEl) {
                menuEl.style.display = 'flex';
                if (btnEl) btnEl.classList.add('active');
                currentCategory = category;
                
                if (category === 'ai') {
                    setMode('pan'); // Defaultnƒõ Pan pro pohyb
                    window.toggleAiPanel(true); // Ensure full panel is shown
                    
                    // Focus na input p≈ôi otev≈ôen√≠
                    setTimeout(() => {
                        const input = document.getElementById('aiPrompt');
                        if(input) input.focus();
                    }, 200);
                    
                    // Aktualizovat info o v√Ωbƒõru
                    updateSelectionUI();
                }
            }
        }
        
        // Rychl√© p≈ôid√°n√≠ bodu ze sou≈ôadnic
        function quickAddPoint() {
            const z = parseFloat(document.getElementById('quickPointZ').value);
            let x = parseFloat(document.getElementById('quickPointX').value);
            if (isNaN(z) || isNaN(x)) {
                alert('Zadej platn√© sou≈ôadnice');
                return;
            }
            points.push({x: z, y: x});
            document.getElementById('quickPointZ').value = '';
            document.getElementById('quickPointX').value = '';
            updateSnapPoints();
            draw();
        }
        
        // Rychl√© p≈ôid√°n√≠ kru≈ænice ze sou≈ôadnic
        function quickAddCircle() {
            const z = parseFloat(document.getElementById('quickCircleZ').value);
            let x = parseFloat(document.getElementById('quickCircleX').value);
            const r = parseFloat(document.getElementById('quickCircleR').value);
            if (isNaN(z) || isNaN(x) || isNaN(r)) {
                alert('Zadej platn√© sou≈ôadnice a polomƒõr');
                return;
            }
            shapes.push({type: 'circle', cx: z, cy: x, r: r});
            document.getElementById('quickCircleZ').value = '';
            document.getElementById('quickCircleX').value = '';
            document.getElementById('quickCircleR').value = '';
            updateSnapPoints();
            draw();
        }
        
        function clearAll() {
            if (confirm('Vymazat v≈°e?')) {
                shapes = [];
                points = [];
                selectedItems = [];
                updateSnapPoints();
                draw();
            }
        }
        
        function calculateIntersections() {
            const intersections = [];
            
            // Naj√≠t v≈°echny pr≈Øseƒç√≠ky mezi objekty
            for (let i = 0; i < shapes.length; i++) {
                for (let j = i + 1; j < shapes.length; j++) {
                    const s1 = shapes[i];
                    const s2 = shapes[j];
                    
                    let pts = [];
                    
                    // ƒå√°ra √ó Kru≈ænice
                    if (s1.type === 'line' && s2.type === 'circle') {
                        pts = intersectLineCircle(s1, s2);
                    } else if (s1.type === 'circle' && s2.type === 'line') {
                        pts = intersectLineCircle(s2, s1);
                    }
                    // Kru≈ænice √ó Kru≈ænice
                    else if (s1.type === 'circle' && s2.type === 'circle') {
                        pts = intersectCircleCircle(s1, s2);
                    }
                    // ƒå√°ra √ó ƒå√°ra
                    else if (s1.type === 'line' && s2.type === 'line') {
                        const pt = lineIntersection(s1, s2);
                        if (pt) pts = [pt];
                    }
                    
                    // P≈ôidat pr≈Øseƒç√≠ky do seznamu
                    pts.forEach(pt => {
                        intersections.push({
                            x: pt.x,
                            y: pt.y,
                            shape1: i,
                            shape2: j
                        });
                    });
                }
            }
            
            if (intersections.length === 0) {
                alert('Nebyly nalezeny ≈æ√°dn√© pr≈Øseƒç√≠ky.');
                return;
            }
            
            // Vytvo≈ôit zpr√°vu s v√Ωsledky
            const axisMode = window.axisMode || 'lathe';
            let message = `Nalezeno ${intersections.length} pr≈Øseƒç√≠k${intersections.length > 1 ? '≈Ø' : ''}:\n\n`;
            
            intersections.forEach((pt, idx) => {
                const displayX = axisMode === 'lathe' ? pt.y : pt.x;
                const displayY = axisMode === 'lathe' ? pt.x : pt.y;
                
                if (axisMode === 'lathe') {
                    message += `${idx + 1}. Z${displayY.toFixed(2)} X${displayX.toFixed(2)}\n`;
                } else {
                    message += `${idx + 1}. X${displayX.toFixed(2)} Y${displayY.toFixed(2)}\n`;
                }
            });
            
            alert(message);
            
            // Volitelnƒõ: p≈ôidat pr≈Øseƒç√≠ky jako body
            const addPoints = confirm('Chcete p≈ôidat pr≈Øseƒç√≠ky jako konstrukƒçn√≠ body?');
            if (addPoints) {
                intersections.forEach(pt => {
                    points.push({x: pt.x, y: pt.y, label: '‚äó'});
                });
                updateSnapPoints();
                draw();
            }
        }
        window.calculateIntersections = calculateIntersections;
        
        function undo() {
            shapes.pop();
            updateSnapPoints();
            draw();
        }
        
        function resetView() {
            zoom = 2;
            panX = canvas.width / 2;
            panY = canvas.height / 2;
            draw();
        }
        
        function exportPNG() {
            const link = document.createElement('a');
            link.download = 'soustruzeni_' + Date.now() + '.png';
            link.href = canvas.toDataURL();
            link.click();
        }
        
        function saveProject() {
            // Vytvo≈ôit objekt s projektem
            const project = {
                version: '1.0',
                date: new Date().toISOString(),
                settings: {
                    axisMode: axisMode,
                    xMeasureMode: xMeasureMode,
                    gridSize: gridSize,
                    zoom: zoom,
                    panX: panX,
                    panY: panY
                },
                shapes: shapes,
                points: points
            };
            
            // P≈ôev√©st na JSON
            const json = JSON.stringify(project, null, 2);
            
            // Vytvo≈ôit blob a st√°hnout
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            
            // Generovat n√°zev souboru s datem a ƒçasem
            const now = new Date();
            const dateStr = now.toISOString().slice(0, 10); // YYYY-MM-DD
            const timeStr = now.toTimeString().slice(0, 5).replace(':', '-'); // HH-MM
            link.download = `projekt_${dateStr}_${timeStr}.json`;
            
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
            
            // Zobrazit potvrzen√≠
            const modeInfo = document.getElementById('modeInfo');
            if (modeInfo) {
                modeInfo.textContent = 'üíæ Projekt ulo≈æen!';
                modeInfo.classList.add('show');
                setTimeout(() => {
                    modeInfo.classList.remove('show');
                }, 3000);
            }
        }
        
        function loadProject(input) {
            const file = input.files[0];
            if (!file) return;
            
            // Zkontrolovat p≈ô√≠ponu
            if (!file.name.endsWith('.json')) {
                alert('‚ùå Chyba: M≈Ø≈æe≈° naƒç√≠st pouze .json soubory!');
                input.value = '';
                return;
            }
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const project = JSON.parse(e.target.result);
                    
                    // Validace struktury
                    if (!project.shapes || !Array.isArray(project.shapes)) {
                        throw new Error('Neplatn√° struktura projektu - chyb√≠ pole shapes');
                    }
                    
                    // Potvrdit naƒçten√≠ (pokud u≈æ nƒõco nakreslen√©ho)
                    if (shapes.length > 0 || points.length > 0) {
                        const confirm = window.confirm(
                            '‚ö†Ô∏è Naƒçten√≠m projektu p≈ôep√≠≈°e≈° aktu√°ln√≠ kreslen√≠.\n\n' +
                            'Chce≈° pokraƒçovat?'
                        );
                        if (!confirm) {
                            input.value = '';
                            return;
                        }
                    }
                    
                    // Naƒç√≠st data
                    shapes = project.shapes || [];
                    points = project.points || [];
                    
                    // Naƒç√≠st nastaven√≠ (pokud existuj√≠)
                    if (project.settings) {
                        if (project.settings.axisMode) {
                            axisMode = project.settings.axisMode;
                            const axisSelect = document.getElementById('axisMode');
                            if (axisSelect) axisSelect.value = axisMode;
                            updateCoordinateLabels();
                        }
                        
                        if (project.settings.xMeasureMode) {
                            xMeasureMode = project.settings.xMeasureMode;
                            const xMeasureSelect = document.getElementById('xMeasureSelect');
                            if (xMeasureSelect) xMeasureSelect.value = xMeasureMode;
                        }
                        
                        if (project.settings.gridSize !== undefined) {
                            gridSize = project.settings.gridSize;
                            const gridInput = document.getElementById('gridSpacing');
                            if (gridInput) gridInput.value = gridSize;
                        }
                        
                        if (project.settings.zoom !== undefined) {
                            zoom = project.settings.zoom;
                        }
                        
                        if (project.settings.panX !== undefined) {
                            panX = project.settings.panX;
                        }
                        
                        if (project.settings.panY !== undefined) {
                            panY = project.settings.panY;
                        }
                    }
                    
                    // Aktualizovat snap body a p≈ôekreslit
                    updateSnapPoints();
                    draw();
                    
                    // Zobrazit potvrzen√≠
                    const modeInfo = document.getElementById('modeInfo');
                    if (modeInfo) {
                        modeInfo.textContent = `‚úÖ Projekt naƒçten! (${shapes.length} tvar≈Ø, ${points.length} bod≈Ø)`;
                        modeInfo.classList.add('show');
                        setTimeout(() => {
                            modeInfo.classList.remove('show');
                        }, 4000);
                    }
                    
                } catch (error) {
                    console.error('Chyba p≈ôi naƒç√≠t√°n√≠ projektu:', error);
                    alert('‚ùå Chyba p≈ôi naƒç√≠t√°n√≠ projektu:\n\n' + error.message);
                }
                
                // Vyƒçistit input
                input.value = '';
            };
            
            reader.onerror = function() {
                alert('‚ùå Chyba p≈ôi ƒçten√≠ souboru!');
                input.value = '';
            };
            
            reader.readAsText(file);
        }
        
        function toggleSelection(item) {
            const index = selectedItems.findIndex(i => {
                if (item.category === 'point' && i.category === 'point') {
                    // Porovn√°n√≠ sou≈ôadnic bodu
                    return Math.abs(item.x - i.x) < 0.0001 && Math.abs(item.y - i.y) < 0.0001;
                } else if (item.category === 'shape' && i.category === 'shape') {
                    // Porovn√°n√≠ reference objektu
                    return item.ref === i.ref;
                }
                return false;
            });

            if (index > -1) {
                // Remove
                selectedItems.splice(index, 1);
            } else {
                // Add with label
                const labels = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                // Find first unused label or just use length
                const label = labels[selectedItems.length % labels.length];
                
                selectedItems.push({...item, label: label});
            }
            
            updateSelectionUI();
        }
        
        // === TOUCH CURSOR FUNKCE ===
        function showTouchCursor(screenX, screenY) {
            const touchCursor = document.getElementById('touchCursor');
            if (!touchCursor) return;
            
            touchCursorActive = true;
            touchCursor.classList.add('active');
            
            // Um√≠stit k≈ô√≠≈æek nad prst s offsetem
            touchCursor.style.left = screenX + 'px';
            touchCursor.style.top = (screenY - touchCursorOffset) + 'px';
        }
        
        function hideTouchCursor() {
            const touchCursor = document.getElementById('touchCursor');
            if (!touchCursor) return;
            
            touchCursorActive = false;
            touchCursor.classList.remove('active');
        }
        
        function updateTouchCursor(screenX, screenY) {
            if (!touchCursorActive) return;
            
            const touchCursor = document.getElementById('touchCursor');
            if (!touchCursor) return;
            
            touchCursor.style.left = screenX + 'px';
            touchCursor.style.top = (screenY - touchCursorOffset) + 'px';
        }
        
        function getTouchCursorPosition(screenX, screenY) {
            // Pokud je touch cursor aktivn√≠, vr√°tit pozici k≈ô√≠≈æku m√≠sto prstu
            if (touchCursorActive) {
                return {
                    x: screenX,
                    y: screenY - touchCursorOffset
                };
            }
            return { x: screenX, y: screenY };
        }

        canvas.addEventListener('pointerdown', e => {
            const rect = canvas.getBoundingClientRect();
            const sx = e.clientX - rect.left;
            const sy = e.clientY - rect.top;
            
            // Touch cursor pro dotykov√° za≈ô√≠zen√≠
            if (e.pointerType === 'touch' && mode !== 'pan') {
                // Spustit timeout pro zobrazen√≠ touch cursoru
                touchCursorTimeout = setTimeout(() => {
                    showTouchCursor(sx, sy);
                }, touchCursorDelay);
            }
            
            let w = screenToWorld(sx, sy);
            
            // P≈ôichycen√≠ - V≈ΩDY pro v≈°echny m√≥dy kromƒõ 'pan'
            let snapResult = {point: w, snapInfo: null};
            if (mode !== 'pan') {
                snapResult = snapPoint(w);
                w = snapResult.point;
            }
            
            // Aktualizace panelu snap-info (≈ælut√Ω panel) p≈ôi kliknut√≠
            const snapInfoEl = document.getElementById('snapInfo');
            let zVal = w.x.toFixed(2);
            let xVal = w.y.toFixed(2); // Vnit≈ôn√≠ hodnota (polomƒõr)
            
            // Zobrazen√≠ pro u≈æivatele
            let displayX = xVal;
            if (xMeasureMode === 'diameter') displayX = (parseFloat(xVal) * 2).toFixed(2);
            
            let infoText = "";
            
            if (axisMode === 'lathe') {
                infoText = `Oznaƒçeno: Z=${zVal} X=${displayX} mm`;
            } else {
                infoText = `Oznaƒçeno: X=${zVal} Y=${displayX} mm`;
            }
            
            if (snapResult.snapInfo) {
                 if (snapResult.snapInfo.type === 'point') infoText += ' (bod)';
                 else if (snapResult.snapInfo.type === 'endpoint') infoText += ' (konec)';
                 else if (snapResult.snapInfo.type === 'center') infoText += ' (st≈ôed)';
                 else if (snapResult.snapInfo.type === 'intersection') infoText += ' (pr≈Øseƒç√≠k)';
                 else if (snapResult.snapInfo.type === 'grid') infoText += ' (m≈ô√≠≈æka)';
            }
            
            if (snapInfoEl) {
                snapInfoEl.textContent = infoText;
                snapInfoEl.classList.add('show');
            }

            if (mode === 'select') {
                // LOGIKA V√ùBƒöRU
                let hitFound = false;

                // 1. Zkusit vybrat bod (priorita) - snapnut√Ω bod
                if (snapResult.snapInfo && snapResult.snapInfo.type !== 'grid') {
                    toggleSelection({
                        category: 'point',
                        type: snapResult.snapInfo.type,
                        x: snapResult.snapInfo.x,
                        y: snapResult.snapInfo.y
                    });
                    hitFound = true;
                } 
                
                // 2. Pokud nen√≠ bod, zkusit vybrat tvar (ƒç√°ra/kru≈ænice)
                if (!hitFound) {
                    // Naj√≠t ƒç√°ru/kru≈ænici pod kurzorem (bez snapu)
                    const rawW = screenToWorld(sx, sy); // Pou≈æijeme syrov√© sou≈ôadnice pro hit test
                    
                    for (let s of shapes) {
                        let hit = false;
                        if (s.type === 'line') {
                            const dx = s.x2 - s.x1;
                            const dy = s.y2 - s.y1;
                            const len = Math.sqrt(dx * dx + dy * dy);
                            const dist = Math.abs((rawW.y - s.y1) * dx - (rawW.x - s.x1) * dy) / len;
                            if (dist < 10 / zoom) hit = true;
                        } else if (s.type === 'circle') {
                            const dist = Math.sqrt((rawW.x - s.cx) ** 2 + (rawW.y - s.cy) ** 2);
                            if (Math.abs(dist - s.r) < 10 / zoom) hit = true;
                        }
                        
                        if (hit) {
                            toggleSelection({
                                category: 'shape',
                                type: s.type,
                                ref: s
                            });
                            hitFound = true;
                            break; // Vybereme jen jeden tvar najednou
                        }
                    }
                }
                
                draw(); // P≈ôekreslit pro zobrazen√≠ v√Ωbƒõru
                return;
            }

            if (mode === 'pan') {
                drawing = true;
                lastTouch = {x: sx, y: sy};
            } else if (mode === 'point') {
                points.push(w);
                updateSnapPoints();
                draw();
            } else if (mode === 'line') {
                // KLIK-KLIK INTERAKCE PRO ƒå√ÅRU
                if (!startPt) {
                    // Prvn√≠ kliknut√≠
                    startPt = w;
                } else {
                    // Druh√© kliknut√≠ - dokonƒçen√≠
                    shapes.push({
                        type: 'line', 
                        x1: startPt.x, y1: startPt.y, 
                        x2: w.x, y2: w.y
                    });
                    startPt = null;
                    tempShape = null;
                    updateSnapPoints();
                }
                draw();
            } else if (mode === 'circle') {
                 // KLIK-KLIK INTERAKCE PRO KRU≈ΩNICI S MOD√ÅLEM
                if (!startPt) {
                    // Prvn√≠ kliknut√≠ - st≈ôed
                    startPt = w;
                } else {
                    // Druh√© kliknut√≠ - polomƒõr
                    const r = Math.sqrt((w.x - startPt.x) ** 2 + (w.y - startPt.y) ** 2);
                    if (r > 0) {
                        openCircleModal(startPt, r);
                    }
                    startPt = null;
                    tempShape = null;
                }
                draw();
            } else if (mode === 'tangent') {
                // Naj√≠t kru≈ænici pod kurzorem
                let foundCircle = null;
                for (let s of shapes) {
                    if (s.type === 'circle') {
                        const dist = Math.sqrt((w.x - s.cx) ** 2 + (w.y - s.cy) ** 2);
                        if (Math.abs(dist - s.r) < 5 / zoom) {
                            foundCircle = s;
                            break;
                        }
                    }
                }
                
                if (foundCircle && startPt) {
                    const tangents = tangentFromPoint(foundCircle, startPt);
                    if (tangents) {
                        tangents.forEach(t => shapes.push({type: 'line', ...t}));
                        startPt = null;
                        updateSnapPoints();
                        draw();
                    }
                } else {
                    startPt = w;
                    draw();
                }
            } else if (mode === 'perpendicular') {
                // Naj√≠t ƒç√°ru pod kurzorem
                let foundLine = null;
                for (let s of shapes) {
                    if (s.type === 'line') {
                        const dx = s.x2 - s.x1;
                        const dy = s.y2 - s.y1;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        const dist = Math.abs((w.y - s.y1) * dx - (w.x - s.x1) * dy) / len;
                        if (dist < 5 / zoom) {
                            foundLine = s;
                            break;
                        }
                    }
                }
                
                if (foundLine && startPt) {
                    shapes.push(perpendicular(foundLine, startPt));
                    startPt = null;
                    updateSnapPoints();
                    draw();
                } else {
                    startPt = w;
                    draw();
                }
            } else if (mode === 'parallel') {
                let foundLine = null;
                for (let s of shapes) {
                    if (s.type === 'line') {
                        const dx = s.x2 - s.x1;
                        const dy = s.y2 - s.y1;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        const dist = Math.abs((w.y - s.y1) * dx - (w.x - s.x1) * dy) / len;
                        if (dist < 5 / zoom) {
                            foundLine = s;
                            break;
                        }
                    }
                }
                
                if (foundLine && startPt) {
                    const offsetDist = 10; // Default or prompt user
                    shapes.push(parallel(foundLine, offsetDist));
                    startPt = null;
                    updateSnapPoints();
                    draw();
                } else {
                    startPt = w;
                    draw();
                }
            } else if (mode === 'trim') {
                // Naj√≠t ƒç√°ru k o≈ô√≠znut√≠
                for (let i = 0; i < shapes.length; i++) {
                    const s = shapes[i];
                    if (s.type === 'line') {
                        const dx = s.x2 - s.x1;
                        const dy = s.y2 - s.y1;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        const t = ((w.x - s.x1) * dx + (w.y - s.y1) * dy) / (len * len);
                        if (t >= 0 && t <= 1) {
                            const px = s.x1 + t * dx;
                            const py = s.y1 + t * dy;
                            const dist = Math.sqrt((w.x - px) ** 2 + (w.y - py) ** 2);
                            if (dist < 5 / zoom) {
                                shapes[i] = trimLine(s, w);
                                updateSnapPoints();
                                draw();
                                break;
                            }
                        }
                    }
                }
            } else if (mode === 'offset') {
                // Odsazen√≠ objektu
                for (let s of shapes) {
                    if (s.type === 'line') {
                        const dx = s.x2 - s.x1;
                        const dy = s.y2 - s.y1;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        const dist = Math.abs((w.y - s.y1) * dx - (w.x - s.x1) * dy) / len;
                        if (dist < 5 / zoom) {
                            // Zeptat se u≈æivatele na vzd√°lenost offsetu
                            const userInput = prompt('Zadej vzd√°lenost odsazen√≠ (mm):', offsetDistance);
                            if (userInput !== null) {
                                const newDist = parseFloat(userInput);
                                if (!isNaN(newDist) && newDist > 0) {
                                    offsetDistance = newDist; // Ulo≈æit pro p≈ô√≠≈°tƒõ
                                    shapes.push(parallel(s, offsetDistance));
                                    updateSnapPoints();
                                    draw();
                                } else {
                                    alert('Neplatn√° hodnota! Zadej kladn√© ƒç√≠slo.');
                                }
                            }
                            break;
                        }
                    }
                }
            } else if (mode === 'mirror') {
                // KROK 1: Vybrat objekt k zrcadlen√≠ (Line, Circle, Point)
                if (!selectedShape) {
                    let found = null;
                    
                    // Zkusit body
                    /* 
                       (Pozn√°mka: Pro body pou≈æ√≠v√°me pole 'points', ale pro zjednodu≈°en√≠ 
                       v tomto m√≥du zat√≠m zrcadl√≠me hlavnƒõ 'shapes'. Pokud by se mƒõly zrcadlit
                       i konstrukƒçn√≠ body, museli bychom prohled√°vat i pole points.)
                    */

                    // Hledat v shapes
                    for (let s of shapes) {
                        if (s.type === 'line') {
                            const dx = s.x2 - s.x1;
                            const dy = s.y2 - s.y1;
                            const len = Math.sqrt(dx * dx + dy * dy);
                            const dist = Math.abs((w.y - s.y1) * dx - (w.x - s.x1) * dy) / len;
                            if (dist < 5 / zoom) {
                                found = s;
                                break;
                            }
                        } else if (s.type === 'circle') {
                            const dist = Math.sqrt((w.x - s.cx) ** 2 + (w.y - s.cy) ** 2);
                            if (Math.abs(dist - s.r) < 5 / zoom) {
                                found = s;
                                break;
                            }
                        }
                    }
                    
                    if (found) {
                        selectedShape = found;
                        draw(); // P≈ôekreslit pro zv√Ωraznƒõn√≠
                    }
                } 
                // KROK 2: Vybrat osu zrcadlen√≠ (mus√≠ to b√Ωt Line)
                else {
                    let axisLine = null;
                    for (let s of shapes) {
                        if (s.type === 'line') {
                            const dx = s.x2 - s.x1;
                            const dy = s.y2 - s.y1;
                            const len = Math.sqrt(dx * dx + dy * dy);
                            const dist = Math.abs((w.y - s.y1) * dx - (w.x - s.x1) * dy) / len;
                            if (dist < 5 / zoom) {
                                axisLine = s;
                                break;
                            }
                        }
                    }
                    
                    if (axisLine) {
                        // Prov√©st zrcadlen√≠
                        if (selectedShape.type === 'line') {
                            const p1 = getMirrorPoint({x: selectedShape.x1, y: selectedShape.y1}, axisLine);
                            const p2 = getMirrorPoint({x: selectedShape.x2, y: selectedShape.y2}, axisLine);
                            shapes.push({
                                type: 'line',
                                x1: p1.x, y1: p1.y,
                                x2: p2.x, y2: p2.y
                            });
                        } else if (selectedShape.type === 'circle') {
                            const c = getMirrorPoint({x: selectedShape.cx, y: selectedShape.cy}, axisLine);
                            shapes.push({
                                type: 'circle',
                                cx: c.x, cy: c.y,
                                r: selectedShape.r
                            });
                        }
                        
                        // Reset
                        selectedShape = null;
                        updateSnapPoints();
                        draw();
                    }
                }
            } else if (mode === 'erase') {
                // GUMA - smazat objekt
                let foundIndex = -1;
                
                // Hledat v shapes
                for (let i = 0; i < shapes.length; i++) {
                    const s = shapes[i];
                    if (s.type === 'line') {
                        const dx = s.x2 - s.x1;
                        const dy = s.y2 - s.y1;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        const dist = Math.abs((w.y - s.y1) * dx - (w.x - s.x1) * dy) / len;
                        if (dist < 5 / zoom) {
                            foundIndex = i;
                            break;
                        }
                    } else if (s.type === 'circle') {
                        const dist = Math.sqrt((w.x - s.cx) ** 2 + (w.y - s.cy) ** 2);
                        if (Math.abs(dist - s.r) < 5 / zoom) {
                            foundIndex = i;
                            break;
                        }
                    }
                }
                
                if (foundIndex !== -1) {
                    shapes.splice(foundIndex, 1);
                    updateSnapPoints();
                    draw();
                }
                
                // Hledat v points
                for (let i = 0; i < points.length; i++) {
                    const p = points[i];
                    const dist = Math.sqrt((w.x - p.x) ** 2 + (w.y - p.y) ** 2);
                    if (dist < 5 / zoom) {
                        points.splice(i, 1);
                        updateSnapPoints();
                        draw();
                        break;
                    }
                }
            } else if (mode === 'extend') {
                // PROTA≈ΩEN√ç - prodlou≈æit ƒç√°ru do pr≈Øseƒç√≠ku
                for (let i = 0; i < shapes.length; i++) {
                    const s = shapes[i];
                    if (s.type === 'line') {
                        const dx = s.x2 - s.x1;
                        const dy = s.y2 - s.y1;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        const dist = Math.abs((w.y - s.y1) * dx - (w.x - s.x1) * dy) / len;
                        if (dist < 5 / zoom) {
                            // Zjistit, kter√Ωm koncem prodlou≈æit (podle bl√≠zkosti ke kurzoru)
                            const dist1 = Math.sqrt((w.x - s.x1) ** 2 + (w.y - s.y1) ** 2);
                            const dist2 = Math.sqrt((w.x - s.x2) ** 2 + (w.y - s.y2) ** 2);
                            
                            // Naj√≠t nejbli≈æ≈°√≠ pr≈Øseƒç√≠k
                            let closestIntersect = null;
                            let minDist = Infinity;
                            
                            for (let j = 0; j < shapes.length; j++) {
                                if (i === j) continue;
                                const other = shapes[j];
                                
                                if (other.type === 'line') {
                                    const isect = lineLineIntersect(s, other);
                                    if (isect) {
                                        const d = (dist1 < dist2) 
                                            ? Math.sqrt((isect.x - s.x1) ** 2 + (isect.y - s.y1) ** 2)
                                            : Math.sqrt((isect.x - s.x2) ** 2 + (isect.y - s.y2) ** 2);
                                        if (d < minDist) {
                                            minDist = d;
                                            closestIntersect = isect;
                                        }
                                    }
                                } else if (other.type === 'circle') {
                                    const isects = lineCircleIntersect(s, other);
                                    for (const isect of isects) {
                                        const d = (dist1 < dist2)
                                            ? Math.sqrt((isect.x - s.x1) ** 2 + (isect.y - s.y1) ** 2)
                                            : Math.sqrt((isect.x - s.x2) ** 2 + (isect.y - s.y2) ** 2);
                                        if (d < minDist) {
                                            minDist = d;
                                            closestIntersect = isect;
                                        }
                                    }
                                }
                            }
                            
                            if (closestIntersect) {
                                if (dist1 < dist2) {
                                    s.x1 = closestIntersect.x;
                                    s.y1 = closestIntersect.y;
                                } else {
                                    s.x2 = closestIntersect.x;
                                    s.y2 = closestIntersect.y;
                                }
                                updateSnapPoints();
                                draw();
                            }
                            break;
                        }
                    }
                }
            } else if (mode === 'measure') {
                // Mƒö≈òEN√ç - zobrazit rozmƒõry objektu
                let found = false;
                
                // Mƒõ≈ôen√≠ kru≈ænice
                for (let s of shapes) {
                    if (s.type === 'circle') {
                        const dist = Math.sqrt((w.x - s.cx) ** 2 + (w.y - s.cy) ** 2);
                        if (Math.abs(dist - s.r) < 5 / zoom) {
                            const displayR = (xMeasureMode === 'diameter') ? s.r * 2 : s.r;
                            const label = (xMeasureMode === 'diameter') ? '‚åÄ' : 'R';
                            alert(`Kru≈ænice:\n${label} = ${displayR.toFixed(3)} mm\nSt≈ôed: Z=${s.cx.toFixed(3)}, X=${s.cy.toFixed(3)}`);
                            found = true;
                            break;
                        }
                    } else if (s.type === 'line') {
                        const dx = s.x2 - s.x1;
                        const dy = s.y2 - s.y1;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        const dist = Math.abs((w.y - s.y1) * dx - (w.x - s.x1) * dy) / len;
                        if (dist < 5 / zoom) {
                            alert(`√öseƒçka:\nD√©lka = ${len.toFixed(3)} mm\nOd [Z=${s.x1.toFixed(3)}, X=${s.y1.toFixed(3)}]\nDo [Z=${s.x2.toFixed(3)}, X=${s.y2.toFixed(3)}]`);
                            found = true;
                            break;
                        }
                    }
                }
                
                // Mƒõ≈ôen√≠ bodu
                if (!found) {
                    for (let p of points) {
                        const dist = Math.sqrt((w.x - p.x) ** 2 + (w.y - p.y) ** 2);
                        if (dist < 5 / zoom) {
                            const displayY = (xMeasureMode === 'diameter') ? p.y * 2 : p.y;
                            alert(`Bod:\nZ = ${p.x.toFixed(3)} mm\nX = ${displayY.toFixed(3)} mm`);
                            found = true;
                            break;
                        }
                    }
                }
            }
        });
        
        canvas.addEventListener('pointermove', e => {
            const rect = canvas.getBoundingClientRect();
            const sx = e.clientX - rect.left;
            const sy = e.clientY - rect.top;
            
            // Aktualizace touch cursoru p≈ôi pohybu
            if (touchCursorActive) {
                updateTouchCursor(sx, sy);
            }
            
            // Pokud je touch cursor aktivn√≠, pou≈æ√≠t jeho pozici
            let adjustedPos = getTouchCursorPosition(sx, sy);
            let w = screenToWorld(adjustedPos.x, adjustedPos.y);
            
            // P≈ôichycen√≠ - V≈ΩDY pro v≈°echny m√≥dy kromƒõ pan
            let snapResult = {point: w, snapInfo: null};
            if (mode !== 'pan') {
                snapResult = snapPoint(w);
                w = snapResult.point;
            }
            
            // Ulo≈æit aktu√°ln√≠ polohu kurzoru
            cursorPos = w;
            
            // Zobrazen√≠ sou≈ôadnic podle m√≥du
            let displayX = w.y;
            if (xMeasureMode === 'diameter') displayX *= 2;
            
            let coordText;
            if (axisMode === 'lathe') {
                coordText = `Z: ${w.x.toFixed(2)} | X: ${displayX.toFixed(2)} mm`;
            } else {
                coordText = `X: ${w.x.toFixed(2)} | Y: ${displayX.toFixed(2)} mm`;
            }
            const coordsEl = document.getElementById('coords');
            if (coordsEl) coordsEl.textContent = coordText;
            
            // Pokud jsme v m√≥du pan a t√°hneme
            if (mode === 'pan' && drawing && lastTouch) {
                panX += sx - lastTouch.x;
                panY += sy - lastTouch.y;
                lastTouch = {x: sx, y: sy};
                draw();
                return;
            }

            // Vykreslov√°n√≠ n√°hledu (ghosting) p≈ôi klik-klik metodƒõ
            if (startPt) {
                if (mode === 'line') {
                    let endX = w.x;
                    let endY = w.y;
                    
                    // Ortogon√°ln√≠ p≈ôichycen√≠ (vodorovn√©/svisl√© ƒç√°ry)
                    if (orthoMode) {
                        const dx = Math.abs(endX - startPt.x);
                        const dy = Math.abs(endY - startPt.y);
                        
                        // Pokud je ƒç√°ra skoro vodorovn√° nebo svisl√° (tolerance 1.5¬∞)
                        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                        
                        if (angle < 1.5 || angle > 178.5) {
                            // Vodorovn√° ƒç√°ra
                            endY = startPt.y;
                        } else if (angle > 88.5 && angle < 91.5) {
                            // Svisl√° ƒç√°ra
                            endX = startPt.x;
                        }
                    }
                    
                    tempShape = {type: 'line', x1: startPt.x, y1: startPt.y, x2: endX, y2: endY, ortho: (endX === startPt.x || endY === startPt.y)};
                    draw();
                } else if (mode === 'circle') {
                    const r = Math.sqrt((w.x - startPt.x) ** 2 + (w.y - startPt.y) ** 2);
                    tempShape = {type: 'circle', cx: startPt.x, cy: startPt.y, r};
                    draw();
                }
            }
        });
        
        canvas.addEventListener('pointerup', e => {
            // Zru≈°it timeout a skr√Ωt touch cursor
            if (touchCursorTimeout) {
                clearTimeout(touchCursorTimeout);
                touchCursorTimeout = null;
            }
            hideTouchCursor();
            
            // Pouze pro Pan ukonƒçujeme drag
            if (mode === 'pan') {
                drawing = false;
                lastTouch = null;
            }
            // Pro Line/Circle se nic nedƒõje na up, v≈°e ≈ôe≈°√≠ click (pointerdown)
        });
        
        canvas.addEventListener('pointercancel', e => {
            // Zru≈°it touch cursor p≈ôi p≈ôeru≈°en√≠ (nap≈ô. scroll, gesture)
            if (touchCursorTimeout) {
                clearTimeout(touchCursorTimeout);
                touchCursorTimeout = null;
            }
            hideTouchCursor();
        });
        
        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            const before = screenToWorld(mx, my);
            
            zoom *= e.deltaY < 0 ? 1.1 : 0.9;
            zoom = Math.max(0.1, Math.min(100, zoom));
            
            const after = screenToWorld(mx, my);
            panX += (after.x - before.x) * zoom;
            panY -= (after.y - before.y) * zoom;
            
            draw();
        }, {passive: false});
        
        let touches = [];
        canvas.addEventListener('touchstart', e => {
            touches = Array.from(e.touches);
            if (touches.length === 2) {
                e.preventDefault();
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                lastDist = Math.sqrt(dx * dx + dy * dy);
            }
        }, {passive: false});
        
        canvas.addEventListener('touchmove', e => {
            if (e.touches.length === 2) {
                e.preventDefault();
                const t = Array.from(e.touches);
                const dx = t[0].clientX - t[1].clientX;
                const dy = t[0].clientY - t[1].clientY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (lastDist > 0) {
                    const rect = canvas.getBoundingClientRect();
                    const cx = (t[0].clientX + t[1].clientX) / 2 - rect.left;
                    const cy = (t[0].clientY + t[1].clientY) / 2 - rect.top;
                    const before = screenToWorld(cx, cy);
                    
                    zoom *= dist > lastDist ? 1.02 : 0.98;
                    zoom = Math.max(0.1, Math.min(100, zoom));
                    
                    const after = screenToWorld(cx, cy);
                    panX += (after.x - before.x) * zoom;
                    panY -= (after.y - before.y) * zoom;
                    
                    draw();
                }
                lastDist = dist;
            }
        }, {passive: false});
        
        canvas.addEventListener('touchend', e => {
            lastDist = 0;
        });
        
        window.addEventListener('load', () => {
            init();
            updateCoordinateLabels();
        });
        window.addEventListener('resize', init);
        
        // Kl√°vesov√© zkratky
        window.addEventListener('keydown', (e) => {
            // Ctrl+S nebo Cmd+S - Ulo≈æit projekt
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveProject();
            }
            
            // Ctrl+O nebo Cmd+O - Otev≈ô√≠t projekt
            if ((e.ctrlKey || e.metaKey) && e.key === 'o') {
                e.preventDefault();
                document.getElementById('loadProjectInput').click();
            }
            
            // Ctrl+Z nebo Cmd+Z - Zpƒõt (Undo)
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            }
        });
    </script>
</body>
    </html>
